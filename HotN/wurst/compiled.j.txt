globals
integer i
real udg_zw
timer udg_t
integer udg_MeineAbility
unit udg_CasterVariable
group udg_UnverwundbarkeitsGruppe
hashtable udg_MeineHashtable
rect udg_Urspung
rect udg_Ziel
real udg_x1
real udg_x2
real udg_x3
real udg_x4
real udg_x5
real udg_y1
real udg_y4
real udg_y5
real udg_y3
real udg_y2
camerasetup gg_cam_Camera_001
camerasetup gg_cam_Camera_002
trigger gg_trg_Unbezeichneter_Ausl__ser_003
integer array LinkedList_dummy
integer array LinkedList_size
integer array LLEntry_elem
integer array LLEntry_prev
integer array LLEntry_next
integer array LLIterator_dummy
integer array LLIterator_current
string array Char_c2s
integer array Char_s2c
real array Char_width
integer Char_MAX_INDEX
real Char_DEFAULT_WIDTH
string Char_DEFAULT_STRING
hashtable Table_ht
integer Trigger_triggerData
timer array TimerUtils_freeTimers
integer TimerUtils_freeTimersCount
integer TimerUtils_timerData
integer TimerUtils_HELD
boolean array PrintingHelper_wantDebug
integer PrintingHelper_DEBUG_LEVEL
real PrintingHelper_DEBUG_MSG_DURATION
integer PrintingHelper_msgcount
string array PrintingHelper_texts
string String_charset
string String_numberset
integer String_numbersetlength
integer String_charsetlength
string array StringIterator_s
integer array StringIterator_currentpos
integer array StringIterator_stringLen
string array StringLines_s
integer array StringLines_currentLine
integer array StringLines_lineCount
integer array StringLines_lastIndex
real Maths_PI
real Maths_PI2
real Maths_PIHALF
real Maths_DEGTORAD
real Maths_RADTODEG
integer Basics_DUMMY_UNIT_ID
integer Basics_HEIGHT_ENABLER
integer Basics_TREE_RECOGNITION
integer Basics_LOCUST_ID
real Basics_ANIMATION_PERIOD
real Basics_MAX_COLLISION_SIZE
player Basics_DUMMY_PLAYER
player Basics_DUMMY_HOSTILE_PLAYER
integer Rect_sourceTable
integer Rect_regionData
timer array Camera_noiseTimer
integer TypeCasting_typecastdata
integer array BigNum_l_leaf
integer array BigNum_l_next
integer BigNum_l_count
integer array BigNum_list
integer array BigNum_base
unit array UnitIndex_u
integer array Event_first
integer array Event_last
boolean array Event_checkData
integer array Action_next
integer array Action_prev
integer array Action_ev
hashtable TList_ht
integer array TList_size
integer array TIterator_pos
integer array TIterator_list
real Terrain_MAX_RANGE
integer Terrain_DUMMY_ITEM_ID
location Terrain_tempLoc
rect Terrain_worldRect
real Terrain_minWorldX
real Terrain_minWorldY
real Terrain_maxWorldX
real Terrain_maxWorldY
item Terrain_dItem
rect Terrain_find
item array Terrain_hid
integer Terrain_hidMax
real Terrain_X
real Terrain_Y
unit Filter_filterCheckUnit
player Filter_filterCheckPlayer
integer array Helper_pow2
integer array Dot_a
integer array Dot_u
integer array Dot_source
real array Dot_damage
timer array Dot_t
integer LinkedListModule_first
integer LinkedListModule_last
integer LinkedListModule_size
integer array LinkedListModule_prev
integer array LinkedListModule_next
integer array this
integer array Buff_action
integer array Buff_u
integer array Buff_buffId
integer array Buff_abiId
effect array Buff_fx
timer array Buff_fxTimer
timer array Buff_t
integer array Buff_fxCounter
string array Buff_fxType
string array Buff_attachment
integer array this_2
string array AbilityDefinition_def
string array BuffDefinition_def
string array W3UDefinition_def
integer array SpellPreset_lvl
string ChannelSpellPreset_CHANNEL_ID
integer ChannelSpellPreset_visibleval
integer ChannelSpellPreset_targetimageval
integer ChannelSpellPreset_physicalspellval
integer ChannelSpellPreset_universalspellval
integer ChannelSpellPreset_uniquecastval
boolean array ChannelSpellPreset_visible
boolean array ChannelSpellPreset_targetimage
boolean array ChannelSpellPreset_physicalspell
boolean array ChannelSpellPreset_universalspell
boolean array ChannelSpellPreset_uniquecast
integer array ChannelSpellPreset_optionval
string SpellDesignConfig_TITLECOLOR
string SpellDesignConfig_TITLE_COOLDOWN
string SpellDesignConfig_TITLE_TTYPE
string SpellDesignConfig_TITLE_EFFECT
hashtable array Table3D_ht
integer array Table3D_key3IndexSize
integer Array_currentSize
integer array Array_content
integer array Array_pos
integer array Array_size
string DebugFile_path
string DebugFile_filetype
integer DebugFile_lastSavedFile
string array DebugFile_filename
string array DebugFile_buffer
integer array DebugFile_content
integer array DebugFile_currentLine
hashtable HashMap_ht
timer array CallbackPeriodic_t
timer array CallbackCounted_t
integer array CallbackCounted_count
integer array CallbackCounted_maxCount
timer Setup_timeTest
integer Setup_maxBonSize
integer Setup_attackRaw_raw
integer Setup_attackRaw_size
integer Setup_attackSpeedRaw_raw
integer Setup_attackSpeedRaw_size
integer Setup_armorRaw_raw
integer Setup_armorRaw_size
integer Setup_lifeRaw_raw
integer Setup_lifeRaw_size
integer Setup_manaRaw_raw
integer Setup_manaRaw_size
integer Setup_agiRaw_raw
integer Setup_agiRaw_size
integer Setup_strRaw_raw
integer Setup_strRaw_size
integer Setup_intRaw_raw
integer Setup_intRaw_size
integer Setup_lifeRegRaw_raw
integer Setup_lifeRegRaw_size
integer Setup_manaRegRaw_raw
integer Setup_manaRegRaw_size
integer array Setup_attackPerm
integer Setup_preloadAbi
item array Setup_permAttackTome
integer Setup_permAttackTomeId
integer Setup_permAttackNegTomeId
item Setup_permAttackNegTome
integer Setup_infoFile
integer Setup_errorFile
integer Setup_debugFile
string Setup_charMap
integer Setup_allPlayers
string Setup_team1
string Setup_team2
real Setup_recycleGraveyard_x
real Setup_recycleGraveyard_y
real Setup_menuStart_x
real Setup_menuStart_y
hashtable Setup_trackBlacklist
trigger Setup_trackableTrackTrigger
trigger Setup_trackableHitTrigger
trigger Setup_trackableDoubleHitTrigger
integer Setup_trackableMap
integer Setup_menuHeight
integer Setup_menuWidth
real Setup_abilityLoadTime
real Setup_abilityLoadTimeLevelBonus
integer InstanceBoard_classes
hashtable InstanceBoard_ht
multiboard InstanceBoard_mb
integer array InstanceBoard_count
string array InstanceBoard_nameOfClass
integer array TextTag_u
texttag array TextTag_tt
timer array TextTag_t
real array TextTag_amount
integer array TextTag_tType
integer ShowInstances_classId
string array Colors_hexs
integer Colors_decs
integer array Colors_playercolors
integer array Colors_playercolors_2
integer array Colors_playercolors_3
integer array ShieldList_first
integer array ShieldList_last
real array ShieldList_shieldSum
integer array Shield_prev
integer array Shield_next
integer array Shield_referingList
timer array Shield_t
real array Shield_amount
integer array Shield_target
integer array Shield_shieldDestroyed
string HeroBar_hpColor
string HeroBar_hpColorDead
string HeroBar_shieldColor
string HeroBar_mpColor
string HeroBar_mpColorDead
string HeroBar_endColor
string HeroBar_marker
string HeroBar_bar
integer HeroBar_realBarCount
integer HeroBar_fakeBarCount
integer HeroBar_seperateAt
timer Bar_updatePos
timer Bar_updateVision
integer array Bar_owner
boolean array Bar_isVisible
boolean array Bar_check
string array Bar_hpFull
integer array Bar_markerDistance
texttag array Bar_tt
integer LinkedListModule_first_2
integer LinkedListModule_last_2
integer LinkedListModule_size_2
integer array LinkedListModule_prev_2
integer array LinkedListModule_next_2
string array BarTest_hpFull
real array BarTest_maxHp
integer array BarTest_markerDistance
integer array Queue_dummy
integer array Queue_front
integer array Queue_back
integer array Queue_size
integer array SEntry_elem
integer array SEntry_next
integer array SIterator_dummy
integer array SIterator_current
string Lightning_CHAIN_LIGHTNING_PRIMARY
string Lightning_CHAIN_LIGHTNING_SECONDARY
string Lightning_DRAIN
string Lightning_DRAIN_LIFE
string Lightning_DRAIN_MANA
string Lightning_FINGER_OF_DEATH
string Lightning_FORKED_LIGHTNING
string Lightning_HEALING_WAVE_PRIMARY
string Lightning_HEALING_WAVE_SECONDARY
string Lightning_LIGHTNING_ATTACK
string Lightning_MAGIC_LEASH
string Lightning_MANA_BURN
string Lightning_MANA_FLARE
string Lightning_SPIRIT_LINK
image array AreaMarker_img
timer array AreaMarker_t
hashtable HandleMap_ht
integer CaptureAnimation_captureTimer
rect MapBounds_mapRect
real MapBounds_mapMinX
real MapBounds_mapMinY
real MapBounds_mapMaxX
real MapBounds_mapMaxY
real MapBounds_mapCenter_x
real MapBounds_mapCenter_y
timer GameTimer_gameTimer
integer DummyRecycler_ANG_N
integer DummyRecycler_ANG_STORAGE_MAX
real DummyRecycler_DEATH_TIME
integer DummyRecycler_ANG_VAL
integer DummyRecycler_ANG_MID
unit array DummyRecycler_stack
integer array DummyRecycler_stackN
real array DummyRecycler_timeStamp
integer array DummyRecycler_queueNext
integer array DummyRecycler_queueLast
integer DummyRecycler_recycle
group DummyRecycler_protect
unit array DelayData_dum
real array DelayData_dT
integer LinkedListModule_first_3
integer LinkedListModule_last_3
integer LinkedListModule_size_3
integer array LinkedListModule_prev_3
integer array LinkedListModule_next_3
unit array Fx_dummy
effect array Fx_fx
real array Fx_zAngle
string array Fx_sfxPath
integer array Fx_col
integer array Fx_col_2
integer array Fx_col_3
integer array Fx_col_4
integer TimedEffect_effectData
real ControlPoint_range
real ControlPoint_captureRange
integer ControlPoint_model
integer ControlPoint_morphAbi
real ControlPoint_height
real ControlPoint_baseDmg
real ControlPoint_dmgPerLvl
real ControlPoint_percentualDmg
real ControlPoint_heroDmgFactor
real ControlPoint_unitDmgFactor
real ControlPoint_creepDmg
real ControlPoint_captureSpeedPoint
real ControlPoint_captureSpeedHero
real ControlPoint_baseSHeal
real ControlPoint_heroSHealFactor
real ControlPoint_unitSHealFactor
integer array this_3
integer array h
real array ControlPoint_pos
real array ControlPoint_pos_2
real array ControlPoint_pos_3
unit array ControlPoint_clickDummy
unit array ControlPoint_visualDummy
group array ControlPoint_inRange
integer array ControlPoint_enemyHerosInGroup
integer array ControlPoint_allyHerosInGroup
integer array ControlPoint_enemysInGroup
integer array ControlPoint_allysInGroup
player array ControlPoint_owner
timer array ControlPoint_t1
timer array ControlPoint_t2
real array ControlPoint_hp
lightning array CaptureData_l1
lightning array CaptureData_l2
real array CaptureData_blitzPos
boolean array CaptureData_captures
integer array CaptureData_onDeath
integer array CaptureData_target
integer array CaptureData_fx
integer array CaptureData_armor
integer array CaptureData_attack
integer array CaptureData_life
integer array CaptureData_mana
integer array CaptureData_spellpower
integer array CaptureData_resistance
integer OrderHandling_smartId
integer OrderHandling_stopId
integer OrderHandling_attackId
integer OrderHandling_scoreboardId
integer OrderHandling_exitDetectId
integer OrderHandling_skillMenuId
integer OrderHandling_stopSpell
integer OrderHandling_attackSpell
integer OrderHandling_scoreboardSpell
integer OrderHandling_exitDetectSpell
integer OrderHandling_qSpellNoTarget
integer OrderHandling_qSpellUnitTarget
integer OrderHandling_qSpellPointTarget
integer OrderHandling_qSpellUnitPointTarget
integer OrderHandling_wSpellNoTarget
integer OrderHandling_wSpellUnitTarget
integer OrderHandling_wSpellPointTarget
integer OrderHandling_wSpellUnitPointTarget
integer OrderHandling_eSpellNoTarget
integer OrderHandling_eSpellUnitTarget
integer OrderHandling_eSpellPointTarget
integer OrderHandling_eSpellUnitPointTarget
integer OrderHandling_rSpellNoTarget
integer OrderHandling_rSpellUnitTarget
integer OrderHandling_rSpellPointTarget
integer OrderHandling_rSpellUnitPointTarget
integer OrderHandling_dSpellNoTarget
integer OrderHandling_dSpellUnitTarget
integer OrderHandling_dSpellPointTarget
integer OrderHandling_dSpellUnitPointTarget
integer OrderHandling_fSpellNoTarget
integer OrderHandling_fpellUnitTarget
integer OrderHandling_fSpellPointTarget
integer OrderHandling_fSpellUnitPointTarget
integer array Order_orderId
integer ShowInstances_classId_2
integer MoveOrder_moveOrderId
real array MoveOrder_pos
real array MoveOrder_pos_2
real array MoveOrder_lastPos
real array MoveOrder_lastPos_2
integer AttackOrder_atkOrderId
unit array AttackOrder_target
integer array CaptureOrder_cp
hashtable PrimitiveIndexes_ht
integer array ObjId_id1
integer array ObjId_id2
integer array ObjId_id3
integer array ObjId_id4
unit PreloadHandler_dum
integer Spell_qSpellId
integer Spell_wSpellId
integer Spell_eSpellId
integer Spell_rSpellId
integer Spell_dSpellId
integer Spell_fSpellId
integer array SpellSetup_sp
integer array SpellSetup_spell
integer array SpellSetup_spellbook
integer array SpellSetup_maxLvl
integer array SpellSetup_castDummy
integer array SpellSetup_pointCost
integer Spell_cleanSpellbook
unit array Spellcast_target
real array Spellcast_pos
real array Spellcast_pos_2
integer array Spellcast_spell
integer array Spell_spell
integer array Spell_spellbook
integer array Spell_castDummy
integer array Spell_maxLvl
integer array Spell_lvl
integer array Spell_pointCost
integer array Spell_st
integer array Spell_owner
integer array Cooldown_cdIcon
integer Cooldown_count
integer Cooldown_lastAbi
integer array EventData_someData1
real array EventData_someData2
boolean array EventData_someData3
integer HeroClass_heroCount
integer array this_4
real array amount
integer array this_5
real array amount_2
integer array this_6
real array amount_3
integer array this_7
real array amount_4
integer array this_8
real array amount_5
integer array this_9
real array amount_6
integer array this_10
real array amount_7
integer array this_11
real array amount_8
integer array this_12
real array amount_9
integer array this_13
real array amount_10
integer array this_14
real array amount_11
integer array this_15
real array amount_12
integer array this_16
real array amount_13
integer array this_17
real array amount_14
integer array this_18
real array amount_15
integer array this_19
real array amount_16
integer array this_20
real array amount_17
integer array this_21
real array amount_18
integer array this_22
real array amount_19
integer array this_23
real array amount_20
integer array this_24
real array amount_21
integer array this_25
real array amount_22
integer array this_26
real array amount_23
integer array this_27
real array amount_24
integer array this_28
real array amount_25
integer array this_29
real array amount_26
integer array this_30
real array amount_27
integer array this_31
real array amount_28
integer array this_32
real array amount_29
integer array this_33
real array amount_30
integer array this_34
real array amount_31
integer array this_35
real array amount_32
integer array this_36
real array amount_33
integer array this_37
real array amount_34
integer array this_38
real array amount_35
integer array this_39
real array amount_36
integer array this_40
real array amount_37
integer array this_41
real array amount_38
real Unit_bounceFactor
real Unit_knockbackFactor
real Unit_basicAttackspeed
unit array Unit_u
real array Unit_attack
real array Unit_bonusAttack
real array Unit_bonusAttackPer
real array Unit_armor
real array Unit_bonusArmor
real array Unit_bonusArmorPer
real array Unit_life
real array Unit_bonusLife
real array Unit_bonusLifePer
real array Unit_mana
real array Unit_bonusMana
real array Unit_bonusManaPer
real array Unit_lifeReg
real array Unit_bonusLifeReg
real array Unit_bonusLifeRegPer
real array Unit_manaReg
real array Unit_bonusManaReg
real array Unit_bonusManaRegPer
real array Unit_bonusAttackspeed
real array Unit_spellpower
real array Unit_spellpowerPer
real array Unit_movespeed
real array Unit_bonusMovespeed
real array Unit_bonusMovespeedPer
real array Unit_magicReduction
real array Unit_normalReduction
real array Unit_resistance
real array Unit_bonusResistance
real array Unit_bonusResistancePer
real array Unit_hitchance
real array Unit_evade
real array Unit_critchance
real array Unit_critdamage
real array Unit_bonusDamage
real array Unit_magicDeflection
real array Unit_normalDeflection
real array Unit_lifesteal
real array Unit_bonusHeal
integer array Unit_vunerableCount
boolean array Unit_vunerable
integer array Unit_shieldList
integer array Unit_lastDamager
integer array Unit_lastHeroDamager
real array Unit_mass
real array Unit_bonusMass
real array Unit_bonusMassPer
real array Unit_knockX
real array Unit_knockY
real array Unit_radius
real array Unit_height
integer array Unit_lastKnocker
integer array Unit_lastCollision
real array Unit_wallLocX
real array Unit_wallLocY
boolean array Unit_hasKnockback
boolean array Unit_isHero
boolean array Unit_isDead
integer array Unit_level
integer array Unit_bounty
integer array Unit_ownerId
player array Unit_owner
integer array Unit_stun
integer array Unit_damageTT
integer array Unit_healTT
integer array Unit_dotTT
integer array Unit_percentDamage
integer array Unit_allDots
integer array Unit_allBuffs
integer array Unit_causeNormalDamagePre
integer array Unit_causeNormalDamageOn
integer array Unit_takeNormalDamagePre
integer array Unit_takeNormalDamageOn
integer array Unit_causeMagicDamagePre
integer array Unit_causeMagicDamageOn
integer array Unit_takeMagicDamagePre
integer array Unit_takeMagicDamageOn
integer array Unit_takeHitPre
integer array Unit_takeHitOn
integer array Unit_causeHitPre
integer array Unit_causeHitOn
integer array Unit_takeCritHitOn
integer array Unit_causeCritHitOn
integer array Unit_onDodge
integer array Unit_onMiss
integer array Unit_onDeath
integer array Unit_causeDeath
integer array Unit_takeSpell
integer array Unit_causeSpell
integer array Unit_takeHeal
integer array Unit_causeHeal
integer array Unit_takeManaHeal
integer array Unit_causeManaHeal
integer array Unit_ct
integer array Unit_onCapture
trigger Unit_damageDetect
integer ShowInstances_classId_3
integer array this_42
trigger Hero_castDetect
integer Hero_abiIdToSpell
timer Hero_checkOrders
real array Hero_agi
real array Hero_bonusAgi
real array Hero_bonusAgiPer
real array Hero_str
real array Hero_bonusStr
real array Hero_bonusStrPer
real array Hero_inte
real array Hero_bonusInt
real array Hero_bonusIntPer
integer array Hero_armorBuffer
integer array Hero_attackBuffer
integer array Hero_morphAbi
boolean array Hero_onAdd
boolean array Hero_wantCapture
integer array Hero_channelCancel
integer array Hero_animationIndex
boolean array Hero_hasPeriodicAnimation
real array Hero_animationIntervall
real array Hero_animationSpeed
real array Hero_captureOffsetZ
real array Hero_captureOffsetDistance
string array Hero_captureEffect
string array Hero_captureEffectAttachmentPoint
effect array Hero_currentEffect
real array Hero_captureOffsetAngle
integer array Hero_hb
integer array Hero_enableAbility
boolean array Hero_acceptOrders
boolean array Hero_stillNoOrder
integer array Hero_mainOrder
integer array Hero_lastOrdered
integer array Hero_castQueue
integer array Hero_spellQ
integer array Hero_spellW
integer array Hero_spellE
integer array Hero_spellR
integer array Hero_spellD
integer array Hero_spellF
trigger GetOrders_orderDetect
integer LinkedListModule_first_4
integer LinkedListModule_last_4
integer LinkedListModule_size_4
integer array LinkedListModule_prev_4
integer array LinkedListModule_next_4
integer array Stun_u
timer array Stun_t
integer UnitClass_knocklist
integer UnitClass_last
item UnitClass_tome
unit UnitClass_tempCheck
integer array PreDamageData_source
integer array PreDamageData_target
integer array PreDamageData_tempBons
integer array PreDamageEvent_target
integer array OnDamageData_source
integer array OnDamageData_target
real array OnDamageData_damage
boolean array OnDamageData_stop
integer array OnDamageEvent_target
integer array SpellData_source
integer array SpellData_target
boolean array SpellData_spellSuccess
integer array SpellEvent_target
integer array Units_source
integer array Units_target
integer array CaptureEventData_u
integer array CaptureEventData_cp
hashtable array HTable_ht
integer PlayerClass_lastp
real PlayerClass_camDistance
real PlayerClass_camAngle
real PlayerClass_camWidth
real PlayerClass_camHeightLow
real PlayerClass_camHeightHigh
integer PlayerClass_playerData
player array Player_p
integer array Player_h
string array Player_team
integer array Player_kills
integer array Player_assists
integer array Player_death
boolean array Player_selectionOn
timer array Player_camSet
real array Player_sightfield
real array Player_perspektiv
integer Trackable_trackData
real Trackable_doubleHitSpeed
trigger Trackable_doubleHitDetect
trackable Trackable_triggeringTrackable
real array Trackable_pos
real array Trackable_pos_2
player array Trackable_owner
string array Trackable_filePath
trigger array Trackable_doubleHit
boolean array Trackable_wasHit
timer array Trackable_doubleHitTimer
real Icon_animationSpeedHover
destructable array Icon_d
integer array Icon_canSee
integer array Icon_needToSee
integer array Icon_objId
real array Icon_scale
real array Icon_realPos
real array Icon_realPos_2
real array Icon_localPos
real array Icon_localPos_2
integer Menu_clickingPlayer
integer Menu_clickedButton
integer Menu_buttons
integer Menu_index
integer array Button_e1
integer array Button_e1_2
integer array Button_e2
integer array Button_e2_2
image array Button_img
integer array Button_referingMenu
trigger array Button_onHitAction
trigger array Button_onDoubleHitAction
trigger array Button_onTrackAction
trigger array Button_onUnTrackAction
integer array Button_ob
integer TrackableEventHandler_trackableTrackAction
integer TrackableEventHandler_trackableHitAction
integer TrackableEventHandler_trackableDoubleHitAction
integer array TrackableEventHandler_currentMenuOfPlayer
integer array TrackableEventHandler_currentButtonOfPlayer
integer TextTagEx_standardColor_red
integer TextTagEx_standardColor_green
integer TextTagEx_standardColor_blue
integer TextTagEx_standardColor_alpha
real TextTagEx_resizeRateConstant
integer TextTagEx_fadeTicks
integer TextTagEx_resizeTicks
integer TextTagEx_timerOwner
integer TextTagEx_tick
texttag array TextTagEx_tt
string array TextTagEx_content
real array TextTagEx_pos
real array TextTagEx_pos_2
real array TextTagEx_pos_3
real Image_resizeRateConstant
integer Image_fadeTicks
integer Image_resizeTicks
integer Image_timerOwner
integer Image_tick
image array Image_img
string array Image_filePath
real array Image_pos
real array Image_pos_2
real array Image_realPos
real array Image_realPos_2
real array Image_size
real array Image_size_2
real array Image_realSize
real array Image_realSize_2
real array Image_resizeRate
real array Image_resizeRate_2
integer array Image_layer
integer array Image_col
integer array Image_col_2
integer array Image_col_3
integer array Image_col_4
real TextHelper_charLengthFactor
string array TextBox_boxPath
real array TextBox_maxSpace
integer array TextBox_content
integer array Text_textBlocks
real array Text_textLength
integer array TextBlock_words
real array TextBlock_wordLength
integer array TextBlock_col
integer array TextBlock_col_2
integer array TextBlock_col_3
integer array TextBlock_textSize
string array Word_w
real array Word_length
boolean array Word_hasColor
integer array Word_col
integer array Word_col_2
integer array Word_col_3
integer Word_allWords
integer ShowInstances_classId_4
integer SamplePointSpellSetup_setup
real SamplePointSpellSetup_sampleVar
integer array SamplePointSpell_setupData
timer array SamplePointSpell_t
integer TestSpell1Setup_setup
integer TestSpell1_animationType
integer array TestSpell1_setup
integer array TestSpell1_caster
timer array TestSpell1_t
real RunningMazeChecker_tileWidth
rect array MazeChecker_checkArea
real array MazeChecker_start
real array MazeChecker_start_2
real array MazeChecker_goal
real array MazeChecker_goal_2
unit array RockThrow_dummy
unit array RockThrow_u
real array RockThrow_dist
real array RockThrow_range
real array RockThrow_speed
real array RockThrow_distd
real array RockThrow_x
real array RockThrow_y
real array RockThrow_z
real array RockThrow_grav
real array RockThrow_currentZ
real array RockThrow_ang
real array RockThrow_damage
integer array RockThrow_i
integer array RockThrow_c
integer array RockThrow_level
timer array RockThrow_t
group array RockThrow_g
effect array RockThrow_e
integer RTable_tableSize
hashtable array RTable_ht
integer array RTable_indexPos
timer array Pull2_t
unit array Pull2_u
unit array Pull2_ut
lightning array Pull2_l
integer array Pull2_i
integer array Pull2_imax
integer array Pull2_uut
timer array Missle_t
integer array Missle_fx
real array Missle_radius
real array Missle_vel
real array Missle_vel_2
integer array Missle_dl
integer array Missle_atHit
integer array Missle_atEnd
integer array Missle_source
boolexpr array Missle_filter
integer array Item_itemID
string array Item_name
string array Item_toolTipN
string array Item_toolTipE
integer array Item_cost
integer array Item_sellcost
real array Item_life
real array Item_mana
real array Item_armor
integer array Item_attack
integer array Item_movespeed
real array Item_lifereg
real array Item_manareg
real array Item_lifeper
real array Item_manaper
real array Item_armorper
real array Item_attackper
real array Item_movespeedper
real array Item_attackspeed
real array Item_liferegper
real array Item_manaregper
integer array Item_intel
integer array Item_str
integer array Item_agi
real array Item_intelper
real array Item_strper
real array Item_agiper
real array Item_crit
real array Item_evade
real array Item_hitdmg
real array Item_critdmg
real array Item_block
real array Item_blockdmg
group array Item_group1
group array Item_group2
group array Item_group3
group array Item_group4
group array Item_group5
ability array Item_spell1
ability array Item_spell2
ability array Item_spell3
ability array Item_spell4
ability array Item_spell5
integer array Item_need1
integer array Item_need2
integer array Item_need3
integer array Item_need4
integer array Item_need5
integer array Item_upg1
integer array Item_upg2
integer array Item_upg3
integer array Item_upg4
integer array Item_upg5
integer array Item_upg6
integer array Item_upg7
integer array Item_upg8
integer array Item_upg9
integer array Item_upg10
string HandleCounter_TITLE
leaderboard HandleCounter_board
timer HandleCounter_boardTimer
player HandleCounter_HANDLE
string HandleCounter_HANDLE_TEXT
player HandleCounter_MAX_HANDLE
string HandleCounter_MAX_HANDLE_TEXT
string HandleCounter_TIME_TEXT
player HandleCounter_TIME
real HandleCounter_updatePeriod
integer HandleCounter_stackEndTreshold
timer HandleCounter_clock
integer HandleCounter_seconds
integer HandleCounter_maxHandleCount
rect array Aura_r
real array Aura_radius
integer array Aura_buffId
boolexpr array Aura_filter
integer array Aura_u
timer array Aura_t
group array Aura_g
integer array Aura_enter
integer array Aura_leave
integer CustomBar_DEFAULT_BACKGROUND
integer CustomBar_DEFAULT_FOREGROUND
integer CustomBar_MAX_GRADIENTS
force CustomBar_tempForce
integer array CustomBar_bars
integer CustomBar_count
timer CustomBar_animationTimer
texttag array CustomBar_t
integer array CustomBar_bg_color
integer array CustomBar_bg_color_2
integer array CustomBar_bg_color_3
integer array CustomBar_bg_color_4
integer array CustomBar_fg_color
integer array CustomBar_fg_color_2
integer array CustomBar_fg_color_3
integer array CustomBar_fg_color_4
real array CustomBar_position
real array CustomBar_position_2
real array CustomBar_position_3
string array CustomBar_txt
real array CustomBar_textsize
integer array CustomBar_lockindex
boolean array CustomBar_locked
unit array CustomBar_u
real array CustomBar_xOffset
real array CustomBar_yOffset
force array CustomBar_disp
real array CustomBar_value
integer array CustomBar_NUM_CHARS
string array CustomBar_char
string array CustomBar_ptext
integer array Stack_dummy
integer array Stack_top
integer array Stack_size
integer array SEntry_elem_2
integer array SEntry_prev
integer array SIterator_dummy_2
integer array SIterator_current_2
trigger GameStart_testt
integer GameStart_lastBon
real GameStart_hp
integer GameStart_testc
integer GameStart_testi
real GameStart_ttSize
real GameStart_testr
string GameStart_tests
integer GameStart_testSpell
string GameStart_testChar
texttag GameStart_testTag
unit GameStart_testu
group GameStart_testg
integer GameStart_progress
integer GameStart_recursionCounter
destructable GameStart_testd
integer GameStart_callLimit
integer GameStart_testImg
integer GameStart_tList
integer GameStart_lList
real Preload_maxProgress
real Preload_progress
integer Preload_preloadStatus
integer Preload_preloadEnd
boolean Preload_showProgress
integer Preload_trackCounter
trigger Preload_trackTrig
integer Preload_trackPos_i1
integer Preload_trackPos_i2
unit Preload_preloadDummy
integer Preload_abiCounter
integer Preload_itemCounter
integer array ForceIterator_pos
integer array ForceIterator_stop
integer ForceIterator_tempThis
integer ForceIterator_tempIndex
player array ForceIterator_players
player array ForceIterator_tempPlayers
integer OnCast_casts
integer array OnCast_abiCode
integer OnPointCast_casts
integer array OnPointCast_abiCode
integer OnUnitCast_casts
integer array OnUnitCast_abiCode
integer array A_otherA
string array Char_c
integer array LinkedList_nextFree
integer LinkedList_firstFree
integer LinkedList_lastFree
integer LinkedList_maxIndex
integer array LinkedList_typeId
integer array LLEntry_nextFree
integer LLEntry_firstFree
integer LLEntry_lastFree
integer LLEntry_maxIndex
integer array LLEntry_typeId
integer array LLIterator_nextFree
integer LLIterator_firstFree
integer LLIterator_lastFree
integer LLIterator_maxIndex
integer array LLIterator_typeId
integer array Table_nextFree
integer Table_firstFree
integer Table_lastFree
integer Table_maxIndex
integer array Table_typeId
integer array StringIterator_nextFree
integer StringIterator_firstFree
integer StringIterator_lastFree
integer StringIterator_maxIndex
integer array StringIterator_typeId
integer array StringLines_nextFree
integer StringLines_firstFree
integer StringLines_lastFree
integer StringLines_maxIndex
integer array StringLines_typeId
integer array BigNum_l_nextFree
integer BigNum_l_firstFree
integer BigNum_l_lastFree
integer BigNum_l_maxIndex
integer array BigNum_l_typeId
integer array BigNum_nextFree
integer BigNum_firstFree
integer BigNum_lastFree
integer BigNum_maxIndex
integer array BigNum_typeId
integer array UnitIndex_nextFree
integer UnitIndex_firstFree
integer UnitIndex_lastFree
integer UnitIndex_maxIndex
integer array UnitIndex_typeId
integer array Event_nextFree
integer Event_firstFree
integer Event_lastFree
integer Event_maxIndex
integer array Event_typeId
integer array Action_nextFree
integer Action_firstFree
integer Action_lastFree
integer Action_maxIndex
integer array Action_typeId
integer array TList_nextFree
integer TList_firstFree
integer TList_lastFree
integer TList_maxIndex
integer array TList_typeId
integer array TIterator_nextFree
integer TIterator_firstFree
integer TIterator_lastFree
integer TIterator_maxIndex
integer array TIterator_typeId
integer array Dot_nextFree
integer Dot_firstFree
integer Dot_lastFree
integer Dot_maxIndex
integer array Dot_typeId
integer array Buff_nextFree
integer Buff_firstFree
integer Buff_lastFree
integer Buff_maxIndex
integer array Buff_typeId
integer array AbilityDefinition_nextFree
integer AbilityDefinition_firstFree
integer AbilityDefinition_lastFree
integer AbilityDefinition_maxIndex
integer array AbilityDefinition_typeId
integer array BuffDefinition_nextFree
integer BuffDefinition_firstFree
integer BuffDefinition_lastFree
integer BuffDefinition_maxIndex
integer array BuffDefinition_typeId
integer array W3UDefinition_nextFree
integer W3UDefinition_firstFree
integer W3UDefinition_lastFree
integer W3UDefinition_maxIndex
integer array W3UDefinition_typeId
integer array Table3D_nextFree
integer Table3D_firstFree
integer Table3D_lastFree
integer Table3D_maxIndex
integer array Table3D_typeId
integer array Array_nextFree
integer Array_firstFree
integer Array_lastFree
integer Array_maxIndex
integer array Array_typeId
integer array DebugFile_nextFree
integer DebugFile_firstFree
integer DebugFile_lastFree
integer DebugFile_maxIndex
integer array DebugFile_typeId
integer array HashMap_nextFree
integer HashMap_firstFree
integer HashMap_lastFree
integer HashMap_maxIndex
integer array HashMap_typeId
integer array CallbackSingle_nextFree
integer CallbackSingle_firstFree
integer CallbackSingle_lastFree
integer CallbackSingle_maxIndex
integer array CallbackSingle_typeId
integer array CallbackPeriodic_nextFree
integer CallbackPeriodic_firstFree
integer CallbackPeriodic_lastFree
integer CallbackPeriodic_maxIndex
integer array CallbackPeriodic_typeId
integer array CallbackCounted_nextFree
integer CallbackCounted_firstFree
integer CallbackCounted_lastFree
integer CallbackCounted_maxIndex
integer array CallbackCounted_typeId
integer array Widget_nextFree
integer Widget_firstFree
integer Widget_lastFree
integer Widget_maxIndex
integer array Widget_typeId
integer array TextTag_nextFree
integer TextTag_firstFree
integer TextTag_lastFree
integer TextTag_maxIndex
integer array TextTag_typeId
integer array ShieldList_nextFree
integer ShieldList_firstFree
integer ShieldList_lastFree
integer ShieldList_maxIndex
integer array ShieldList_typeId
integer array Shield_nextFree
integer Shield_firstFree
integer Shield_lastFree
integer Shield_maxIndex
integer array Shield_typeId
integer array Bar_nextFree
integer Bar_firstFree
integer Bar_lastFree
integer Bar_maxIndex
integer array Bar_typeId
integer array BarTest_nextFree
integer BarTest_firstFree
integer BarTest_lastFree
integer BarTest_maxIndex
integer array BarTest_typeId
integer array Queue_nextFree
integer Queue_firstFree
integer Queue_lastFree
integer Queue_maxIndex
integer array Queue_typeId
integer array SEntry_nextFree
integer SEntry_firstFree
integer SEntry_lastFree
integer SEntry_maxIndex
integer array SEntry_typeId
integer array SIterator_nextFree
integer SIterator_firstFree
integer SIterator_lastFree
integer SIterator_maxIndex
integer array SIterator_typeId
integer array AreaMarker_nextFree
integer AreaMarker_firstFree
integer AreaMarker_lastFree
integer AreaMarker_maxIndex
integer array AreaMarker_typeId
integer array HandleMap_nextFree
integer HandleMap_firstFree
integer HandleMap_lastFree
integer HandleMap_maxIndex
integer array HandleMap_typeId
integer array DelayData_nextFree
integer DelayData_firstFree
integer DelayData_lastFree
integer DelayData_maxIndex
integer array DelayData_typeId
integer array Fx_nextFree
integer Fx_firstFree
integer Fx_lastFree
integer Fx_maxIndex
integer array Fx_typeId
integer array ControlPoint_nextFree
integer ControlPoint_firstFree
integer ControlPoint_lastFree
integer ControlPoint_maxIndex
integer array ControlPoint_typeId
integer array CaptureData_nextFree
integer CaptureData_firstFree
integer CaptureData_lastFree
integer CaptureData_maxIndex
integer array CaptureData_typeId
integer array Order_nextFree
integer Order_firstFree
integer Order_lastFree
integer Order_maxIndex
integer array Order_typeId
integer array ObjId_nextFree
integer ObjId_firstFree
integer ObjId_lastFree
integer ObjId_maxIndex
integer array ObjId_typeId
integer array SpellSetup_nextFree
integer SpellSetup_firstFree
integer SpellSetup_lastFree
integer SpellSetup_maxIndex
integer array SpellSetup_typeId
integer array Spellcast_nextFree
integer Spellcast_firstFree
integer Spellcast_lastFree
integer Spellcast_maxIndex
integer array Spellcast_typeId
integer array Spell_nextFree
integer Spell_firstFree
integer Spell_lastFree
integer Spell_maxIndex
integer array Spell_typeId
integer array EventData_nextFree
integer EventData_firstFree
integer EventData_lastFree
integer EventData_maxIndex
integer array EventData_typeId
integer array EventAction_nextFree
integer EventAction_firstFree
integer EventAction_lastFree
integer EventAction_maxIndex
integer array EventAction_typeId
integer array Unit_nextFree
integer Unit_firstFree
integer Unit_lastFree
integer Unit_maxIndex
integer array Unit_typeId
integer array Bonus_nextFree
integer Bonus_firstFree
integer Bonus_lastFree
integer Bonus_maxIndex
integer array Bonus_typeId
integer array Stun_nextFree
integer Stun_firstFree
integer Stun_lastFree
integer Stun_maxIndex
integer array Stun_typeId
integer array PreDamageData_nextFree
integer PreDamageData_firstFree
integer PreDamageData_lastFree
integer PreDamageData_maxIndex
integer array PreDamageData_typeId
integer array OnDamageData_nextFree
integer OnDamageData_firstFree
integer OnDamageData_lastFree
integer OnDamageData_maxIndex
integer array OnDamageData_typeId
integer array SpellData_nextFree
integer SpellData_firstFree
integer SpellData_lastFree
integer SpellData_maxIndex
integer array SpellData_typeId
integer array Units_nextFree
integer Units_firstFree
integer Units_lastFree
integer Units_maxIndex
integer array Units_typeId
integer array CaptureEventData_nextFree
integer CaptureEventData_firstFree
integer CaptureEventData_lastFree
integer CaptureEventData_maxIndex
integer array CaptureEventData_typeId
integer array HTable_nextFree
integer HTable_firstFree
integer HTable_lastFree
integer HTable_maxIndex
integer array HTable_typeId
integer array Player_nextFree
integer Player_firstFree
integer Player_lastFree
integer Player_maxIndex
integer array Player_typeId
integer array Trackable_nextFree
integer Trackable_firstFree
integer Trackable_lastFree
integer Trackable_maxIndex
integer array Trackable_typeId
integer array MenuIndexer_nextFree
integer MenuIndexer_firstFree
integer MenuIndexer_lastFree
integer MenuIndexer_maxIndex
integer array MenuIndexer_typeId
integer array Menu_nextFree
integer Menu_firstFree
integer Menu_lastFree
integer Menu_maxIndex
integer array Menu_typeId
integer array TextTagEx_nextFree
integer TextTagEx_firstFree
integer TextTagEx_lastFree
integer TextTagEx_maxIndex
integer array TextTagEx_typeId
integer array Text_nextFree
integer Text_firstFree
integer Text_lastFree
integer Text_maxIndex
integer array Text_typeId
integer array TextBlock_nextFree
integer TextBlock_firstFree
integer TextBlock_lastFree
integer TextBlock_maxIndex
integer array TextBlock_typeId
integer array Word_nextFree
integer Word_firstFree
integer Word_lastFree
integer Word_maxIndex
integer array Word_typeId
integer array SamplePointSpell_nextFree
integer SamplePointSpell_firstFree
integer SamplePointSpell_lastFree
integer SamplePointSpell_maxIndex
integer array SamplePointSpell_typeId
integer array TestSpell1_nextFree
integer TestSpell1_firstFree
integer TestSpell1_lastFree
integer TestSpell1_maxIndex
integer array TestSpell1_typeId
integer array MazeChecker_nextFree
integer MazeChecker_firstFree
integer MazeChecker_lastFree
integer MazeChecker_maxIndex
integer array MazeChecker_typeId
integer array RockThrow_nextFree
integer RockThrow_firstFree
integer RockThrow_lastFree
integer RockThrow_maxIndex
integer array RockThrow_typeId
integer array RTable_nextFree
integer RTable_firstFree
integer RTable_lastFree
integer RTable_maxIndex
integer array RTable_typeId
integer array Pull2_nextFree
integer Pull2_firstFree
integer Pull2_lastFree
integer Pull2_maxIndex
integer array Pull2_typeId
integer array Missle_nextFree
integer Missle_firstFree
integer Missle_lastFree
integer Missle_maxIndex
integer array Missle_typeId
integer array Item_nextFree
integer Item_firstFree
integer Item_lastFree
integer Item_maxIndex
integer array Item_typeId
integer array Aura_nextFree
integer Aura_firstFree
integer Aura_lastFree
integer Aura_maxIndex
integer array Aura_typeId
integer array CustomBar_nextFree
integer CustomBar_firstFree
integer CustomBar_lastFree
integer CustomBar_maxIndex
integer array CustomBar_typeId
integer array Stack_nextFree
integer Stack_firstFree
integer Stack_lastFree
integer Stack_maxIndex
integer array Stack_typeId
integer array SEntry_nextFree_2
integer SEntry_firstFree_2
integer SEntry_lastFree_2
integer SEntry_maxIndex_2
integer array SEntry_typeId_2
integer array SIterator_nextFree_2
integer SIterator_firstFree_2
integer SIterator_lastFree_2
integer SIterator_maxIndex_2
integer array SIterator_typeId_2
integer array Preload_nextFree
integer Preload_firstFree
integer Preload_lastFree
integer Preload_maxIndex
integer array Preload_typeId
integer array ForceIterator_nextFree
integer ForceIterator_firstFree
integer ForceIterator_lastFree
integer ForceIterator_maxIndex
integer array ForceIterator_typeId
integer array OnCast_nextFree
integer OnCast_firstFree
integer OnCast_lastFree
integer OnCast_maxIndex
integer array OnCast_typeId
integer array OnPointCast_nextFree
integer OnPointCast_firstFree
integer OnPointCast_lastFree
integer OnPointCast_maxIndex
integer array OnPointCast_typeId
integer array OnUnitCast_nextFree
integer OnUnitCast_firstFree
integer OnUnitCast_lastFree
integer OnUnitCast_maxIndex
integer array OnUnitCast_typeId
integer array A_nextFree
integer A_firstFree
integer A_lastFree
integer A_maxIndex
integer array A_typeId
integer array Char_nextFree
integer Char_firstFree
integer Char_lastFree
integer Char_maxIndex
integer array Char_typeId
real vec3_rotate_return_x
real vec3_rotate_return_y
real vec3_rotate_return_z
real angle_toVec_return_x
real angle_toVec_return_y
real vec3_op_plus_return_x
real vec3_op_plus_return_y
real vec3_op_plus_return_z
real vec2_op_plus_return_x
real vec2_op_plus_return_y
real vec2_polarOffset_return_x
real vec2_polarOffset_return_y
real vec2_setLength_return_x
real vec2_setLength_return_y
real vec2_op_mult_return_x
real vec2_op_mult_return_y
real vec2_toVec3_return_x
real vec2_toVec3_return_y
real vec2_toVec3_return_z
real vec3_project_return_x
real vec3_project_return_y
real vec3_project_return_z
real vec3_toVec2_return_x
real vec3_toVec2_return_y
real unit_getPos_return_x
real unit_getPos_return_y
integer fromPlayerColor_return_red
integer fromPlayerColor_return_green
integer fromPlayerColor_return_blue
real vec2_withZ_return_x
real vec2_withZ_return_y
real vec2_withZ_return_z
real dispatch_Hero_getBarPos_return_x
real dispatch_Hero_getBarPos_return_y
real dispatch_Hero_getBarPos_return_z
integer colorA_toLightningColor_return_red
integer colorA_toLightningColor_return_green
integer colorA_toLightningColor_return_blue
integer colorA_toLightningColor_return_alpha
integer color_toLightningColor_return_red
integer color_toLightningColor_return_green
integer color_toLightningColor_return_blue
real dispatch_Unit_getMiddle_return_x
real dispatch_Unit_getMiddle_return_y
real dispatch_Unit_getMiddle_return_z
real dispatch_Hero_getCaptureAttackPoint_return_x
real dispatch_Hero_getCaptureAttackPoint_return_y
real dispatch_Hero_getCaptureAttackPoint_return_z
real vec3_op_mult_return_x
real vec3_op_mult_return_y
real vec3_op_mult_return_z
real vec3_op_plus_return_x_2
real vec3_op_plus_return_y_2
real vec3_op_plus_return_z_2
real getPathingNormal_return_x
real getPathingNormal_return_y
real getBounceVec_return_x
real getBounceVec_return_y
real vec2_op_minus_return_x
real vec2_op_minus_return_y
real vec2_toTile_return_x
real vec2_toTile_return_y
real dispatch_Fx_getPos2_return_x
real dispatch_Fx_getPos2_return_y
integer makeColor_return_red
integer makeColor_return_green
integer makeColor_return_blue
integer makeColor_return_alpha
integer cBonData_return_raw
integer cBonData_return_size
real Fx_getPos2_return_x
real Fx_getPos2_return_y
real Unit_getMiddle_return_x
real Unit_getMiddle_return_y
real Unit_getMiddle_return_z
real Hero_getBarPos_return_x
real Hero_getBarPos_return_y
real Hero_getBarPos_return_z
real Hero_getCaptureAttackPoint_return_x
real Hero_getCaptureAttackPoint_return_y
real Hero_getCaptureAttackPoint_return_z
real Missle_getPos_return_x
real Missle_getPos_return_y
real angle_direction_return_x
real angle_direction_return_y
real vec3_setLength_return_x
real vec3_setLength_return_y
real vec3_setLength_return_z
real vec3_op_minus_return_x
real vec3_op_minus_return_y
real vec3_op_minus_return_z
real vec3_op_minus_return_x_2
real vec3_op_minus_return_y_2
real vec3_op_minus_return_z_2
real vec3_addReals_return_x
real vec3_addReals_return_y
real vec3_addReals_return_z
real vec3_scaleXY_return_x
real vec3_scaleXY_return_y
real vec3_scaleXY_return_z
real vec3_cross_return_x
real vec3_cross_return_y
real vec3_cross_return_z
real vec3_norm_return_x
real vec3_norm_return_y
real vec3_norm_return_z
real vec3_trim_return_x
real vec3_trim_return_y
real vec3_trim_return_z
real vec3_rotate_return_x_2
real vec3_rotate_return_y_2
real vec3_rotate_return_z_2
real vec3_offset2d_return_x
real vec3_offset2d_return_y
real vec3_offset2d_return_z
real vec3_polarProject_return_x
real vec3_polarProject_return_y
real vec3_polarProject_return_z
real vec2_addReals_return_x
real vec2_addReals_return_y
real vec2_norm_return_x
real vec2_norm_return_y
real vec2_trim_return_x
real vec2_trim_return_y
real vec2_isInRange_return_v_x
real vec2_isInRange_return_v_y
real vec2_isInRange_return_range
real unit_getPos3fake_return_x
real unit_getPos3fake_return_y
real unit_getPos3fake_return_z
real rect_getCenter_return_x
real rect_getCenter_return_y
real rect_getLeftTop_return_x
real rect_getLeftTop_return_y
real rect_getRightTop_return_x
real rect_getRightTop_return_y
real rect_getLeftBot_return_x
real rect_getLeftBot_return_y
real rect_getRightBot_return_x
real rect_getRightBot_return_y
real linear_return_x
real linear_return_y
real bezier_3_return_x
real bezier_3_return_y
real getTerrainNormal_return_x
real getTerrainNormal_return_y
real getTerrainNormal_return_z
integer color_withAlpha_return_red
integer color_withAlpha_return_green
integer color_withAlpha_return_blue
integer color_withAlpha_return_alpha
integer fromHexString_return_red
integer fromHexString_return_green
integer fromHexString_return_blue
integer fromHexString_return_alpha
integer fromPlayer_return_red
integer fromPlayer_return_green
integer fromPlayer_return_blue
integer colorA_mix_return_red
integer colorA_mix_return_green
integer colorA_mix_return_blue
integer colorA_mix_return_alpha
real randomPointOnMap_return_x
real randomPointOnMap_return_y
real tile_nextX_return_x
real tile_nextX_return_y
real tile_nextY_return_x
real tile_nextY_return_y
real tile_prevX_return_x
real tile_prevX_return_y
real tile_prevY_return_x
real tile_prevY_return_y
real dispatch_Missle_getPos_return_x
real dispatch_Missle_getPos_return_y
unit group_nexttempReturn
texttag createTTExtempReturn
texttag createTTExtempReturn_2
texttag createTTExtempReturn_3
texttag createTTExtempReturn_4
image createImagetempReturn
image createImagetempReturn_2
trackable createTrackableForPlayertempReturn
player ForceIterator_nexttempReturn
player dispatch_Table_loadPlayertempReturn
widget dispatch_Table_loadWidgettempReturn
unit dispatch_Table_loadUnittempReturn
destructable dispatch_Table_loadDestructabletempReturn
item dispatch_Table_loadItemtempReturn
ability dispatch_Table_loadAbilitytempReturn
force dispatch_Table_loadForcetempReturn
group dispatch_Table_loadGrouptempReturn
trigger dispatch_Table_loadTriggertempReturn
timer dispatch_Table_loadTimertempReturn
location dispatch_Table_loadLocationtempReturn
region dispatch_Table_loadRegiontempReturn
rect dispatch_Table_loadRecttempReturn
sound dispatch_Table_loadSoundtempReturn
effect dispatch_Table_loadEffecttempReturn
fogstate dispatch_Table_loadFogStatetempReturn
dialog dispatch_Table_loadDialogtempReturn
button dispatch_Table_loadButtontempReturn
quest dispatch_Table_loadQuesttempReturn
leaderboard dispatch_Table_loadLeaderboardtempReturn
multiboard dispatch_Table_loadMultiboardtempReturn
trackable dispatch_Table_loadTrackabletempReturn
lightning dispatch_Table_loadLightningtempReturn
image dispatch_Table_loadImagetempReturn
ubersplat dispatch_Table_loadUbersplattempReturn
trackable dispatch_Table3D_gettempReturn
player dispatch_Fx_getOwnertempReturn
unit dispatch_Fx_getDummytempReturn
player dispatch_ForceIterator_nexttempReturn
code ref_function_IssueHauntOrderAtLocBJFilter
code ref_function_EnumDestructablesInCircleBJFilter
code ref_function_GetUnitsInRectOfPlayerFilter
code ref_function_GetUnitsOfTypeIdAllFilter
code ref_function_GetUnitsOfPlayerAndTypeIdFilter
code ref_function_MeleeTrainedUnitIsHeroBJFilter
code ref_function_LivingPlayerUnitsOfTypeIdFilter
code ref_function_QueuedTriggerDoneBJ
code ref_function_SetDNCSoundsDawn
code ref_function_SetDNCSoundsDusk
code ref_function_SetDNCSoundsDay
code ref_function_SetDNCSoundsNight
code ref_function_StartStockUpdates
code ref_function_RemovePurchasedItem
code ref_function_MarkGameStarted
code ref_function_PerformStockUpdates
code ref_function_UpdateEachStockBuildingEnum
code ref_function_DelayedSuspendDecay
code ref_function_MeleeTriggerTournamentFinishSoon
code ref_function_MeleeTriggerTournamentFinishNow
code ref_function_MeleeTriggerActionConstructCancel
code ref_function_MeleeTriggerActionUnitDeath
code ref_function_MeleeTriggerActionUnitConstructionStart
code ref_function_MeleeTriggerActionPlayerDefeated
code ref_function_MeleeTriggerActionPlayerLeft
code ref_function_MeleeTriggerActionAllianceChange
code ref_function_MeleeTriggerActionPlayerLeft_2
code ref_function_MeleeTriggerActionAllianceChange_2
code ref_function_MeleeDoDrawEnum
code ref_function_MeleeDoDefeatEnum
code ref_function_MeleeDoVictoryEnum
code ref_function_MeleeDoDefeatEnum_2
code ref_function_MeleeDoVictoryEnum_2
code ref_function_MeleeCrippledPlayerTimeout
code ref_function_MeleeEnumFindNearestMine
code ref_function_MeleeClearExcessUnit
code ref_function_MeleeGrantItemsToTrainedHero
code ref_function_MeleeGrantItemsToHiredHero
code ref_function_SetPlayerColorBJEnum
code ref_function_TriggerActionUnitRescuedBJ
code ref_function_MakeUnitRescuableToForceBJEnum
code ref_function_FinishCinematicFadeBJ
code ref_function_ContinueCinematicFadeBJ
code ref_function_SetCineModeVolumeGroupsImmediateBJ
code ref_function_CancelCineSceneBJ
code ref_function_CustomDefeatRestartBJ
code ref_function_CustomDefeatReduceDifficultyBJ
code ref_function_CustomDefeatLoadBJ
code ref_function_CustomDefeatQuitBJ
code ref_function_CustomVictoryOkBJ
code ref_function_CustomVictoryQuitBJ
code ref_function_MakeUnitsPassiveForPlayerEnum
code ref_function_CountUnitsInGroupEnum
code ref_function_GetRandomSubGroupEnum
code ref_function_CountPlayersInForceEnum
code ref_function_GroupAddGroupEnum
code ref_function_ForcePickRandomPlayerEnum
code ref_function_GroupPickRandomUnitEnum
code ref_function_GroupRemoveGroupEnum
code ref_function_NearbyElevatorExistsEnum
code ref_function_FindElevatorWallBlockerEnum
code ref_function_NudgeUnitsInRectEnum
code ref_function_NudgeItemsInRectEnum
code ref_function_RandomDestructableInRectBJEnum
code ref_function_PauseAllUnitsBJEnum
code ref_function_WakePlayerUnitsEnum
code ref_function_IsUnitGroupInRectBJEnum
code ref_function_IsUnitGroupEmptyBJEnum
code ref_function_IsUnitGroupDeadBJEnum
code ref_function_SelectGroupBJEnum
code ref_function_SelectGroupBJEnum_2
code ref_function_DelayedSuspendDecayStopAnimEnum
code ref_function_DelayedSuspendDecayStopAnimEnum_2
code ref_function_DelayedSuspendDecayFleshEnum
code ref_function_DelayedSuspendDecayBoneEnum
code ref_function_DelayedSuspendDecayStopAnimEnum_3
code ref_function_GetLastCreatedGroupEnum
code ref_function_RandomItemInRectBJEnum
code ref_function_VolumeGroupResetImmediateBJ
code ref_function_SetSpeechVolumeGroupsImmediateBJ
code ref_function_RegisterDestDeathInRegionEnum
code ref_function_Trig_Unbezeichneter_Ausl__ser_003_Actions
code ref_function_GroupAddGroupEnum_2
code ref_function_resetCam
code ref_function_resetCam_2
code ref_function_resetCam_3
code ref_function_hideItem
code ref_function_Dot_timerDestroyDot
code ref_function_Buff_createEffect
code ref_function_Buff_timerDestroyBuff
code ref_function_CallbackSingle_staticCallback
code ref_function_CallbackPeriodic_staticCallback
code ref_function_CallbackCounted_staticCallback
code ref_function_Image_callShowFadedCallback
code ref_function_Image_callHideFadedCallback
code ref_function_TextTag_destroyTextTag
code ref_function_TextTag_destroyTextTag_2
code ref_function_TextTag_destroyTextTag_3
code ref_function_Shield_onExpire
code ref_function_Bar_callUpdateEx
code ref_function_AreaMarker_destr
code ref_function_playAnimation
code ref_function_destroyTimedEffect
code ref_function_destroyTimedFx
code ref_function_notDead
code ref_function_ControlPoint_callGroupCheck
code ref_function_ControlPoint_callInRangeActions
code ref_function_ControlPoint_hideDummy
code ref_function_Spell_timedDisableCastDummy
code ref_function_cdt
code ref_function_notUnit
code ref_function_Unit_callMakeVunerable
code ref_function_Stun_destroyStun
code ref_function_Hero_enableAbilityTimed
code ref_function_Stun_destroyStun_2
code ref_function_resetDoubleHit
code ref_function_Image_callSrinkCallback
code ref_function_Image_callGrowCallback
code ref_function_SamplePointSpell_callCallback
code ref_function_TestSpell1_bla
code ref_function_TestSpell1_callCallback
code ref_function_RockThrow_rockMoveCall
code ref_function_Pull2_blackHCall
code ref_function_Missle_callMove
code ref_function_Missle_callMove_2
code ref_function_actions
code ref_function_callback
code ref_function_Aura_callCheck
code ref_function_CustomBar_copyForce
code ref_function_CustomBar_lockCallback
code ref_function_CustomBar_fadeOutCallback
code ref_function_Preload_preload
code ref_function_Preload_createBackground
code ref_function_Preload_preload_2
code ref_function_Preload_preload_3
code ref_function_ForceIterator_callback
code ref_function_createMultiboard
code ref_function_Bar_updatePos
code ref_function_Bar_updateVision
code ref_function_checkDelayed
code ref_function_kill
code ref_function_Hero_handleCasts
code ref_function_Hero_checkOrders
code ref_function_GetOrders_callOnOrder
code ref_function_Unit_tookDamage
code ref_function_doubleHit
code ref_function_trackableHitHandler
code ref_function_trackableTrackHandler
code ref_function_trackableDoubleHitHandler
code ref_function_spellCondition
code ref_function_spellStart
code ref_function_updateTime
code ref_function_setCallLimit
code ref_function_Dot_loopList
code ref_function_callKnockback
code ref_function_camTest
code ref_function_forceKey
code ref_function_charMessung
code ref_function_onEsc
code ref_function_textTag
code ref_function_handleCasts
endglobals
function CreatePlayerBuildings takes nothing returns nothing
endfunction

function CreateUnitsForPlayer0 takes nothing returns nothing
	local player p = Player(0)
	local unit u = CreateUnit(p, 1211117617, 265.8, 62.3, 118.887)
	local integer unitID
	local trigger t
	local real life
	set p = null
	set u = null
	set t = null
endfunction

function CreatePlayerUnits takes nothing returns nothing
	call CreateUnitsForPlayer0()
endfunction

function CreateAllUnits takes nothing returns nothing
	call CreatePlayerBuildings()
	call CreatePlayerUnits()
endfunction

function CreateCameras takes nothing returns nothing
	set gg_cam_Camera_001 = CreateCameraSetup()
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_ROTATION, 90.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_ANGLE_OF_ATTACK, 270.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_TARGET_DISTANCE, 150.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_ROLL, 0.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_FIELD_OF_VIEW, 20.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_001, CAMERA_FIELD_FARZ, 200.0, 0.0)
	call CameraSetupSetDestPosition(gg_cam_Camera_001, 1022.5, 11.0, 0.0)
	set gg_cam_Camera_002 = CreateCameraSetup()
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_ROTATION, 90.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_ANGLE_OF_ATTACK, 270.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_TARGET_DISTANCE, 150.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_ROLL, 0.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_FIELD_OF_VIEW, 20.0, 0.0)
	call CameraSetupSetField(gg_cam_Camera_002, CAMERA_FIELD_FARZ, 200.0, 0.0)
	call CameraSetupSetDestPosition(gg_cam_Camera_002, 0.0, 0.0, 0.0)
endfunction

function InitTrig_Unbezeichneter_Ausl__ser_003 takes nothing returns nothing
	set gg_trg_Unbezeichneter_Ausl__ser_003 = CreateTrigger()
	call TriggerRegisterTimerEventSingle(gg_trg_Unbezeichneter_Ausl__ser_003, 5.)
	call TriggerAddAction(gg_trg_Unbezeichneter_Ausl__ser_003, ref_function_Trig_Unbezeichneter_Ausl__ser_003_Actions)
endfunction

function InitCustomTriggers takes nothing returns nothing
	call InitTrig_Unbezeichneter_Ausl__ser_003()
endfunction

function InitGlobals takes nothing returns nothing
	set udg_zw = 0.
	set udg_t = CreateTimer()
	set udg_UnverwundbarkeitsGruppe = CreateGroup()
	set udg_x1 = 0.
	set udg_x2 = 0.
	set udg_x3 = 0.
	set udg_x4 = 0.
	set udg_x5 = 0.
	set udg_y1 = 0.
	set udg_y4 = 0.
	set udg_y5 = 0.
	set udg_y3 = 0.
	set udg_y2 = 0.
endfunction

function RunInitializationTriggers takes nothing returns nothing
	call ConditionalTriggerExecute(gg_trg_Unbezeichneter_Ausl__ser_003)
endfunction

function printError takes string msg returns nothing
	call DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., PrintingHelper_DEBUG_MSG_DURATION, "|cffFF0000[ERROR]|r - " + msg)
endfunction

function image_remove takes image this_43 returns nothing
	if this_43 != null then
		call DestroyImage(this_43)
	else
		call printError("Nullpointer exeption by destroying an image")
	endif
endfunction

function hashtable_loadInt takes hashtable this_43, integer parentKey, integer childKey returns integer
	return LoadInteger(this_43, parentKey, childKey)
endfunction

function Table_loadInt takes integer this_43, integer parentKey returns integer
	return hashtable_loadInt(Table_ht, this_43, parentKey)
endfunction

function dispatch_Table_loadInt takes integer this_43, integer parentKey returns integer
	local integer loadInt_result
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.loadInt")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.loadInt on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set loadInt_result = Table_loadInt(this_43, parentKey)
	return loadInt_result
endfunction

function timer_getData takes timer this_43 returns integer
	return dispatch_Table_loadInt(TimerUtils_timerData, GetHandleId(this_43))
endfunction

function timer_pause takes timer this_43 returns nothing
	call PauseTimer(this_43)
endfunction

function hashtable_saveInt takes hashtable this_43, integer parentKey, integer childKey, integer value returns hashtable
	call SaveInteger(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table_saveInt takes integer this_43, integer parentKey, integer value returns nothing
	call hashtable_saveInt(Table_ht, this_43, parentKey, value)
endfunction

function dispatch_Table_saveInt takes integer this_43, integer parentKey, integer value returns nothing
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.saveInt")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.saveInt on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table_saveInt(this_43, parentKey, value)
endfunction

function timer_setData takes timer this_43, integer data returns timer
	call dispatch_Table_saveInt(TimerUtils_timerData, GetHandleId(this_43), data)
	return this_43
endfunction

function timer_release takes timer this_43 returns nothing
	if this_43 == null then
		call printError("Trying to release a null timer")
		return
	endif
	if timer_getData(this_43) == TimerUtils_HELD then
		call printError("ReleaseTimer: Double free!")
		return
	endif
	call timer_setData(this_43, TimerUtils_HELD)
	call timer_pause(this_43)
	set TimerUtils_freeTimers[TimerUtils_freeTimersCount] = this_43
	set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount + 1
endfunction

function AreaMarker_onDestroy takes integer this_43 returns nothing
	call image_remove(AreaMarker_img[this_43])
	if AreaMarker_t[this_43] != null then
		call timer_release(AreaMarker_t[this_43])
	endif
endfunction

function dealloc_AreaMarker takes integer obj returns nothing
	if AreaMarker_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type AreaMarker")
		call I2S(1 / 0)
	else
		set AreaMarker_nextFree[AreaMarker_lastFree] = obj
		set AreaMarker_lastFree = obj
		if AreaMarker_firstFree == 0 then
			set AreaMarker_firstFree = obj
			set AreaMarker_nextFree[obj] = 0
		endif
		set AreaMarker_typeId[obj] = 0
	endif
endfunction

function destroyAreaMarker takes integer this_43 returns nothing
	call AreaMarker_onDestroy(this_43)
	call dealloc_AreaMarker(this_43)
endfunction

function dispatch_AreaMarker_destroyAreaMarker takes integer this_43 returns nothing
	if AreaMarker_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling AreaMarker.destroyAreaMarker")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called AreaMarker.destroyAreaMarker on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyAreaMarker(this_43)
endfunction

function AreaMarker_destr takes nothing returns nothing
	call dispatch_AreaMarker_destroyAreaMarker(timer_getData(GetExpiredTimer()))
endfunction

function Action_onDestroy takes integer this_43 returns nothing
	if Event_first[Action_ev[this_43]] != this_43 then
		set Action_next[Action_prev[this_43]] = Action_next[this_43]
	else
		set Event_first[Action_ev[this_43]] = Action_next[this_43]
	endif
	if Event_last[Action_ev[this_43]] != this_43 then
		set Action_prev[Action_next[this_43]] = Action_prev[this_43]
	else
		set Event_last[Action_ev[this_43]] = Action_prev[this_43]
	endif
endfunction

function dealloc_Action takes integer obj returns nothing
	if Action_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Action")
		call I2S(1 / 0)
	else
		set Action_nextFree[Action_lastFree] = obj
		set Action_lastFree = obj
		if Action_firstFree == 0 then
			set Action_firstFree = obj
			set Action_nextFree[obj] = 0
		endif
		set Action_typeId[obj] = 0
	endif
endfunction

function destroyAction takes integer this_43 returns nothing
	call Action_onDestroy(this_43)
	call dealloc_Action(this_43)
endfunction

function dispatch_Action_destroyAction takes integer this_43 returns nothing
	if Action_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Action.destroyAction")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Action.destroyAction on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Action_typeId[this_43] <= 17 then
		if Action_typeId[this_43] <= 15 then
			if Action_typeId[this_43] <= 11 then
				call destroyAction(this_43)
			else
				call destroyAction(this_43)
			endif
		else
			call destroyAction(this_43)
		endif
	elseif Action_typeId[this_43] <= 629 then
		call destroyAction(this_43)
	else
		call destroyAction(this_43)
	endif
endfunction

function unit_addAbility takes unit this_43, integer abil returns unit
	call UnitAddAbility(this_43, abil)
	return this_43
endfunction

function unit_removeAbility takes unit this_43, integer abil returns unit
	call UnitRemoveAbility(this_43, abil)
	return this_43
endfunction

function Unit_updateState takes integer this_43, integer amount_39, integer data_raw, integer data_size returns nothing
	local integer i_2
	local integer temp
	local integer statHelper
	local integer i_3
	local integer temp_2
	local integer i_4
	local integer temp_3
	call unit_removeAbility(Unit_u[this_43], data_raw + 45)
	set i_2 = data_raw + 97
	set temp = data_raw + 97 + data_size
	loop
		exitwhen i_2 > temp
		call unit_removeAbility(Unit_u[this_43], i_2)
		set i_2 = i_2 + 1
	endloop
	set statHelper = amount_39
	if statHelper >= 0 then
		set i_3 = data_raw + 97
		set temp_2 = data_raw + 97 + data_size
		loop
			exitwhen i_3 > temp_2
			if ModuloInteger(statHelper, 2) == 1 then
				call unit_addAbility(Unit_u[this_43], i_3)
			endif
			set statHelper = statHelper / 2
			set i_3 = i_3 + 1
		endloop
	else
		set statHelper = statHelper + 1
		set i_4 = data_raw + 97
		set temp_3 = data_raw + 97 + data_size
		loop
			exitwhen i_4 > temp_3
			if ModuloInteger(statHelper, 2) == 0 then
				call unit_addAbility(Unit_u[this_43], i_4)
			endif
			set statHelper = statHelper / 2
			set i_4 = i_4 + 1
		endloop
		call unit_addAbility(Unit_u[this_43], data_raw + 45)
	endif
endfunction

function dispatch_Unit_updateState takes integer this_43, integer amount_39, integer data_raw, integer data_size returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateState")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateState on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateState(this_43, amount_39, data_raw, data_size)
	else
		call Unit_updateState(this_43, amount_39, data_raw, data_size)
	endif
endfunction

function roundReal takes real value returns integer
	if value > 0. then
		return R2I(value + 0.5)
	else
		return R2I(value - 0.5)
	endif
endfunction

function Unit_updateLife takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_lifeReg[this_43] + Unit_bonusLifeReg[this_43]) * (1. + Unit_bonusLifeRegPer[this_43] / 100.) - Unit_lifeReg[this_43]), Setup_lifeRegRaw_raw, Setup_lifeRegRaw_size)
endfunction

function getTimer takes nothing returns timer
	if TimerUtils_freeTimersCount > 0 then
		set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount - 1
		call timer_setData(TimerUtils_freeTimers[TimerUtils_freeTimersCount], 0)
		return TimerUtils_freeTimers[TimerUtils_freeTimersCount]
	else
		return timer_setData(CreateTimer(), 0)
	endif
endfunction

function timer_start takes timer this_43, real time, code timerCallBack returns timer
	call TimerStart(this_43, time, false, timerCallBack)
	return this_43
endfunction

function Bar_updateEx takes integer this_43 returns nothing
	local timer t = timer_start(timer_setData(getTimer(), this_43), 0.0, ref_function_Bar_callUpdateEx)
	set t = null
endfunction

function dispatch_Bar_updateEx takes integer this_43 returns nothing
	if Bar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bar.updateEx")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bar.updateEx on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Bar_updateEx(this_43)
endfunction

function Hero_updateLife takes integer this_43 returns nothing
	call dispatch_Bar_updateEx(Hero_hb[this_43])
	call Unit_updateLife(this_43)
endfunction

function dispatch_Unit_updateLife takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateLife")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateLife on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateLife(this_43)
	else
		call Hero_updateLife(this_43)
	endif
endfunction

function closure_impl takes integer this_43 returns nothing
	set Unit_bonusLife[this_26[this_43]] = Unit_bonusLife[this_26[this_43]] - amount_23[this_43]
	call dispatch_Unit_updateLife(this_26[this_43])
endfunction

function Unit_updateAttackspeed takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal(Unit_bonusAttackspeed[this_43]), Setup_attackSpeedRaw_raw, Setup_attackSpeedRaw_size)
endfunction

function dispatch_Unit_updateAttackspeed takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateAttackspeed")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateAttackspeed on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateAttackspeed(this_43)
	else
		call Unit_updateAttackspeed(this_43)
	endif
endfunction

function closure_impl_2 takes integer this_43 returns nothing
	set Unit_bonusAttackspeed[this_20[this_43]] = Unit_bonusAttackspeed[this_20[this_43]] - amount_17[this_43]
	call dispatch_Unit_updateAttackspeed(this_20[this_43])
endfunction

function Unit_updateArmor takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_armor[this_43] + Unit_bonusArmor[this_43]) * (1. + Unit_bonusArmorPer[this_43] / 100.) - Unit_armor[this_43]), Setup_armorRaw_raw, Setup_armorRaw_size)
endfunction

function dispatch_Unit_updateArmor takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateArmor")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateArmor on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateArmor(this_43)
	else
		call Unit_updateArmor(this_43)
	endif
endfunction

function closure_impl_3 takes integer this_43 returns nothing
	set Unit_bonusArmorPer[this_14[this_43]] = Unit_bonusArmorPer[this_14[this_43]] - amount_11[this_43]
	call dispatch_Unit_updateArmor(this_14[this_43])
endfunction

function Unit_updateManaReg takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_manaReg[this_43] + Unit_bonusManaReg[this_43]) * (1. + Unit_bonusManaRegPer[this_43] / 100.) - Unit_manaReg[this_43]), Setup_manaRegRaw_raw, Setup_manaRegRaw_size)
endfunction

function dispatch_Unit_updateManaReg takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateManaReg")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateManaReg on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateManaReg(this_43)
	else
		call Unit_updateManaReg(this_43)
	endif
endfunction

function closure_impl_4 takes integer this_43 returns nothing
	set Unit_bonusManaReg[this_38[this_43]] = Unit_bonusManaReg[this_38[this_43]] - amount_35[this_43]
	call dispatch_Unit_updateManaReg(this_38[this_43])
endfunction

function Unit_updateLifeReg takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_lifeReg[this_43] + Unit_bonusLifeReg[this_43]) * (1. + Unit_bonusLifeRegPer[this_43] / 100.) - Unit_lifeReg[this_43]), Setup_lifeRegRaw_raw, Setup_lifeRegRaw_size)
endfunction

function dispatch_Unit_updateLifeReg takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateLifeReg")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateLifeReg on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateLifeReg(this_43)
	else
		call Unit_updateLifeReg(this_43)
	endif
endfunction

function closure_impl_5 takes integer this_43 returns nothing
	set Unit_bonusLifeReg[this_30[this_43]] = Unit_bonusLifeReg[this_30[this_43]] - amount_27[this_43]
	call dispatch_Unit_updateLifeReg(this_30[this_43])
endfunction

function closure_impl_6 takes integer this_43 returns nothing
	set Unit_spellpower[this_8[this_43]] = Unit_spellpower[this_8[this_43]] - amount_5[this_43]
endfunction

function closure_impl_7 takes integer this_43 returns nothing
	set Unit_bonusResistancePer[this_18[this_43]] = Unit_bonusResistancePer[this_18[this_43]] - amount_15[this_43]
endfunction

function closure_impl_8 takes integer this_43 returns nothing
	set Unit_bonusResistance[this_16[this_43]] = Unit_bonusResistance[this_16[this_43]] - amount_13[this_43]
endfunction

function Unit_updateMana takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_mana[this_43] + Unit_bonusMana[this_43]) * (1. + Unit_bonusManaPer[this_43] / 100.) - Unit_mana[this_43]), Setup_manaRaw_raw, Setup_manaRaw_size)
endfunction

function Hero_updateMana takes integer this_43 returns nothing
	call dispatch_Bar_updateEx(Hero_hb[this_43])
	call Unit_updateMana(this_43)
endfunction

function dispatch_Unit_updateMana takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateMana")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateMana on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateMana(this_43)
	else
		call Hero_updateMana(this_43)
	endif
endfunction

function closure_impl_9 takes integer this_43 returns nothing
	set Unit_bonusMana[this_34[this_43]] = Unit_bonusMana[this_34[this_43]] - amount_31[this_43]
	call dispatch_Unit_updateMana(this_34[this_43])
endfunction

function Unit_updateAttack takes integer this_43 returns nothing
	call dispatch_Unit_updateState(this_43, roundReal((Unit_attack[this_43] + Unit_bonusAttack[this_43]) * (1. + Unit_bonusAttackPer[this_43] / 100.) - Unit_attack[this_43]), Setup_attackRaw_raw, Setup_attackRaw_size)
endfunction

function dispatch_Unit_updateAttack takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateAttack")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateAttack on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateAttack(this_43)
	else
		call Unit_updateAttack(this_43)
	endif
endfunction

function closure_impl_10 takes integer this_43 returns nothing
	set Unit_bonusAttackPer[this_6[this_43]] = Unit_bonusAttackPer[this_6[this_43]] - amount_3[this_43]
	call dispatch_Unit_updateAttack(this_6[this_43])
endfunction

function closure_impl_11 takes integer this_43 returns nothing
	set Unit_bonusManaPer[this_36[this_43]] = Unit_bonusManaPer[this_36[this_43]] - amount_33[this_43]
	call dispatch_Unit_updateMana(this_36[this_43])
endfunction

function closure_impl_12 takes integer this_43 returns nothing
	set Unit_bonusLife[this_24[this_43]] = Unit_bonusLife[this_24[this_43]] - amount_21[this_43]
	call dispatch_Unit_updateLife(this_24[this_43])
endfunction

function closure_impl_13 takes integer this_43 returns nothing
	set Unit_bonusLifePer[this_28[this_43]] = Unit_bonusLifePer[this_28[this_43]] - amount_25[this_43]
	call dispatch_Unit_updateLife(this_28[this_43])
endfunction

function Unit_updateMovespeed takes integer this_43 returns nothing
	call SetUnitMoveSpeed(Unit_u[this_43], (Unit_movespeed[this_43] + Unit_bonusMovespeed[this_43]) * (1. + Unit_bonusMovespeedPer[this_43] / 100.))
endfunction

function dispatch_Unit_updateMovespeed takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.updateMovespeed")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.updateMovespeed on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_updateMovespeed(this_43)
	else
		call Unit_updateMovespeed(this_43)
	endif
endfunction

function closure_impl_14 takes integer this_43 returns nothing
	set Unit_bonusMovespeed[this_22[this_43]] = Unit_bonusMovespeed[this_22[this_43]] - amount_19[this_43]
	call dispatch_Unit_updateMovespeed(this_22[this_43])
endfunction

function closure_impl_15 takes integer this_43 returns nothing
	set Unit_spellpowerPer[this_10[this_43]] = Unit_spellpowerPer[this_10[this_43]] - amount_7[this_43]
endfunction

function closure_impl_16 takes integer this_43 returns nothing
	set Unit_bonusLifeRegPer[this_32[this_43]] = Unit_bonusLifeRegPer[this_32[this_43]] - amount_29[this_43]
	call dispatch_Unit_updateLifeReg(this_32[this_43])
endfunction

function closure_impl_17 takes integer this_43 returns nothing
	set Unit_bonusManaRegPer[this_40[this_43]] = Unit_bonusManaRegPer[this_40[this_43]] - amount_37[this_43]
	call dispatch_Unit_updateManaReg(this_40[this_43])
endfunction

function closure_impl_18 takes integer this_43 returns nothing
	set Unit_bonusArmor[this_12[this_43]] = Unit_bonusArmor[this_12[this_43]] - amount_9[this_43]
	call dispatch_Unit_updateArmor(this_12[this_43])
endfunction

function closure_impl_19 takes integer this_43 returns nothing
	set Unit_bonusAttack[this_4[this_43]] = Unit_bonusAttack[this_4[this_43]] - amount[this_43]
	call dispatch_Unit_updateAttack(this_4[this_43])
endfunction

function dispatch_Bonus_remove takes integer this_43 returns nothing
	if Bonus_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bonus.remove")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bonus.remove on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Bonus_typeId[this_43] <= 665 then
		if Bonus_typeId[this_43] <= 655 then
			if Bonus_typeId[this_43] <= 651 then
				if Bonus_typeId[this_43] <= 649 then
					if Bonus_typeId[this_43] <= 646 then
						call closure_impl_19(this_43)
					else
						call closure_impl_10(this_43)
					endif
				else
					call closure_impl_6(this_43)
				endif
			elseif Bonus_typeId[this_43] <= 653 then
				call closure_impl_15(this_43)
			else
				call closure_impl_18(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 661 then
			if Bonus_typeId[this_43] <= 659 then
				if Bonus_typeId[this_43] <= 657 then
					call closure_impl_3(this_43)
				else
					call closure_impl_8(this_43)
				endif
			else
				call closure_impl_7(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 663 then
			call closure_impl_2(this_43)
		else
			call closure_impl_14(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 675 then
		if Bonus_typeId[this_43] <= 671 then
			if Bonus_typeId[this_43] <= 669 then
				if Bonus_typeId[this_43] <= 667 then
					call closure_impl_12(this_43)
				else
					call closure_impl(this_43)
				endif
			else
				call closure_impl_13(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 673 then
			call closure_impl_5(this_43)
		else
			call closure_impl_16(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 679 then
		if Bonus_typeId[this_43] <= 677 then
			call closure_impl_9(this_43)
		else
			call closure_impl_11(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 681 then
		call closure_impl_4(this_43)
	else
		call closure_impl_17(this_43)
	endif
endfunction

function Bonus_onDestroy takes integer this_43 returns nothing
	call dispatch_Bonus_remove(this_43)
endfunction

function dealloc_Bonus takes integer obj returns nothing
	if Bonus_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Bonus")
		call I2S(1 / 0)
	else
		set Bonus_nextFree[Bonus_lastFree] = obj
		set Bonus_lastFree = obj
		if Bonus_firstFree == 0 then
			set Bonus_firstFree = obj
			set Bonus_nextFree[obj] = 0
		endif
		set Bonus_typeId[obj] = 0
	endif
endfunction

function destroyBonus takes integer this_43 returns nothing
	call Bonus_onDestroy(this_43)
	call dealloc_Bonus(this_43)
endfunction

function dispatch_Bonus_destroyBonus takes integer this_43 returns nothing
	if Bonus_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bonus.destroyBonus")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bonus.destroyBonus on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Bonus_typeId[this_43] <= 665 then
		if Bonus_typeId[this_43] <= 655 then
			if Bonus_typeId[this_43] <= 651 then
				if Bonus_typeId[this_43] <= 649 then
					if Bonus_typeId[this_43] <= 647 then
						call destroyBonus(this_43)
					else
						call destroyBonus(this_43)
					endif
				else
					call destroyBonus(this_43)
				endif
			elseif Bonus_typeId[this_43] <= 653 then
				call destroyBonus(this_43)
			else
				call destroyBonus(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 661 then
			if Bonus_typeId[this_43] <= 659 then
				if Bonus_typeId[this_43] <= 657 then
					call destroyBonus(this_43)
				else
					call destroyBonus(this_43)
				endif
			else
				call destroyBonus(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 663 then
			call destroyBonus(this_43)
		else
			call destroyBonus(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 675 then
		if Bonus_typeId[this_43] <= 671 then
			if Bonus_typeId[this_43] <= 669 then
				if Bonus_typeId[this_43] <= 667 then
					call destroyBonus(this_43)
				else
					call destroyBonus(this_43)
				endif
			else
				call destroyBonus(this_43)
			endif
		elseif Bonus_typeId[this_43] <= 673 then
			call destroyBonus(this_43)
		else
			call destroyBonus(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 679 then
		if Bonus_typeId[this_43] <= 677 then
			call destroyBonus(this_43)
		else
			call destroyBonus(this_43)
		endif
	elseif Bonus_typeId[this_43] <= 681 then
		call destroyBonus(this_43)
	else
		call destroyBonus(this_43)
	endif
endfunction

function effect_destr takes effect this_43 returns nothing
	call DestroyEffect(this_43)
endfunction

function timer_getElapsed takes timer this_43 returns real
	return TimerGetElapsed(this_43)
endfunction

function getElapsedGameTime takes nothing returns real
	return timer_getElapsed(GameTimer_gameTimer)
endfunction

function int_toReal takes integer this_43 returns real
	return I2R(this_43)
endfunction

function unit_getTypeId takes unit this_43 returns integer
	return GetUnitTypeId(this_43)
endfunction

function unit_remove takes unit this_43 returns nothing
	call RemoveUnit(this_43)
endfunction

function unit_setFacing takes unit this_43, real deg returns unit
	call SetUnitFacing(this_43, deg)
	return this_43
endfunction

function unit_setOwner takes unit this_43, player p, boolean changeColor returns unit
	call SetUnitOwner(this_43, p, changeColor)
	return this_43
endfunction

function recycleDummy takes unit u returns nothing
	local integer rc = DummyRecycler_recycle
	local integer i_2
	if unit_getTypeId(u) == Basics_DUMMY_UNIT_ID and ( not IsUnitInGroup(u, DummyRecycler_protect)) then
		if rc == 0 then
			call unit_remove(u)
			return
		endif
		set DummyRecycler_recycle = DummyRecycler_queueLast[rc]
		set i_2 = R2I(GetUnitFacing(u)) / DummyRecycler_ANG_VAL
		if DummyRecycler_stackN[i_2] < DummyRecycler_ANG_STORAGE_MAX then
			set i_2 = DummyRecycler_ANG_N
			loop
				exitwhen  not (DummyRecycler_stackN[i_2] > DummyRecycler_ANG_STORAGE_MAX)
				set i_2 = i_2 - 1
			endloop
		endif
		set DummyRecycler_queueNext[DummyRecycler_queueLast[i_2]] = rc
		set DummyRecycler_queueLast[i_2] = rc
		set DummyRecycler_queueNext[rc] = 0
		set DummyRecycler_stackN[i_2] = DummyRecycler_stackN[i_2] + 1
		set DummyRecycler_timeStamp[rc] = getElapsedGameTime() + DummyRecycler_DEATH_TIME
		set DummyRecycler_stack[rc] = u
		call GroupAddUnit(DummyRecycler_protect, u)
		call unit_setFacing(u, int_toReal(i_2 * DummyRecycler_ANG_VAL + DummyRecycler_ANG_MID))
		call SetUnitVertexColor(u, 255, 255, 255, 255)
		call SetUnitAnimationByIndex(u, 90)
		call SetUnitScale(u, 1., 1., 1.)
		call unit_setOwner(u, Basics_DUMMY_PLAYER, true)
	else
		call printError("[DummyRecycler] Error: Attempt to recycle invalid unit.")
	endif
endfunction

function Fx_onDestroy takes integer this_43 returns nothing
	if Fx_fx[this_43] != null then
		call effect_destr(Fx_fx[this_43])
	endif
	call recycleDummy(Fx_dummy[this_43])
endfunction

function dealloc_Fx takes integer obj returns nothing
	if Fx_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Fx")
		call I2S(1 / 0)
	else
		set Fx_nextFree[Fx_lastFree] = obj
		set Fx_lastFree = obj
		if Fx_firstFree == 0 then
			set Fx_firstFree = obj
			set Fx_nextFree[obj] = 0
		endif
		set Fx_typeId[obj] = 0
	endif
endfunction

function destroyFx takes integer this_43 returns nothing
	call Fx_onDestroy(this_43)
	call dealloc_Fx(this_43)
endfunction

function dispatch_Fx_destroyFx takes integer this_43 returns nothing
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.destroyFx")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.destroyFx on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyFx(this_43)
endfunction

function lightning_destr takes lightning this_43 returns nothing
	call DestroyLightning(this_43)
endfunction

function CaptureData_onDestroy takes integer this_43 returns nothing
	call lightning_destr(CaptureData_l1[this_43])
	call lightning_destr(CaptureData_l2[this_43])
	if CaptureData_onDeath[this_43] != 0 then
		call dispatch_Action_destroyAction(CaptureData_onDeath[this_43])
	endif
	if CaptureData_fx[this_43] != 0 then
		call dispatch_Fx_destroyFx(CaptureData_fx[this_43])
	endif
	if CaptureData_armor[this_43] != 0 then
		call dispatch_Bonus_destroyBonus(CaptureData_armor[this_43])
		call dispatch_Bonus_destroyBonus(CaptureData_attack[this_43])
		call dispatch_Bonus_destroyBonus(CaptureData_life[this_43])
		call dispatch_Bonus_destroyBonus(CaptureData_mana[this_43])
		call dispatch_Bonus_destroyBonus(CaptureData_spellpower[this_43])
		call dispatch_Bonus_destroyBonus(CaptureData_resistance[this_43])
	endif
endfunction

function dealloc_CaptureData takes integer obj returns nothing
	if CaptureData_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type CaptureData")
		call I2S(1 / 0)
	else
		set CaptureData_nextFree[CaptureData_lastFree] = obj
		set CaptureData_lastFree = obj
		if CaptureData_firstFree == 0 then
			set CaptureData_firstFree = obj
			set CaptureData_nextFree[obj] = 0
		endif
		set CaptureData_typeId[obj] = 0
	endif
endfunction

function destroyCaptureData takes integer this_43 returns nothing
	call CaptureData_onDestroy(this_43)
	call dealloc_CaptureData(this_43)
endfunction

function dispatch_CaptureData_destroyCaptureData takes integer this_43 returns nothing
	if CaptureData_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CaptureData.destroyCaptureData")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CaptureData.destroyCaptureData on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyCaptureData(this_43)
endfunction

function ControlPoint_onDeath takes integer this_43, integer triggerUnit returns nothing
	call dispatch_CaptureData_destroyCaptureData(Unit_ct[triggerUnit])
	set Unit_ct[triggerUnit] = 0
	if IsUnitAlly(Unit_u[triggerUnit], ControlPoint_owner[this_43]) then
		if Unit_isHero[triggerUnit] then
			set ControlPoint_allyHerosInGroup[this_43] = ControlPoint_allyHerosInGroup[this_43] - 1
		else
			set ControlPoint_allysInGroup[this_43] = ControlPoint_allysInGroup[this_43] - 1
		endif
	elseif Unit_isHero[triggerUnit] then
		set ControlPoint_enemyHerosInGroup[this_43] = ControlPoint_enemyHerosInGroup[this_43] - 1
	else
		set ControlPoint_enemysInGroup[this_43] = ControlPoint_enemysInGroup[this_43] - 1
	endif
	call GroupRemoveUnit(ControlPoint_inRange[this_43], Unit_u[triggerUnit])
endfunction

function dispatch_ControlPoint_onDeath takes integer this_43, integer triggerUnit returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.onDeath")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.onDeath on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_onDeath(this_43, triggerUnit)
endfunction

function closure_impl_20 takes integer this_43, integer data returns nothing
	call dispatch_ControlPoint_onDeath(this_3[this_43], Units_target[data])
endfunction

function Button_showDirect takes integer this_43, player p returns nothing
endfunction

function dispatch_Button_showDirect takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Button.showDirect")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Button.showDirect on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Button_showDirect(this_43, p)
endfunction

function alloc_Button takes nothing returns integer
	local integer this_43
	if Widget_firstFree == 0 then
		set Widget_maxIndex = Widget_maxIndex + 1
		set this_43 = Widget_maxIndex
	else
		set this_43 = Widget_firstFree
		set Widget_firstFree = Widget_nextFree[Widget_firstFree]
		set Widget_nextFree[this_43] = 0
	endif
	set Widget_typeId[this_43] = 706
	return this_43
endfunction

function construct_Widget takes integer this_43 returns nothing
endfunction

function construct_WidgetEx takes integer this_43 returns nothing
	call construct_Widget(this_43)
endfunction

function construct_Observable takes integer this_43 returns nothing
	call construct_WidgetEx(this_43)
endfunction

function HTable_put takes integer this_43, handle parentKey, integer childKey, integer data returns nothing
	call hashtable_saveInt(HTable_ht[this_43], GetHandleId(parentKey), childKey, data)
endfunction

function dispatch_HTable_put takes integer this_43, handle parentKey, integer childKey, integer data returns nothing
	if HTable_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HTable.put")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HTable.put on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call HTable_put(this_43, parentKey, childKey, data)
endfunction

function hashtable_loadTrackableHandle takes hashtable this_43, integer parentKey, integer childKey returns trackable
	return LoadTrackableHandle(this_43, parentKey, childKey)
endfunction

function Table3D_get takes integer this_43, integer key1, integer key2, integer key3 returns trackable
	return hashtable_loadTrackableHandle(Table3D_ht[this_43], key1, key2 * Table3D_key3IndexSize[this_43] + key3)
endfunction

function dispatch_Table3D_get takes integer this_43, integer key1, integer key2, integer key3 returns trackable
	local trackable get_result
	if Table3D_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table3D.get")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table3D.get on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set get_result = Table3D_get(this_43, key1, key2, key3)
	set dispatch_Table3D_gettempReturn = get_result
	set get_result = null
	return dispatch_Table3D_gettempReturn
endfunction

function alloc_Icon takes nothing returns integer
	local integer this_43
	if Widget_firstFree == 0 then
		set Widget_maxIndex = Widget_maxIndex + 1
		set this_43 = Widget_maxIndex
	else
		set this_43 = Widget_firstFree
		set Widget_firstFree = Widget_nextFree[Widget_firstFree]
		set Widget_nextFree[this_43] = 0
	endif
	set Widget_typeId[this_43] = 703
	return this_43
endfunction

function LLIterator_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_LLIterator takes integer obj returns nothing
	if LLIterator_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type LLIterator")
		call I2S(1 / 0)
	else
		set LLIterator_nextFree[LLIterator_lastFree] = obj
		set LLIterator_lastFree = obj
		if LLIterator_firstFree == 0 then
			set LLIterator_firstFree = obj
			set LLIterator_nextFree[obj] = 0
		endif
		set LLIterator_typeId[obj] = 0
	endif
endfunction

function destroyLLIterator takes integer this_43 returns nothing
	call LLIterator_onDestroy(this_43)
	call dealloc_LLIterator(this_43)
endfunction

function dispatch_LLIterator_destroyLLIterator takes integer this_43 returns nothing
	if LLIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LLIterator.destroyLLIterator")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LLIterator.destroyLLIterator on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyLLIterator(this_43)
endfunction

function LLIterator_close takes integer this_43 returns nothing
	call dispatch_LLIterator_destroyLLIterator(this_43)
endfunction

function dispatch_LLIterator_close takes integer this_43 returns nothing
	if LLIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LLIterator.close")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LLIterator.close on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call LLIterator_close(this_43)
endfunction

function LLIterator_hasNext takes integer this_43 returns boolean
	return LLEntry_next[LLIterator_current[this_43]] != LLIterator_dummy[this_43]
endfunction

function dispatch_LLIterator_hasNext takes integer this_43 returns boolean
	local boolean hasNext_result
	if LLIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LLIterator.hasNext")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LLIterator.hasNext on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set hasNext_result = LLIterator_hasNext(this_43)
	return hasNext_result
endfunction

function LLIterator_next takes integer this_43 returns integer
	set LLIterator_current[this_43] = LLEntry_next[LLIterator_current[this_43]]
	return LLEntry_elem[LLIterator_current[this_43]]
endfunction

function dispatch_LLIterator_next takes integer this_43 returns integer
	local integer next_result
	if LLIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LLIterator.next")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LLIterator.next on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set next_result = LLIterator_next(this_43)
	return next_result
endfunction

function alloc_LLIterator takes nothing returns integer
	local integer this_43
	if LLIterator_firstFree == 0 then
		set LLIterator_maxIndex = LLIterator_maxIndex + 1
		set this_43 = LLIterator_maxIndex
	else
		set this_43 = LLIterator_firstFree
		set LLIterator_firstFree = LLIterator_nextFree[LLIterator_firstFree]
		set LLIterator_nextFree[this_43] = 0
	endif
	set LLIterator_typeId[this_43] = 3
	return this_43
endfunction

function construct_LLIterator takes integer this_43, integer dummy returns nothing
	set LLIterator_dummy[this_43] = dummy
	set LLIterator_current[this_43] = dummy
endfunction

function new_LLIterator takes integer dummy returns integer
	local integer this_43 = alloc_LLIterator()
	call construct_LLIterator(this_43, dummy)
	return this_43
endfunction

function LinkedList_iterator takes integer this_43 returns integer
	return new_LLIterator(LinkedList_dummy[this_43])
endfunction

function dispatch_LinkedList_iterator takes integer this_43 returns integer
	local integer iterator_result
	if LinkedList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LinkedList.iterator")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LinkedList.iterator on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set iterator_result = LinkedList_iterator(this_43)
	return iterator_result
endfunction

function hashtable_saveBoolean takes hashtable this_43, integer parentKey, integer childKey, boolean value returns hashtable
	call SaveBoolean(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table_saveBoolean takes integer this_43, integer parentKey, boolean value returns nothing
	call hashtable_saveBoolean(Table_ht, this_43, parentKey, value)
endfunction

function dispatch_Table_saveBoolean takes integer this_43, integer parentKey, boolean value returns nothing
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.saveBoolean")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.saveBoolean on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table_saveBoolean(this_43, parentKey, value)
endfunction

function alloc_Table takes nothing returns integer
	local integer this_43
	if Table_firstFree == 0 then
		set Table_maxIndex = Table_maxIndex + 1
		set this_43 = Table_maxIndex
	else
		set this_43 = Table_firstFree
		set Table_firstFree = Table_nextFree[Table_firstFree]
		set Table_nextFree[this_43] = 0
	endif
	set Table_typeId[this_43] = 4
	return this_43
endfunction

function construct_Table takes integer this_43 returns nothing
endfunction

function new_Table takes nothing returns integer
	local integer this_43 = alloc_Table()
	call construct_Table(this_43)
	return this_43
endfunction

function hashtable_loadPlayerHandle takes hashtable this_43, integer parentKey, integer childKey returns player
	return LoadPlayerHandle(this_43, parentKey, childKey)
endfunction

function Table_loadPlayer takes integer this_43, integer parentKey returns player
	return hashtable_loadPlayerHandle(Table_ht, this_43, parentKey)
endfunction

function dispatch_Table_loadPlayer takes integer this_43, integer parentKey returns player
	local player loadPlayer_result
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.loadPlayer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.loadPlayer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set loadPlayer_result = Table_loadPlayer(this_43, parentKey)
	set dispatch_Table_loadPlayertempReturn = loadPlayer_result
	set loadPlayer_result = null
	return dispatch_Table_loadPlayertempReturn
endfunction

function hashtable_saveFogStateHandle takes hashtable this_43, integer parentKey, integer childKey, fogstate value returns hashtable
	call SaveFogStateHandle(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table_saveFogState takes integer this_43, integer parentKey, fogstate value returns nothing
	call hashtable_saveFogStateHandle(Table_ht, this_43, parentKey, value)
endfunction

function dispatch_Table_saveFogState takes integer this_43, integer parentKey, fogstate value returns nothing
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.saveFogState")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.saveFogState on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table_saveFogState(this_43, parentKey, value)
endfunction

function playerFromIndex takes integer index returns player
	call dispatch_Table_saveFogState(TypeCasting_typecastdata, 0, ConvertFogState(index))
	return dispatch_Table_loadPlayer(TypeCasting_typecastdata, 0)
endfunction

function construct_Icon takes integer this_43, integer objId, integer pos_i1, integer pos_i2 returns nothing
	local integer wurst__iterator0
	local player p
	local integer tempIndex
	local integer tempIndex_2
	call construct_Observable(this_43)
	set Icon_d[this_43] = null
	set Icon_canSee[this_43] = new_Table()
	set Icon_needToSee[this_43] = 0
	set Icon_scale[this_43] = 1.
	set tempIndex = this_43
	set Icon_localPos[tempIndex] = Setup_recycleGraveyard_x
	set Icon_localPos_2[tempIndex] = Setup_recycleGraveyard_y
	set tempIndex_2 = this_43
	set Icon_realPos[tempIndex_2] = pos_i1 + Setup_menuStart_x
	set Icon_realPos_2[tempIndex_2] = pos_i2 + Setup_menuStart_y
	set Icon_objId[this_43] = objId
	set wurst__iterator0 = dispatch_LinkedList_iterator(Setup_allPlayers)
	loop
		exitwhen  not dispatch_LLIterator_hasNext(wurst__iterator0)
		set p = playerFromIndex(dispatch_LLIterator_next(wurst__iterator0))
		call dispatch_Table_saveBoolean(Icon_canSee[this_43], GetPlayerId(p), false)
	endloop
	call dispatch_LLIterator_close(wurst__iterator0)
	set p = null
endfunction

function new_Icon takes integer objId, integer pos_i1, integer pos_i2 returns integer
	local integer this_43 = alloc_Icon()
	call construct_Icon(this_43, objId, pos_i1, pos_i2)
	return this_43
endfunction

function construct_Button takes integer this_43, integer fromHere_i1, integer fromHere_i2, integer toHere_i1, integer toHere_i2, integer bt, integer whichMenu returns nothing
	local integer i1
	local integer temp
	local integer i2
	local integer temp_2
	local integer i3
	local trackable t
	local integer temp_3
	call construct_Observable(this_43)
	set Button_onHitAction[this_43] = null
	set Button_onDoubleHitAction[this_43] = null
	set Button_onTrackAction[this_43] = null
	set Button_onUnTrackAction[this_43] = null
	set i1 = fromHere_i1
	set temp = toHere_i1
	loop
		exitwhen i1 > temp
		set i2 = fromHere_i2
		set temp_2 = toHere_i2
		loop
			exitwhen i2 > temp_2
			set i3 = 0
			loop
				exitwhen i3 > 11
				set t = dispatch_Table3D_get(Setup_trackableMap, i1, i2, i3)
				call dispatch_HTable_put(TrackableEventHandler_trackableTrackAction, t, whichMenu, this_43)
				call dispatch_HTable_put(TrackableEventHandler_trackableHitAction, t, whichMenu, this_43)
				call dispatch_HTable_put(TrackableEventHandler_trackableDoubleHitAction, t, whichMenu, this_43)
				set i3 = i3 + 1
			endloop
			set i2 = i2 + 1
		endloop
		set i1 = i1 + 1
	endloop
	set temp_3 = bt
	if temp_3 == 1 then
		set Button_ob[this_43] = new_Icon(1231253358, 30, 20)
	else
		set Button_ob[this_43] = 0
	endif
	set t = null
endfunction

function new_Button takes integer fromHere_i1, integer fromHere_i2, integer toHere_i1, integer toHere_i2, integer bt, integer whichMenu returns integer
	local integer this_43 = alloc_Button()
	call construct_Button(this_43, fromHere_i1, fromHere_i2, toHere_i1, toHere_i2, bt, whichMenu)
	return this_43
endfunction

function alloc_MenuIndexer takes nothing returns integer
	local integer this_43
	if MenuIndexer_firstFree == 0 then
		set MenuIndexer_maxIndex = MenuIndexer_maxIndex + 1
		set this_43 = MenuIndexer_maxIndex
	else
		set this_43 = MenuIndexer_firstFree
		set MenuIndexer_firstFree = MenuIndexer_nextFree[MenuIndexer_firstFree]
		set MenuIndexer_nextFree[this_43] = 0
	endif
	set MenuIndexer_typeId[this_43] = 704
	return this_43
endfunction

function construct_MenuIndexer takes integer this_43 returns nothing
endfunction

function new_MenuIndexer takes nothing returns integer
	local integer this_43 = alloc_MenuIndexer()
	call construct_MenuIndexer(this_43)
	return this_43
endfunction

function afterPreload takes nothing returns nothing
	local integer test = new_MenuIndexer()
	local integer b = new_Button(30, 20, 30, 20, 1, test)
	call dispatch_Button_showDirect(b, Player(0))
	call dispatch_Button_showDirect(b, Player(1))
	set TrackableEventHandler_currentMenuOfPlayer[0] = test
	set TrackableEventHandler_currentMenuOfPlayer[1] = test
endfunction

function closure_impl_21 takes integer this_43, integer i_2 returns nothing
	call afterPreload()
endfunction

function hashtable_loadTimerHandle takes hashtable this_43, integer parentKey, integer childKey returns timer
	return LoadTimerHandle(this_43, parentKey, childKey)
endfunction

function Table_loadTimer takes integer this_43, integer parentKey returns timer
	return hashtable_loadTimerHandle(Table_ht, this_43, parentKey)
endfunction

function dispatch_Table_loadTimer takes integer this_43, integer parentKey returns timer
	local timer loadTimer_result
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.loadTimer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.loadTimer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set loadTimer_result = Table_loadTimer(this_43, parentKey)
	set dispatch_Table_loadTimertempReturn = loadTimer_result
	set loadTimer_result = null
	return dispatch_Table_loadTimertempReturn
endfunction

function Hero_stopCaptureAnimation takes integer this_43 returns nothing
	if dispatch_Table_loadTimer(CaptureAnimation_captureTimer, this_43) != null then
		call timer_release(dispatch_Table_loadTimer(CaptureAnimation_captureTimer, this_43))
	endif
	if Hero_currentEffect[this_43] != null then
		call effect_destr(Hero_currentEffect[this_43])
	endif
endfunction

function closure_impl_22 takes integer this_43, integer u returns nothing
	set CaptureData_captures[Unit_ct[h[this_43]]] = false
	call Hero_stopCaptureAnimation(h[this_43])
endfunction

function LinkedListModule_remove takes integer this_43 returns nothing
	set LinkedListModule_size = LinkedListModule_size - 1
	if this_43 != LinkedListModule_first then
		set LinkedListModule_next[LinkedListModule_prev[this_43]] = LinkedListModule_next[this_43]
	endif
	if this_43 != LinkedListModule_last then
		set LinkedListModule_prev[LinkedListModule_next[this_43]] = LinkedListModule_prev[this_43]
	endif
	if this_43 == LinkedListModule_last then
		set LinkedListModule_last = LinkedListModule_prev[this_43]
	endif
	if this_43 == LinkedListModule_first then
		set LinkedListModule_first = LinkedListModule_next[this_43]
	endif
endfunction

function dispatch_Dot_remove takes integer this_43 returns nothing
	if Dot_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Dot.remove")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Dot.remove on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call LinkedListModule_remove(this_43)
endfunction

function TList_get takes integer this_43, integer index returns integer
	return hashtable_loadInt(TList_ht, this_43, index)
endfunction

function dispatch_TList_get takes integer this_43, integer index returns integer
	local integer get_result
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.get")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.get on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set get_result = TList_get(this_43, index)
	return get_result
endfunction

function TList_setElem takes integer this_43, integer index, integer elem returns nothing
	call hashtable_saveInt(TList_ht, this_43, index, elem)
endfunction

function dispatch_TList_setElem takes integer this_43, integer index, integer elem returns nothing
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.setElem")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.setElem on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TList_setElem(this_43, index, elem)
endfunction

function TList_removeAt takes integer this_43, integer index returns nothing
	local integer i_2
	local integer temp
	set TList_size[this_43] = TList_size[this_43] - 1
	set i_2 = index
	set temp = TList_size[this_43]
	loop
		exitwhen i_2 > temp
		call dispatch_TList_setElem(this_43, i_2, dispatch_TList_get(this_43, i_2 + 1))
		set i_2 = i_2 + 1
	endloop
endfunction

function dispatch_TList_removeAt takes integer this_43, integer index returns nothing
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.removeAt")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.removeAt on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TList_removeAt(this_43, index)
endfunction

function TList_remove takes integer this_43, integer t returns nothing
	local integer i_2 = 0
	local integer temp = TList_size[this_43] - 1
	loop
		exitwhen i_2 > temp
		if dispatch_TList_get(this_43, i_2) == t then
			call dispatch_TList_removeAt(this_43, i_2)
			exitwhen true
		endif
		set i_2 = i_2 + 1
	endloop
endfunction

function dispatch_TList_remove takes integer this_43, integer t returns nothing
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.remove")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.remove on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TList_remove(this_43, t)
endfunction

function Dot_onDestroy takes integer this_43 returns nothing
	call dispatch_Action_destroyAction(Dot_a[this_43])
	call timer_release(Dot_t[this_43])
	call dispatch_TList_remove(Unit_allDots[Dot_u[this_43]], this_43)
	call dispatch_Dot_remove(this_43)
endfunction

function dealloc_Dot takes integer obj returns nothing
	if Dot_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Dot")
		call I2S(1 / 0)
	else
		set Dot_nextFree[Dot_lastFree] = obj
		set Dot_lastFree = obj
		if Dot_firstFree == 0 then
			set Dot_firstFree = obj
			set Dot_nextFree[obj] = 0
		endif
		set Dot_typeId[obj] = 0
	endif
endfunction

function destroyDot takes integer this_43 returns nothing
	call Dot_onDestroy(this_43)
	call dealloc_Dot(this_43)
endfunction

function dispatch_Dot_destroyDot takes integer this_43 returns nothing
	if Dot_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Dot.destroyDot")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Dot.destroyDot on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyDot(this_43)
endfunction

function closure_impl_23 takes integer this_43, integer data returns nothing
	call dispatch_Dot_destroyDot(this[this_43])
endfunction

function Buff_onDestroy takes integer this_43 returns nothing
	call dispatch_Action_destroyAction(Buff_action[this_43])
	call timer_release(Buff_t[this_43])
	call dispatch_TList_remove(Unit_allBuffs[Buff_u[this_43]], this_43)
	if Buff_fxTimer[this_43] != null then
		call timer_release(Buff_fxTimer[this_43])
	endif
	call UnitRemoveAbility(Unit_u[Buff_u[this_43]], Buff_abiId[this_43])
	call UnitRemoveAbility(Unit_u[Buff_u[this_43]], Buff_buffId[this_43])
	if Buff_fx[this_43] != null then
		call DestroyEffect(Buff_fx[this_43])
	endif
endfunction

function dealloc_Buff takes integer obj returns nothing
	if Buff_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Buff")
		call I2S(1 / 0)
	else
		set Buff_nextFree[Buff_lastFree] = obj
		set Buff_lastFree = obj
		if Buff_firstFree == 0 then
			set Buff_firstFree = obj
			set Buff_nextFree[obj] = 0
		endif
		set Buff_typeId[obj] = 0
	endif
endfunction

function destroyBuff takes integer this_43 returns nothing
	call Buff_onDestroy(this_43)
	call dealloc_Buff(this_43)
endfunction

function dispatch_Buff_destroyBuff takes integer this_43 returns nothing
	if Buff_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Buff.destroyBuff")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Buff.destroyBuff on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyBuff(this_43)
endfunction

function closure_impl_24 takes integer this_43, integer data returns nothing
	call dispatch_Buff_destroyBuff(this_2[this_43])
endfunction

function dispatch_Action_fire takes integer this_43, integer d returns nothing
	if Action_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Action.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Action.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Action_typeId[this_43] <= 628 then
		if Action_typeId[this_43] <= 17 then
			if Action_typeId[this_43] <= 15 then
				call closure_impl_23(this_43, d)
			else
				call closure_impl_24(this_43, d)
			endif
		else
			call closure_impl_20(this_43, d)
		endif
	elseif Action_typeId[this_43] <= 629 then
		call closure_impl_22(this_43, d)
	else
		call closure_impl_21(this_43, d)
	endif
endfunction

function Event_stop takes integer this_43, integer d returns boolean
	return false
endfunction

function OnDamageEvent_stop takes integer this_43, integer data returns boolean
	return OnDamageData_stop[data]
endfunction

function SpellEvent_stop takes integer this_43, integer data returns boolean
	return  not SpellData_spellSuccess[data]
endfunction

function dispatch_Event_stop takes integer this_43, integer d returns boolean
	local boolean stop_result
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Event.stop")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Event.stop on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Event_typeId[this_43] <= 693 then
		if Event_typeId[this_43] <= 689 then
			if Event_typeId[this_43] <= 10 then
				set stop_result = Event_stop(this_43, d)
			else
				set stop_result = Event_stop(this_43, d)
			endif
		elseif Event_typeId[this_43] <= 691 then
			set stop_result = OnDamageEvent_stop(this_43, d)
		else
			set stop_result = SpellEvent_stop(this_43, d)
		endif
	elseif Event_typeId[this_43] <= 696 then
		if Event_typeId[this_43] <= 694 then
			set stop_result = Event_stop(this_43, d)
		else
			set stop_result = Event_stop(this_43, d)
		endif
	else
		set stop_result = Event_stop(this_43, d)
	endif
	return stop_result
endfunction

function Event_callActions takes integer this_43, integer d returns nothing
	local integer buffer = Event_first[this_43]
	loop
		exitwhen  not (buffer != 0)
		call dispatch_Action_fire(buffer, d)
		if Event_checkData[this_43] and dispatch_Event_stop(this_43, d) then
			return
		endif
		set buffer = Action_next[buffer]
	endloop
endfunction

function UnitEvent_fire takes integer this_43, integer whichUnit returns nothing
	call Event_callActions(this_43, whichUnit)
endfunction

function dispatch_UnitEvent_fire takes integer this_43, integer whichUnit returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling UnitEvent.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called UnitEvent.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call UnitEvent_fire(this_43, whichUnit)
endfunction

function group_close takes group this_43 returns nothing
	call DestroyGroup(this_43)
endfunction

function group_hasNext takes group this_43 returns boolean
	return FirstOfGroup(this_43) != null
endfunction

function group_iterator takes group this_43 returns group
	set bj_groupAddGroupDest = CreateGroup()
	call ForGroup(this_43, ref_function_GroupAddGroupEnum_2)
	return bj_groupAddGroupDest
endfunction

function group_next takes group this_43 returns unit
	local unit u = FirstOfGroup(this_43)
	call GroupRemoveUnit(this_43, u)
	set group_nexttempReturn = u
	set u = null
	return group_nexttempReturn
endfunction

function unit_getX takes unit this_43 returns real
	return GetUnitX(this_43)
endfunction

function unit_getY takes unit this_43 returns real
	return GetUnitY(this_43)
endfunction

function unit_getPos takes unit this_43 returns real
	set unit_getPos_return_x = unit_getX(this_43)
	set unit_getPos_return_y = unit_getY(this_43)
	return unit_getPos_return_x
endfunction

function unit_getUserData takes unit this_43 returns integer
	return GetUnitUserData(this_43)
endfunction

function real_squared takes real this_43 returns real
	return this_43 * this_43
endfunction

function vec2_distToVec takes real this_x, real this_y, real v_x, real v_y returns real
	return SquareRoot(real_squared(v_x - this_x) + real_squared(v_y - this_y))
endfunction

function Aura_check takes integer this_43 returns nothing
	local group wurst__iterator0
	local unit gu
	local integer obj
	local group tempGroup
	local unit gu_2
	local integer obj_2
	set Filter_filterCheckPlayer = Unit_owner[Aura_u[this_43]]
	set wurst__iterator0 = group_iterator(Aura_g[this_43])
	loop
		exitwhen  not group_hasNext(wurst__iterator0)
		set gu = group_next(wurst__iterator0)
		set obj = unit_getUserData(gu)
		if obj != 0 and vec2_distToVec(unit_getPos(gu), unit_getPos_return_y, unit_getPos(Unit_u[Aura_u[this_43]]), unit_getPos_return_y) > Aura_radius[this_43] then
			call dispatch_UnitEvent_fire(Aura_leave[this_43], obj)
			call GroupRemoveUnit(Aura_g[this_43], gu)
		endif
	endloop
	call group_close(wurst__iterator0)
	set tempGroup = CreateGroup()
	call MoveRectTo(Aura_r[this_43], unit_getX(Unit_u[Aura_u[this_43]]), unit_getY(Unit_u[Aura_u[this_43]]))
	call GroupEnumUnitsInRect(tempGroup, Aura_r[this_43], Aura_filter[this_43])
	loop
		exitwhen  not group_hasNext(tempGroup)
		set gu_2 = group_next(tempGroup)
		set obj_2 = unit_getUserData(gu_2)
		if obj_2 != 0 and vec2_distToVec(unit_getPos(gu_2), unit_getPos_return_y, unit_getPos(Unit_u[Aura_u[this_43]]), unit_getPos_return_y) <= Aura_radius[this_43] and ( not IsUnitInGroup(gu_2, Aura_g[this_43])) then
			call dispatch_UnitEvent_fire(Aura_enter[this_43], obj_2)
			call GroupAddUnit(Aura_g[this_43], gu_2)
		endif
	endloop
	call DestroyGroup(tempGroup)
	set wurst__iterator0 = null
	set gu = null
	set tempGroup = null
	set gu_2 = null
endfunction

function dispatch_Aura_check takes integer this_43 returns nothing
	if Aura_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Aura.check")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Aura.check on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Aura_check(this_43)
endfunction

function Aura_callCheck takes nothing returns nothing
	call dispatch_Aura_check(timer_getData(GetExpiredTimer()))
endfunction

function unit_getState takes unit this_43, unitstate state returns real
	return GetUnitState(this_43, state)
endfunction

function unit_getHP takes unit this_43 returns real
	return unit_getState(this_43, UNIT_STATE_LIFE)
endfunction

function Bar_update takes integer this_43 returns nothing
	local real hp = unit_getHP(Unit_u[Bar_owner[this_43]])
	local real maxHp = GetUnitState(Unit_u[Bar_owner[this_43]], UNIT_STATE_MAX_LIFE)
	local real per = hp / maxHp
	local integer barsGot = roundReal(per * HeroBar_realBarCount) * 2
	local integer shieldBars = roundReal(ShieldList_shieldSum[Unit_shieldList[Bar_owner[this_43]]] / maxHp * HeroBar_realBarCount) * 2
	local integer barsLeft = HeroBar_fakeBarCount - barsGot - shieldBars
	local string hpGot
	local string shield
	local integer manaBarsGot
	local integer manaBarsLeft
	local string manaGot
	local string manaDead
	local string final
	set barsGot = barsGot + barsGot / (Bar_markerDistance[this_43] + 2) * 12
	set hpGot = SubString(Bar_hpFull[this_43], 0, barsGot)
	set shield = SubString(HeroBar_bar, 0, shieldBars)
	set manaBarsGot = roundReal(GetUnitState(Unit_u[Bar_owner[this_43]], UNIT_STATE_MANA) / GetUnitState(Unit_u[Bar_owner[this_43]], UNIT_STATE_MAX_MANA) * HeroBar_realBarCount) * 2
	set manaBarsLeft = HeroBar_fakeBarCount - manaBarsGot
	set manaGot = SubString(HeroBar_bar, 0, manaBarsGot)
	set manaDead = SubString(HeroBar_bar, 0, manaBarsLeft)
	if barsLeft <= 0 then
		set final = hpGot + HeroBar_shieldColor + shield + HeroBar_endColor + "|n" + HeroBar_mpColor + manaGot + HeroBar_endColor + HeroBar_mpColorDead + manaDead + HeroBar_endColor
	else
		set final = hpGot + HeroBar_shieldColor + shield + HeroBar_endColor + HeroBar_hpColorDead + SubString(HeroBar_bar, 0, barsLeft) + HeroBar_endColor + "|n" + HeroBar_mpColor + manaGot + HeroBar_endColor + HeroBar_mpColorDead + manaDead + HeroBar_endColor
	endif
	call SetTextTagText(Bar_tt[this_43], final, 0.01)
endfunction

function dispatch_Bar_update takes integer this_43 returns nothing
	if Bar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bar.update")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bar.update on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Bar_update(this_43)
endfunction

function Bar_updateExDirect takes integer this_43 returns nothing
	local integer i_2
	local integer temp
	local integer charCount
	set Bar_markerDistance[this_43] = (HeroBar_seperateAt * HeroBar_realBarCount / R2I(GetUnitState(Unit_u[Bar_owner[this_43]], UNIT_STATE_MAX_LIFE)) - 1) * 2
	set Bar_hpFull[this_43] = ""
	set i_2 = 1
	set temp = HeroBar_fakeBarCount / (Bar_markerDistance[this_43] + 2)
	loop
		exitwhen i_2 > temp
		set Bar_hpFull[this_43] = Bar_hpFull[this_43] + SubString(HeroBar_bar, 0, Bar_markerDistance[this_43])
		set Bar_hpFull[this_43] = Bar_hpFull[this_43] + HeroBar_marker
		set i_2 = i_2 + 1
	endloop
	set charCount = HeroBar_fakeBarCount / (Bar_markerDistance[this_43] + 2) * (Bar_markerDistance[this_43] + 2)
	set Bar_hpFull[this_43] = Bar_hpFull[this_43] + SubString(HeroBar_bar, 0, HeroBar_fakeBarCount - charCount)
	call dispatch_Bar_update(this_43)
endfunction

function dispatch_Bar_updateExDirect takes integer this_43 returns nothing
	if Bar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bar.updateExDirect")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bar.updateExDirect on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Bar_updateExDirect(this_43)
endfunction

function Bar_callUpdateEx takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Bar_updateExDirect(timer_getData(t))
	call timer_release(t)
	set t = null
	set t = null
endfunction

function Hero_getBarPos takes integer this_43 returns real
	set Hero_getBarPos_return_x = unit_getX(Unit_u[this_43]) - 55.
	set Hero_getBarPos_return_y = unit_getY(Unit_u[this_43])
	set Hero_getBarPos_return_z = GetUnitFlyHeight(Unit_u[this_43]) + Unit_height[this_43]
	return Hero_getBarPos_return_x
endfunction

function dispatch_Hero_getBarPos takes integer this_43 returns real
	local real getBarPos_result_x
	local real getBarPos_result_y
	local real getBarPos_result_z
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.getBarPos")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.getBarPos on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getBarPos_result_x = Hero_getBarPos(this_43)
	set getBarPos_result_y = Hero_getBarPos_return_y
	set getBarPos_result_z = Hero_getBarPos_return_z
	set dispatch_Hero_getBarPos_return_x = getBarPos_result_x
	set dispatch_Hero_getBarPos_return_y = getBarPos_result_y
	set dispatch_Hero_getBarPos_return_z = getBarPos_result_z
	return dispatch_Hero_getBarPos_return_x
endfunction

function texttag_setPos takes texttag this_43, real pos_x, real pos_y, real pos_z returns texttag
	call SetTextTagPos(this_43, pos_x, pos_y, pos_z)
	return this_43
endfunction

function Bar_updatePos_2 takes nothing returns nothing
	local integer b = LinkedListModule_first_2
	loop
		exitwhen  not (b != 0)
		if Bar_isVisible[b] then
			call texttag_setPos(Bar_tt[b], dispatch_Hero_getBarPos(Bar_owner[b]), dispatch_Hero_getBarPos_return_y, dispatch_Hero_getBarPos_return_z)
		endif
		set b = LinkedListModule_next_2[b]
	endloop
endfunction

function texttag_setVisibility takes texttag this_43, boolean flag returns texttag
	call SetTextTagVisibility(this_43, flag)
	return this_43
endfunction

function Bar_updateVision_2 takes nothing returns nothing
	local integer b = LinkedListModule_first_2
	loop
		exitwhen  not (b != 0)
		if Bar_check[b] then
			if IsVisibleToPlayer(unit_getX(Unit_u[Bar_owner[b]]), unit_getY(Unit_u[Bar_owner[b]]), GetLocalPlayer()) then
				set Bar_isVisible[b] = true
				call texttag_setVisibility(Bar_tt[b], true)
			else
				set Bar_isVisible[b] = false
				call texttag_setVisibility(Bar_tt[b], false)
			endif
			call dispatch_Bar_update(b)
			set b = LinkedListModule_next_2[b]
		endif
	endloop
endfunction

function unit_addEffect takes unit this_43, string fx, string attachment returns effect
	return AddSpecialEffectTarget(fx, this_43, attachment)
endfunction

function Buff_createEffect takes nothing returns nothing
	local timer t = GetExpiredTimer()
	local integer b = timer_getData(t)
	if Buff_fxCounter[b] > 0 then
		call DestroyEffect(unit_addEffect(Unit_u[Buff_u[b]], Buff_fxType[b], Buff_attachment[b]))
		set Buff_fxCounter[b] = Buff_fxCounter[b] - 1
	else
		call timer_release(t)
	endif
	set t = null
endfunction

function Buff_timerDestroyBuff takes nothing returns nothing
	call dispatch_Buff_destroyBuff(timer_getData(GetExpiredTimer()))
endfunction

function dispatch_CallbackCounted_call takes integer this_43, integer cb returns nothing
endfunction

function CallbackCounted_onDestroy takes integer this_43 returns nothing
	call timer_release(CallbackCounted_t[this_43])
endfunction

function dealloc_CallbackCounted takes integer obj returns nothing
	if CallbackCounted_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type CallbackCounted")
		call I2S(1 / 0)
	else
		set CallbackCounted_nextFree[CallbackCounted_lastFree] = obj
		set CallbackCounted_lastFree = obj
		if CallbackCounted_firstFree == 0 then
			set CallbackCounted_firstFree = obj
			set CallbackCounted_nextFree[obj] = 0
		endif
		set CallbackCounted_typeId[obj] = 0
	endif
endfunction

function destroyCallbackCounted takes integer this_43 returns nothing
	call CallbackCounted_onDestroy(this_43)
	call dealloc_CallbackCounted(this_43)
endfunction

function dispatch_CallbackCounted_destroyCallbackCounted takes integer this_43 returns nothing
	if CallbackCounted_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CallbackCounted.destroyCallbackCounted")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CallbackCounted.destroyCallbackCounted on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyCallbackCounted(this_43)
endfunction

function CallbackCounted_callAndCount takes integer this_43 returns nothing
	call dispatch_CallbackCounted_call(this_43, this_43)
	set CallbackCounted_count[this_43] = CallbackCounted_count[this_43] + 1
	if CallbackCounted_count[this_43] >= CallbackCounted_maxCount[this_43] then
		call dispatch_CallbackCounted_destroyCallbackCounted(this_43)
	endif
endfunction

function dispatch_CallbackCounted_callAndCount takes integer this_43 returns nothing
	if CallbackCounted_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CallbackCounted.callAndCount")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CallbackCounted.callAndCount on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call CallbackCounted_callAndCount(this_43)
endfunction

function CallbackCounted_staticCallback takes nothing returns nothing
	call dispatch_CallbackCounted_callAndCount(timer_getData(GetExpiredTimer()))
endfunction

function dispatch_CallbackPeriodic_call takes integer this_43, integer cb returns nothing
endfunction

function CallbackPeriodic_staticCallback takes nothing returns nothing
	local integer cb = timer_getData(GetExpiredTimer())
	call dispatch_CallbackPeriodic_call(cb, cb)
endfunction

function closure_impl_25 takes integer this_43 returns nothing
	set Unit_bonusLifePer[this_29[this_43]] = Unit_bonusLifePer[this_29[this_43]] - amount_26[this_43]
	call dispatch_Unit_updateLife(this_29[this_43])
endfunction

function closure_impl_26 takes integer this_43 returns nothing
	set Unit_bonusAttackspeed[this_21[this_43]] = Unit_bonusAttackspeed[this_21[this_43]] - amount_18[this_43]
	call dispatch_Unit_updateAttackspeed(this_21[this_43])
endfunction

function dispatch_Hero_updateLife takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.updateLife")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.updateLife on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_updateLife(this_43)
endfunction

function dispatch_Hero_updateMana takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.updateMana")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.updateMana on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_updateMana(this_43)
endfunction

function closure_impl_27 takes integer this_43 returns nothing
	set Hero_onAdd[this_42[this_43]] = false
	call dispatch_Unit_updateArmor(this_42[this_43])
	call dispatch_Hero_updateLife(this_42[this_43])
	call dispatch_Hero_updateMana(this_42[this_43])
endfunction

function closure_impl_28 takes integer this_43 returns nothing
	set Unit_bonusArmorPer[this_15[this_43]] = Unit_bonusArmorPer[this_15[this_43]] - amount_12[this_43]
	call dispatch_Unit_updateArmor(this_15[this_43])
endfunction

function closure_impl_29 takes integer this_43 returns nothing
	set Unit_spellpower[this_9[this_43]] = Unit_spellpower[this_9[this_43]] - amount_6[this_43]
endfunction

function closure_impl_30 takes integer this_43 returns nothing
	set Unit_bonusManaReg[this_39[this_43]] = Unit_bonusManaReg[this_39[this_43]] - amount_36[this_43]
	call dispatch_Unit_updateManaReg(this_39[this_43])
endfunction

function closure_impl_31 takes integer this_43 returns nothing
	set Unit_bonusMana[this_37[this_43]] = Unit_bonusMana[this_37[this_43]] - amount_34[this_43]
	call dispatch_Unit_updateMana(this_37[this_43])
endfunction

function closure_impl_32 takes integer this_43 returns nothing
	set Unit_bonusAttackPer[this_7[this_43]] = Unit_bonusAttackPer[this_7[this_43]] - amount_4[this_43]
	call dispatch_Unit_updateAttack(this_7[this_43])
endfunction

function closure_impl_33 takes integer this_43 returns nothing
	set Unit_bonusMovespeed[this_23[this_43]] = Unit_bonusMovespeed[this_23[this_43]] - amount_20[this_43]
	call dispatch_Unit_updateMovespeed(this_23[this_43])
endfunction

function closure_impl_34 takes integer this_43 returns nothing
	set Unit_bonusLife[this_27[this_43]] = Unit_bonusLife[this_27[this_43]] - amount_24[this_43]
	call dispatch_Unit_updateLife(this_27[this_43])
endfunction

function closure_impl_35 takes integer this_43 returns nothing
	set Unit_bonusResistancePer[this_19[this_43]] = Unit_bonusResistancePer[this_19[this_43]] - amount_16[this_43]
endfunction

function closure_impl_36 takes integer this_43 returns nothing
	set Unit_spellpowerPer[this_11[this_43]] = Unit_spellpowerPer[this_11[this_43]] - amount_8[this_43]
endfunction

function closure_impl_37 takes integer this_43 returns nothing
	set Unit_bonusResistance[this_17[this_43]] = Unit_bonusResistance[this_17[this_43]] - amount_14[this_43]
endfunction

function closure_impl_38 takes integer this_43 returns nothing
	set Unit_bonusLifeRegPer[this_33[this_43]] = Unit_bonusLifeRegPer[this_33[this_43]] - amount_30[this_43]
	call dispatch_Unit_updateLifeReg(this_33[this_43])
endfunction

function closure_impl_39 takes integer this_43 returns nothing
	set Unit_bonusManaRegPer[this_41[this_43]] = Unit_bonusManaRegPer[this_41[this_43]] - amount_38[this_43]
	call dispatch_Unit_updateManaReg(this_41[this_43])
endfunction

function closure_impl_40 takes integer this_43 returns nothing
	set Unit_bonusMovespeedPer[this_25[this_43]] = Unit_bonusMovespeedPer[this_25[this_43]] - amount_22[this_43]
	call dispatch_Unit_updateMovespeed(this_25[this_43])
endfunction

function closure_impl_41 takes integer this_43 returns nothing
	set Unit_bonusMana[this_35[this_43]] = Unit_bonusMana[this_35[this_43]] - amount_32[this_43]
	call dispatch_Unit_updateMana(this_35[this_43])
endfunction

function closure_impl_42 takes integer this_43 returns nothing
	set Unit_bonusLifeReg[this_31[this_43]] = Unit_bonusLifeReg[this_31[this_43]] - amount_28[this_43]
	call dispatch_Unit_updateLifeReg(this_31[this_43])
endfunction

function closure_impl_43 takes integer this_43 returns nothing
	set Unit_bonusArmor[this_13[this_43]] = Unit_bonusArmor[this_13[this_43]] - amount_10[this_43]
	call dispatch_Unit_updateArmor(this_13[this_43])
endfunction

function closure_impl_44 takes integer this_43 returns nothing
	set Unit_bonusAttack[this_5[this_43]] = Unit_bonusAttack[this_5[this_43]] - amount_2[this_43]
	call dispatch_Unit_updateAttack(this_5[this_43])
endfunction

function dispatch_CallbackSingle_call takes integer this_43 returns nothing
	if CallbackSingle_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CallbackSingle.call")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CallbackSingle.call on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if CallbackSingle_typeId[this_43] <= 666 then
		if CallbackSingle_typeId[this_43] <= 656 then
			if CallbackSingle_typeId[this_43] <= 652 then
				if CallbackSingle_typeId[this_43] <= 650 then
					if CallbackSingle_typeId[this_43] <= 648 then
						call closure_impl_44(this_43)
					else
						call closure_impl_32(this_43)
					endif
				else
					call closure_impl_29(this_43)
				endif
			elseif CallbackSingle_typeId[this_43] <= 654 then
				call closure_impl_36(this_43)
			else
				call closure_impl_43(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 662 then
			if CallbackSingle_typeId[this_43] <= 660 then
				if CallbackSingle_typeId[this_43] <= 658 then
					call closure_impl_28(this_43)
				else
					call closure_impl_37(this_43)
				endif
			else
				call closure_impl_35(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 664 then
			call closure_impl_26(this_43)
		else
			call closure_impl_33(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 676 then
		if CallbackSingle_typeId[this_43] <= 672 then
			if CallbackSingle_typeId[this_43] <= 670 then
				if CallbackSingle_typeId[this_43] <= 668 then
					call closure_impl_40(this_43)
				else
					call closure_impl_34(this_43)
				endif
			else
				call closure_impl_25(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 674 then
			call closure_impl_42(this_43)
		else
			call closure_impl_38(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 682 then
		if CallbackSingle_typeId[this_43] <= 680 then
			if CallbackSingle_typeId[this_43] <= 678 then
				call closure_impl_41(this_43)
			else
				call closure_impl_31(this_43)
			endif
		else
			call closure_impl_30(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 684 then
		call closure_impl_39(this_43)
	else
		call closure_impl_27(this_43)
	endif
endfunction

function CallbackSingle_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_CallbackSingle takes integer obj returns nothing
	if CallbackSingle_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type CallbackSingle")
		call I2S(1 / 0)
	else
		set CallbackSingle_nextFree[CallbackSingle_lastFree] = obj
		set CallbackSingle_lastFree = obj
		if CallbackSingle_firstFree == 0 then
			set CallbackSingle_firstFree = obj
			set CallbackSingle_nextFree[obj] = 0
		endif
		set CallbackSingle_typeId[obj] = 0
	endif
endfunction

function destroyCallbackSingle takes integer this_43 returns nothing
	call CallbackSingle_onDestroy(this_43)
	call dealloc_CallbackSingle(this_43)
endfunction

function dispatch_CallbackSingle_destroyCallbackSingle takes integer this_43 returns nothing
	if CallbackSingle_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CallbackSingle.destroyCallbackSingle")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CallbackSingle.destroyCallbackSingle on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if CallbackSingle_typeId[this_43] <= 666 then
		if CallbackSingle_typeId[this_43] <= 656 then
			if CallbackSingle_typeId[this_43] <= 650 then
				if CallbackSingle_typeId[this_43] <= 648 then
					if CallbackSingle_typeId[this_43] <= 609 then
						call destroyCallbackSingle(this_43)
					else
						call destroyCallbackSingle(this_43)
					endif
				else
					call destroyCallbackSingle(this_43)
				endif
			elseif CallbackSingle_typeId[this_43] <= 654 then
				if CallbackSingle_typeId[this_43] <= 652 then
					call destroyCallbackSingle(this_43)
				else
					call destroyCallbackSingle(this_43)
				endif
			else
				call destroyCallbackSingle(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 662 then
			if CallbackSingle_typeId[this_43] <= 660 then
				if CallbackSingle_typeId[this_43] <= 658 then
					call destroyCallbackSingle(this_43)
				else
					call destroyCallbackSingle(this_43)
				endif
			else
				call destroyCallbackSingle(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 664 then
			call destroyCallbackSingle(this_43)
		else
			call destroyCallbackSingle(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 676 then
		if CallbackSingle_typeId[this_43] <= 672 then
			if CallbackSingle_typeId[this_43] <= 670 then
				if CallbackSingle_typeId[this_43] <= 668 then
					call destroyCallbackSingle(this_43)
				else
					call destroyCallbackSingle(this_43)
				endif
			else
				call destroyCallbackSingle(this_43)
			endif
		elseif CallbackSingle_typeId[this_43] <= 674 then
			call destroyCallbackSingle(this_43)
		else
			call destroyCallbackSingle(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 682 then
		if CallbackSingle_typeId[this_43] <= 680 then
			if CallbackSingle_typeId[this_43] <= 678 then
				call destroyCallbackSingle(this_43)
			else
				call destroyCallbackSingle(this_43)
			endif
		else
			call destroyCallbackSingle(this_43)
		endif
	elseif CallbackSingle_typeId[this_43] <= 684 then
		call destroyCallbackSingle(this_43)
	else
		call destroyCallbackSingle(this_43)
	endif
endfunction

function CallbackSingle_staticCallback takes nothing returns nothing
	local timer t = GetExpiredTimer()
	local integer cb = timer_getData(t)
	call dispatch_CallbackSingle_call(cb)
	call dispatch_CallbackSingle_destroyCallbackSingle(cb)
	call timer_release(t)
	set t = null
endfunction

function alloc_Closure takes nothing returns integer
	local integer this_43
	if Action_firstFree == 0 then
		set Action_maxIndex = Action_maxIndex + 1
		set this_43 = Action_maxIndex
	else
		set this_43 = Action_firstFree
		set Action_firstFree = Action_nextFree[Action_firstFree]
		set Action_nextFree[this_43] = 0
	endif
	set Action_typeId[this_43] = 628
	return this_43
endfunction

function createLightning takes string typ, real pos1_x, real pos1_y, real pos1_z, real pos2_x, real pos2_y, real pos2_z returns lightning
	return AddLightningEx(typ, true, pos1_x, pos1_y, pos1_z, pos2_x, pos2_y, pos2_z)
endfunction

function alloc_Closure_2 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 657
	return this_43
endfunction

function Unit_bonusArmorPer_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusArmorPer[this_43] = Unit_bonusArmorPer[this_43] + amount_39
	call dispatch_Unit_updateArmor(this_43)
	set clVar = alloc_Closure_2()
	set this_14[clVar] = this_43
	set amount_11[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusArmorPer takes integer this_43, real amount_39 returns integer
	local integer bonusArmorPer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusArmorPer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusArmorPer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusArmorPer_result = Unit_bonusArmorPer_2(this_43, amount_39)
	else
		set bonusArmorPer_result = Unit_bonusArmorPer_2(this_43, amount_39)
	endif
	return bonusArmorPer_result
endfunction

function alloc_Closure_3 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 649
	return this_43
endfunction

function Unit_bonusAttackPer_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusAttackPer[this_43] = Unit_bonusAttackPer[this_43] + amount_39
	call dispatch_Unit_updateAttack(this_43)
	set clVar = alloc_Closure_3()
	set this_6[clVar] = this_43
	set amount_3[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusAttackPer takes integer this_43, real amount_39 returns integer
	local integer bonusAttackPer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusAttackPer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusAttackPer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusAttackPer_result = Unit_bonusAttackPer_2(this_43, amount_39)
	else
		set bonusAttackPer_result = Unit_bonusAttackPer_2(this_43, amount_39)
	endif
	return bonusAttackPer_result
endfunction

function alloc_Closure_4 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 671
	return this_43
endfunction

function Unit_bonusLifePer_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusLifePer[this_43] = Unit_bonusLifePer[this_43] + amount_39
	call dispatch_Unit_updateLife(this_43)
	set clVar = alloc_Closure_4()
	set this_28[clVar] = this_43
	set amount_25[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusLifePer takes integer this_43, real amount_39 returns integer
	local integer bonusLifePer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusLifePer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusLifePer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusLifePer_result = Unit_bonusLifePer_2(this_43, amount_39)
	else
		set bonusLifePer_result = Unit_bonusLifePer_2(this_43, amount_39)
	endif
	return bonusLifePer_result
endfunction

function alloc_Closure_5 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 679
	return this_43
endfunction

function Unit_bonusManaPer_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusManaPer[this_43] = Unit_bonusManaPer[this_43] + amount_39
	call dispatch_Unit_updateMana(this_43)
	set clVar = alloc_Closure_5()
	set this_36[clVar] = this_43
	set amount_33[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusManaPer takes integer this_43, real amount_39 returns integer
	local integer bonusManaPer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusManaPer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusManaPer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusManaPer_result = Unit_bonusManaPer_2(this_43, amount_39)
	else
		set bonusManaPer_result = Unit_bonusManaPer_2(this_43, amount_39)
	endif
	return bonusManaPer_result
endfunction

function alloc_Closure_6 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 661
	return this_43
endfunction

function Unit_bonusResistancePer_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusResistancePer[this_43] = Unit_bonusResistancePer[this_43] + amount_39
	set clVar = alloc_Closure_6()
	set this_18[clVar] = this_43
	set amount_15[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusResistancePer takes integer this_43, real amount_39 returns integer
	local integer bonusResistancePer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusResistancePer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusResistancePer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusResistancePer_result = Unit_bonusResistancePer_2(this_43, amount_39)
	else
		set bonusResistancePer_result = Unit_bonusResistancePer_2(this_43, amount_39)
	endif
	return bonusResistancePer_result
endfunction

function alloc_Closure_7 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 653
	return this_43
endfunction

function Unit_bonusSpellpowerPer takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_spellpowerPer[this_43] = Unit_spellpowerPer[this_43] + amount_39
	set clVar = alloc_Closure_7()
	set this_10[clVar] = this_43
	set amount_7[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusSpellpowerPer takes integer this_43, real amount_39 returns integer
	local integer bonusSpellpowerPer_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusSpellpowerPer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusSpellpowerPer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusSpellpowerPer_result = Unit_bonusSpellpowerPer(this_43, amount_39)
	else
		set bonusSpellpowerPer_result = Unit_bonusSpellpowerPer(this_43, amount_39)
	endif
	return bonusSpellpowerPer_result
endfunction

function ControlPoint_addAllBons takes integer this_43, integer u returns nothing
	local integer ct = Unit_ct[u]
	set CaptureData_armor[ct] = dispatch_Unit_bonusArmorPer(u, 10.)
	set CaptureData_attack[ct] = dispatch_Unit_bonusAttackPer(u, 10.)
	set CaptureData_life[ct] = dispatch_Unit_bonusLifePer(u, 10.)
	set CaptureData_mana[ct] = dispatch_Unit_bonusManaPer(u, 10.)
	set CaptureData_resistance[ct] = dispatch_Unit_bonusResistancePer(u, 10.)
	set CaptureData_spellpower[ct] = dispatch_Unit_bonusSpellpowerPer(u, 10.)
endfunction

function dispatch_ControlPoint_addAllBons takes integer this_43, integer u returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.addAllBons")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.addAllBons on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_addAllBons(this_43, u)
endfunction

function ControlPoint_selfHeal takes integer this_43 returns nothing
	local real heal = ControlPoint_baseSHeal + ControlPoint_heroSHealFactor * ControlPoint_allyHerosInGroup[this_43] + ControlPoint_unitSHealFactor * ControlPoint_allysInGroup[this_43]
	if ControlPoint_hp[this_43] + heal >= 1000. then
		set ControlPoint_hp[this_43] = 1000.
	else
		set ControlPoint_hp[this_43] = ControlPoint_hp[this_43] + heal
	endif
endfunction

function dispatch_ControlPoint_selfHeal takes integer this_43 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.selfHeal")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.selfHeal on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_selfHeal(this_43)
endfunction

function real_toInt takes real this_43 returns integer
	return R2I(this_43)
endfunction

function unit_setVertexColor takes unit this_43, integer col_red, integer col_green, integer col_blue returns unit
	call SetUnitVertexColor(this_43, col_red, col_green, col_blue, 255)
	return this_43
endfunction

function ControlPoint_setColor takes integer this_43 returns nothing
	local real helpHP = ControlPoint_hp[this_43]
	local real green
	local real red
	local real red_2
	local real green_2
	if ControlPoint_hp[this_43] >= 500. then
		set helpHP = 500.
	endif
	if IsPlayerAlly(GetLocalPlayer(), ControlPoint_owner[this_43]) then
		set helpHP = helpHP + 500.
		set green = 30. + helpHP / 1000. * 225.
		set red = 255. - helpHP / 1000. * 225.
		call unit_setVertexColor(ControlPoint_visualDummy[this_43], real_toInt(red), real_toInt(green), 30)
	else
		set helpHP = helpHP + 500.
		set red_2 = 30. + helpHP / 1000. * 225.
		set green_2 = 255. - helpHP / 1000. * 225.
		call unit_setVertexColor(ControlPoint_visualDummy[this_43], real_toInt(red_2), real_toInt(green_2), 30)
	endif
endfunction

function dispatch_ControlPoint_setColor takes integer this_43 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.setColor")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.setColor on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_setColor(this_43)
endfunction

function hashtable_saveTimerHandle takes hashtable this_43, integer parentKey, integer childKey, timer value returns hashtable
	call SaveTimerHandle(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table_saveTimer takes integer this_43, integer parentKey, timer value returns nothing
	call hashtable_saveTimerHandle(Table_ht, this_43, parentKey, value)
endfunction

function dispatch_Table_saveTimer takes integer this_43, integer parentKey, timer value returns nothing
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.saveTimer")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.saveTimer on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table_saveTimer(this_43, parentKey, value)
endfunction

function timer_startPeriodic takes timer this_43, real time, code timerCallBack returns timer
	call TimerStart(this_43, time, true, timerCallBack)
	return this_43
endfunction

function Hero_playCaptureAnimation takes integer this_43 returns nothing
	local timer t
	if Hero_hasPeriodicAnimation[this_43] then
		set t = getTimer()
		call timer_setData(t, this_43)
		call timer_startPeriodic(t, Hero_animationIntervall[this_43], ref_function_playAnimation)
		call dispatch_Table_saveTimer(CaptureAnimation_captureTimer, this_43, t)
		call SetUnitAnimationByIndex(Unit_u[this_43], Hero_animationIndex[this_43])
	else
		call SetUnitAnimationByIndex(Unit_u[this_43], Hero_animationIndex[this_43])
	endif
	if Hero_captureEffect[this_43] != null then
		set Hero_currentEffect[this_43] = unit_addEffect(Unit_u[this_43], Hero_captureEffect[this_43], Hero_captureEffectAttachmentPoint[this_43])
	endif
	call SetUnitTimeScale(Unit_u[this_43], Hero_animationSpeed[this_43] / 100.)
	set t = null
endfunction

function alloc_Closure_8 takes nothing returns integer
	local integer this_43
	if Action_firstFree == 0 then
		set Action_maxIndex = Action_maxIndex + 1
		set this_43 = Action_maxIndex
	else
		set this_43 = Action_firstFree
		set Action_firstFree = Action_nextFree[Action_firstFree]
		set Action_nextFree[this_43] = 0
	endif
	set Action_typeId[this_43] = 629
	return this_43
endfunction

function angle_op_plus takes real this_radians, real other_radians returns real
	return this_radians + other_radians
endfunction

function Unit_getMiddle takes integer this_43 returns real
	set Unit_getMiddle_return_x = unit_getX(Unit_u[this_43])
	set Unit_getMiddle_return_y = unit_getY(Unit_u[this_43])
	set Unit_getMiddle_return_z = Unit_height[this_43] / 2.
	return Unit_getMiddle_return_x
endfunction

function dispatch_Unit_getMiddle takes integer this_43 returns real
	local real getMiddle_result_x
	local real getMiddle_result_y
	local real getMiddle_result_z
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.getMiddle")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.getMiddle on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set getMiddle_result_x = Unit_getMiddle(this_43)
		set getMiddle_result_y = Unit_getMiddle_return_y
		set getMiddle_result_z = Unit_getMiddle_return_z
	else
		set getMiddle_result_x = Unit_getMiddle(this_43)
		set getMiddle_result_y = Unit_getMiddle_return_y
		set getMiddle_result_z = Unit_getMiddle_return_z
	endif
	set dispatch_Unit_getMiddle_return_x = getMiddle_result_x
	set dispatch_Unit_getMiddle_return_y = getMiddle_result_y
	set dispatch_Unit_getMiddle_return_z = getMiddle_result_z
	return dispatch_Unit_getMiddle_return_x
endfunction

function real_asAngleRadians takes real this_43 returns real
	return this_43
endfunction

function vec2_angleTo takes real this_x, real this_y, real v_x, real v_y returns real
	return real_asAngleRadians(Atan2(v_y - this_y, v_x - this_x))
endfunction

function angle_toVec takes real this_radians, real len returns real
	set angle_toVec_return_x = Cos(this_radians) * len
	set angle_toVec_return_y = Sin(this_radians) * len
	return angle_toVec_return_x
endfunction

function vec2_op_plus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_plus_return_x = this_x + v_x
	set vec2_op_plus_return_y = this_y + v_y
	return vec2_op_plus_return_x
endfunction

function vec2_polarOffset takes real this_x, real this_y, real ang_radians, real dist returns real
	set vec2_polarOffset_return_x = vec2_op_plus(this_x, this_y, angle_toVec(ang_radians, dist), angle_toVec_return_y)
	set vec2_polarOffset_return_y = vec2_op_plus_return_y
	return vec2_polarOffset_return_x
endfunction

function vec3_toVec2 takes real this_x, real this_y, real this_z returns real
	set vec3_toVec2_return_x = this_x
	set vec3_toVec2_return_y = this_y
	return vec3_toVec2_return_x
endfunction

function Hero_getCaptureAttackPoint takes integer this_43, real controllPointPos_x, real controllPointPos_y, real controllPointPos_z returns real
	local real pos_x = dispatch_Unit_getMiddle(this_43)
	local real pos_y = dispatch_Unit_getMiddle_return_y
	local real pos_z = dispatch_Unit_getMiddle_return_z
	local real pos2D_x = vec3_toVec2(pos_x, pos_y, pos_z)
	local real pos2D_y = vec3_toVec2_return_y
	local integer tempIndex
	local real temp
	local real temp_2
	local real temp_3
	set pos_z = pos_z + Hero_captureOffsetZ[this_43]
	set temp_2 = pos2D_x
	set temp_3 = pos2D_y
	set temp = vec2_angleTo(pos2D_x, pos2D_y, vec3_toVec2(controllPointPos_x, controllPointPos_y, controllPointPos_z), vec3_toVec2_return_y)
	set tempIndex = this_43
	set pos2D_x = vec2_polarOffset(temp_2, temp_3, angle_op_plus(temp, Hero_captureOffsetAngle[tempIndex]), Hero_captureOffsetDistance[this_43])
	set pos2D_y = vec2_polarOffset_return_y
	set pos_x = pos2D_x
	set pos_y = pos2D_y
	set Hero_getCaptureAttackPoint_return_x = pos_x
	set Hero_getCaptureAttackPoint_return_y = pos_y
	set Hero_getCaptureAttackPoint_return_z = pos_z
	return Hero_getCaptureAttackPoint_return_x
endfunction

function dispatch_Hero_getCaptureAttackPoint takes integer this_43, real controllPointPos_x, real controllPointPos_y, real controllPointPos_z returns real
	local real getCaptureAttackPoint_result_x
	local real getCaptureAttackPoint_result_y
	local real getCaptureAttackPoint_result_z
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.getCaptureAttackPoint")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.getCaptureAttackPoint on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getCaptureAttackPoint_result_x = Hero_getCaptureAttackPoint(this_43, controllPointPos_x, controllPointPos_y, controllPointPos_z)
	set getCaptureAttackPoint_result_y = Hero_getCaptureAttackPoint_return_y
	set getCaptureAttackPoint_result_z = Hero_getCaptureAttackPoint_return_z
	set dispatch_Hero_getCaptureAttackPoint_return_x = getCaptureAttackPoint_result_x
	set dispatch_Hero_getCaptureAttackPoint_return_y = getCaptureAttackPoint_result_y
	set dispatch_Hero_getCaptureAttackPoint_return_z = getCaptureAttackPoint_result_z
	return dispatch_Hero_getCaptureAttackPoint_return_x
endfunction

function Event_addAction takes integer this_43, integer a returns integer
	set Action_ev[a] = this_43
	if Event_first[this_43] == 0 then
		set Event_first[this_43] = a
		set Event_last[this_43] = a
		set Action_next[a] = 0
		set Action_prev[a] = 0
	else
		set Action_prev[Event_first[this_43]] = a
		set Action_next[a] = Event_first[this_43]
		set Event_first[this_43] = a
	endif
	return a
endfunction

function dispatch_Event_addAction takes integer this_43, integer a returns integer
	local integer addAction_result
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Event.addAction")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Event.addAction on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Event_typeId[this_43] <= 691 then
		if Event_typeId[this_43] <= 689 then
			if Event_typeId[this_43] <= 10 then
				set addAction_result = Event_addAction(this_43, a)
			else
				set addAction_result = Event_addAction(this_43, a)
			endif
		else
			set addAction_result = Event_addAction(this_43, a)
		endif
	elseif Event_typeId[this_43] <= 696 then
		if Event_typeId[this_43] <= 694 then
			set addAction_result = Event_addAction(this_43, a)
		else
			set addAction_result = Event_addAction(this_43, a)
		endif
	else
		set addAction_result = Event_addAction(this_43, a)
	endif
	return addAction_result
endfunction

function alloc_UnitEvent takes nothing returns integer
	local integer this_43
	if Event_firstFree == 0 then
		set Event_maxIndex = Event_maxIndex + 1
		set this_43 = Event_maxIndex
	else
		set this_43 = Event_firstFree
		set Event_firstFree = Event_nextFree[Event_firstFree]
		set Event_nextFree[this_43] = 0
	endif
	set Event_typeId[this_43] = 694
	return this_43
endfunction

function construct_Event takes integer this_43 returns nothing
	set Event_first[this_43] = 0
	set Event_last[this_43] = 0
	set Event_checkData[this_43] = false
endfunction

function construct_UnitEvent takes integer this_43 returns nothing
	call construct_Event(this_43)
endfunction

function new_UnitEvent takes nothing returns integer
	local integer this_43 = alloc_UnitEvent()
	call construct_UnitEvent(this_43)
	return this_43
endfunction

function Hero_registerChannelCancel takes integer this_43, integer action returns integer
	if Hero_channelCancel[this_43] == 0 then
		set Hero_channelCancel[this_43] = new_UnitEvent()
	endif
	return dispatch_Event_addAction(Hero_channelCancel[this_43], action)
endfunction

function dispatch_Hero_registerChannelCancel takes integer this_43, integer action returns integer
	local integer registerChannelCancel_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.registerChannelCancel")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.registerChannelCancel on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set registerChannelCancel_result = Hero_registerChannelCancel(this_43, action)
	return registerChannelCancel_result
endfunction

function print takes string msg returns nothing
	call DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., PrintingHelper_DEBUG_MSG_DURATION, msg)
endfunction

function trigger_disable takes trigger this_43 returns trigger
	call DisableTrigger(this_43)
	return this_43
endfunction

function trigger_enable takes trigger this_43 returns trigger
	call EnableTrigger(this_43)
	return this_43
endfunction

function angle_degrees takes real this_radians returns real
	return this_radians * Maths_RADTODEG
endfunction

function unit_setFacing_2 takes unit this_43, real a_radians returns unit
	call SetUnitFacing(this_43, angle_degrees(a_radians))
	return this_43
endfunction

function ControlPoint_startCapture takes integer this_43, integer h_2 returns nothing
	local integer clVar
	local real hpos_x
	local real hpos_y
	local real hpos_z
	local integer tempIndex
	local integer tempIndex_2
	local integer temp
	local real temp_2
	local real temp_3
	local unit temp_4
	local integer temp_5
	call print("start")
	call trigger_disable(GetOrders_orderDetect)
	call IssueImmediateOrder(Unit_u[h_2], "stop")
	call trigger_enable(GetOrders_orderDetect)
	set CaptureData_captures[Unit_ct[h_2]] = true
	set temp = h_2
	set clVar = alloc_Closure_8()
	set h[clVar] = h_2
	call dispatch_Hero_registerChannelCancel(temp, clVar)
	set temp_4 = Unit_u[h_2]
	set temp_2 = unit_getPos(Unit_u[h_2])
	set temp_3 = unit_getPos_return_y
	set tempIndex = this_43
	call unit_setFacing_2(temp_4, vec2_angleTo(temp_2, temp_3, vec3_toVec2(ControlPoint_pos[tempIndex], ControlPoint_pos_2[tempIndex], ControlPoint_pos_3[tempIndex]), vec3_toVec2_return_y))
	call Hero_playCaptureAnimation(h_2)
	set temp_5 = h_2
	set tempIndex_2 = this_43
	set hpos_x = dispatch_Hero_getCaptureAttackPoint(temp_5, ControlPoint_pos[tempIndex_2], ControlPoint_pos_2[tempIndex_2], ControlPoint_pos_3[tempIndex_2])
	set hpos_y = dispatch_Hero_getCaptureAttackPoint_return_y
	set hpos_z = dispatch_Hero_getCaptureAttackPoint_return_z
	if CaptureData_l2[Unit_ct[h_2]] == null then
		set CaptureData_l2[Unit_ct[h_2]] = createLightning(Lightning_FORKED_LIGHTNING, hpos_x, hpos_y, hpos_z, hpos_x, hpos_y, hpos_z)
		call SetLightningColor(CaptureData_l2[Unit_ct[h_2]], 1., 0.5, 0.1, 1.)
	endif
	set temp_4 = null
endfunction

function dispatch_ControlPoint_startCapture takes integer this_43, integer h_2 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.startCapture")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.startCapture on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_startCapture(this_43, h_2)
endfunction

function unit_setScale takes unit this_43, real scale returns unit
	call SetUnitScale(this_43, scale, scale, scale)
	return this_43
endfunction

function Fx_setScale takes integer this_43, real value returns integer
	call unit_setScale(Fx_dummy[this_43], value)
	return this_43
endfunction

function dispatch_Fx_setScale takes integer this_43, real value returns integer
	local integer setScale_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.setScale")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.setScale on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set setScale_result = Fx_setScale(this_43, value)
	return setScale_result
endfunction

function alloc_Unit2Event takes nothing returns integer
	local integer this_43
	if Event_firstFree == 0 then
		set Event_maxIndex = Event_maxIndex + 1
		set this_43 = Event_maxIndex
	else
		set this_43 = Event_firstFree
		set Event_firstFree = Event_nextFree[Event_firstFree]
		set Event_nextFree[this_43] = 0
	endif
	set Event_typeId[this_43] = 696
	return this_43
endfunction

function construct_Unit2Event takes integer this_43 returns nothing
	call construct_Event(this_43)
endfunction

function new_Unit2Event takes nothing returns integer
	local integer this_43 = alloc_Unit2Event()
	call construct_Unit2Event(this_43)
	return this_43
endfunction

function Unit_registerDeath takes integer this_43, integer action returns integer
	if Unit_onDeath[this_43] == 0 then
		set Unit_onDeath[this_43] = new_Unit2Event()
	endif
	return dispatch_Event_addAction(Unit_onDeath[this_43], action)
endfunction

function dispatch_Unit_registerDeath takes integer this_43, integer action returns integer
	local integer registerDeath_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.registerDeath")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.registerDeath on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set registerDeath_result = Unit_registerDeath(this_43, action)
	else
		set registerDeath_result = Unit_registerDeath(this_43, action)
	endif
	return registerDeath_result
endfunction

function alloc_CaptureData takes nothing returns integer
	local integer this_43
	if CaptureData_firstFree == 0 then
		set CaptureData_maxIndex = CaptureData_maxIndex + 1
		set this_43 = CaptureData_maxIndex
	else
		set this_43 = CaptureData_firstFree
		set CaptureData_firstFree = CaptureData_nextFree[CaptureData_firstFree]
		set CaptureData_nextFree[this_43] = 0
	endif
	set CaptureData_typeId[this_43] = 630
	return this_43
endfunction

function construct_CaptureData takes integer this_43, integer target returns nothing
	set CaptureData_l1[this_43] = null
	set CaptureData_l2[this_43] = null
	set CaptureData_blitzPos[this_43] = 0.
	set CaptureData_captures[this_43] = false
	set CaptureData_onDeath[this_43] = 0
	set CaptureData_target[this_43] = 0
	set CaptureData_fx[this_43] = 0
	set CaptureData_armor[this_43] = 0
	set CaptureData_attack[this_43] = 0
	set CaptureData_life[this_43] = 0
	set CaptureData_mana[this_43] = 0
	set CaptureData_spellpower[this_43] = 0
	set CaptureData_resistance[this_43] = 0
	set CaptureData_target[this_43] = target
endfunction

function new_CaptureData takes integer target returns integer
	local integer this_43 = alloc_CaptureData()
	call construct_CaptureData(this_43, target)
	return this_43
endfunction

function alloc_Fx takes nothing returns integer
	local integer this_43
	if Fx_firstFree == 0 then
		set Fx_maxIndex = Fx_maxIndex + 1
		set this_43 = Fx_maxIndex
	else
		set this_43 = Fx_firstFree
		set Fx_firstFree = Fx_nextFree[Fx_firstFree]
		set Fx_nextFree[this_43] = 0
	endif
	set Fx_typeId[this_43] = 626
	return this_43
endfunction

function Fx_setFx takes integer this_43, string newpath returns integer
	if Fx_fx[this_43] != null then
		call effect_destr(Fx_fx[this_43])
	endif
	if newpath == "" then
		set Fx_fx[this_43] = null
	else
		set Fx_fx[this_43] = unit_addEffect(Fx_dummy[this_43], newpath, "origin")
	endif
	set Fx_sfxPath[this_43] = newpath
	return this_43
endfunction

function dispatch_Fx_setFx takes integer this_43, string newpath returns integer
	local integer setFx_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.setFx")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.setFx on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set setFx_result = Fx_setFx(this_43, newpath)
	return setFx_result
endfunction

function unit_setFlyHeight takes unit this_43, real height, real rate returns unit
	call SetUnitFlyHeight(this_43, height, rate)
	return this_43
endfunction

function Fx_setZ takes integer this_43, real z returns integer
	call unit_setFlyHeight(Fx_dummy[this_43], z, 0.)
	return this_43
endfunction

function dispatch_Fx_setZ takes integer this_43, real z returns integer
	local integer setZ_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.setZ")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.setZ on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set setZ_result = Fx_setZ(this_43, z)
	return setZ_result
endfunction

function createUnit takes player p, integer unitId, real pos_x, real pos_y, real pos_z, real facing_radians returns unit
	return CreateUnit(p, unitId, pos_x, pos_y, angle_degrees(facing_radians))
endfunction

function int_moduloInt takes integer this_43, integer divisor returns integer
	return this_43 - this_43 / divisor * divisor
endfunction

function unit_pause takes unit this_43 returns unit
	call PauseUnit(this_43, true)
	return this_43
endfunction

function unit_setXYZ takes unit this_43, real pos_x, real pos_y, real pos_z returns unit
	call SetUnitX(this_43, pos_x)
	call SetUnitY(this_43, pos_y)
	call SetUnitFlyHeight(this_43, pos_z, 0.)
	return this_43
endfunction

function newDummy takes real pos_x, real pos_y, real pos_z, real facing_radians returns unit
	local integer i_2 = int_moduloInt(R2I(angle_degrees(facing_radians)), 360) / DummyRecycler_ANG_VAL
	local integer qn = DummyRecycler_queueNext[i_2]
	local unit u
	if qn != 0 and getElapsedGameTime() >= DummyRecycler_timeStamp[qn] then
		set DummyRecycler_queueNext[i_2] = DummyRecycler_queueNext[qn]
		if DummyRecycler_queueNext[i_2] == 0 then
			set DummyRecycler_queueLast[i_2] = i_2
		endif
		set DummyRecycler_stackN[i_2] = DummyRecycler_stackN[i_2] - 1
		set DummyRecycler_queueLast[qn] = DummyRecycler_recycle
		set DummyRecycler_recycle = qn
		set u = DummyRecycler_stack[qn]
		call unit_setFacing(u, angle_degrees(facing_radians))
		call GroupRemoveUnit(DummyRecycler_protect, u)
		call unit_pause(u)
	else
		set u = createUnit(Basics_DUMMY_PLAYER, Basics_DUMMY_UNIT_ID, pos_x, pos_y, pos_z, facing_radians)
		call unit_pause(unit_addAbility(unit_removeAbility(unit_addAbility(u, Basics_HEIGHT_ENABLER), Basics_HEIGHT_ENABLER), Basics_LOCUST_ID))
	endif
	call unit_setXYZ(u, pos_x, pos_y, pos_z)
	set bj_lastCreatedUnit = u
	set u = null
	return bj_lastCreatedUnit
endfunction

function construct_Fx takes integer this_43, real pos_x, real pos_y, real pos_z, real facing_radians, string fxpath returns nothing
	set Fx_dummy[this_43] = null
	set Fx_fx[this_43] = null
	set Fx_zAngle[this_43] = 0.
	set Fx_dummy[this_43] = newDummy(pos_x, pos_y, pos_z, facing_radians)
	call dispatch_Fx_setZ(this_43, pos_z)
	call dispatch_Fx_setFx(this_43, fxpath)
endfunction

function new_Fx takes real pos_x, real pos_y, real pos_z, real facing_radians, string fxpath returns integer
	local integer this_43 = alloc_Fx()
	call construct_Fx(this_43, pos_x, pos_y, pos_z, facing_radians, fxpath)
	return this_43
endfunction

function ControlPoint_groupCheck takes integer this_43 returns nothing
	local group wurst__iterator0
	local unit gu
	local integer obj
	local group tempGroup
	local unit gu_2
	local integer obj_2
	local integer a
	local integer clVar
	local real middle_x
	local real middle_y
	local real middle_z
	local integer tempIndex
	local integer tempIndex_2
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local real tempTupleSelectionResult_3
	local integer tempIndex_3
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real tempTupleSelectionResult_3_2
	local integer tempIndex_4
	local real temp
	local real temp_2
	local group temp_3
	local real temp_4
	local integer temp_5
	local string temp_6
	local real temp_7
	local real temp_8
	local real temp_9
	local integer temp_10
	call dispatch_ControlPoint_selfHeal(this_43)
	call dispatch_ControlPoint_setColor(this_43)
	set wurst__iterator0 = group_iterator(ControlPoint_inRange[this_43])
	loop
		exitwhen  not group_hasNext(wurst__iterator0)
		set gu = group_next(wurst__iterator0)
		set obj = unit_getUserData(gu)
		set temp = unit_getPos(gu)
		set temp_2 = unit_getPos_return_y
		set tempIndex = this_43
		if vec2_distToVec(temp, temp_2, vec3_toVec2(ControlPoint_pos[tempIndex], ControlPoint_pos_2[tempIndex], ControlPoint_pos_3[tempIndex]), vec3_toVec2_return_y) > ControlPoint_range then
			call dispatch_CaptureData_destroyCaptureData(Unit_ct[obj])
			set Unit_ct[obj] = 0
			if IsUnitAlly(gu, ControlPoint_owner[this_43]) then
				if Unit_isHero[obj] then
					set ControlPoint_allyHerosInGroup[this_43] = ControlPoint_allyHerosInGroup[this_43] - 1
				else
					set ControlPoint_allysInGroup[this_43] = ControlPoint_allysInGroup[this_43] - 1
				endif
			elseif Unit_isHero[obj] then
				set ControlPoint_enemyHerosInGroup[this_43] = ControlPoint_enemyHerosInGroup[this_43] - 1
			else
				set ControlPoint_enemysInGroup[this_43] = ControlPoint_enemysInGroup[this_43] - 1
			endif
			call GroupRemoveUnit(ControlPoint_inRange[this_43], gu)
		endif
	endloop
	call group_close(wurst__iterator0)
	set tempGroup = CreateGroup()
	set temp_3 = tempGroup
	set tempIndex_2 = this_43
	set tempTupleSelectionResult_1 = ControlPoint_pos[tempIndex_2]
	set tempTupleSelectionResult_2 = ControlPoint_pos_2[tempIndex_2]
	set tempTupleSelectionResult_3 = ControlPoint_pos_3[tempIndex_2]
	set temp_4 = tempTupleSelectionResult_1
	set tempIndex_3 = this_43
	set tempTupleSelectionResult_1_2 = ControlPoint_pos[tempIndex_3]
	set tempTupleSelectionResult_2_2 = ControlPoint_pos_2[tempIndex_3]
	set tempTupleSelectionResult_3_2 = ControlPoint_pos_3[tempIndex_3]
	call GroupEnumUnitsInRange(temp_3, temp_4, tempTupleSelectionResult_2_2, ControlPoint_range, Condition(ref_function_notDead))
	loop
		exitwhen  not group_hasNext(tempGroup)
		set gu_2 = group_next(tempGroup)
		if  not IsUnitInGroup(gu_2, ControlPoint_inRange[this_43]) then
			set obj_2 = unit_getUserData(gu_2)
			set Unit_ct[obj_2] = new_CaptureData(this_43)
			set temp_5 = obj_2
			set clVar = alloc_Closure()
			set this_3[clVar] = this_43
			set a = dispatch_Unit_registerDeath(temp_5, clVar)
			set CaptureData_onDeath[Unit_ct[obj_2]] = a
			call GroupAddUnit(ControlPoint_inRange[this_43], gu_2)
			if IsUnitAlly(gu_2, ControlPoint_owner[this_43]) then
				call dispatch_ControlPoint_addAllBons(this_43, obj_2)
				if Unit_isHero[obj_2] then
					set ControlPoint_allyHerosInGroup[this_43] = ControlPoint_allyHerosInGroup[this_43] + 1
				else
					set ControlPoint_allysInGroup[this_43] = ControlPoint_allysInGroup[this_43] + 1
				endif
			else
				if Unit_isHero[obj_2] then
					set ControlPoint_enemyHerosInGroup[this_43] = ControlPoint_enemyHerosInGroup[this_43] + 1
					if Hero_wantCapture[obj_2] then
						call dispatch_ControlPoint_startCapture(this_43, obj_2)
					endif
				else
					set ControlPoint_enemysInGroup[this_43] = ControlPoint_enemysInGroup[this_43] + 1
				endif
				set middle_x = dispatch_Unit_getMiddle(obj_2)
				set middle_y = dispatch_Unit_getMiddle_return_y
				set middle_z = dispatch_Unit_getMiddle_return_z
				set temp_10 = Unit_ct[obj_2]
				set temp_6 = Lightning_FORKED_LIGHTNING
				set temp_7 = middle_x
				set temp_8 = middle_y
				set temp_9 = middle_z
				set tempIndex_4 = this_43
				set CaptureData_l1[temp_10] = createLightning(temp_6, temp_7, temp_8, temp_9, ControlPoint_pos[tempIndex_4], ControlPoint_pos_2[tempIndex_4], ControlPoint_pos_3[tempIndex_4])
				set CaptureData_fx[Unit_ct[obj_2]] = new_Fx(middle_x, middle_y, middle_z, real_asAngleRadians(0.), "Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl")
				call dispatch_Fx_setScale(CaptureData_fx[Unit_ct[obj_2]], 3.)
			endif
		endif
	endloop
	call DestroyGroup(tempGroup)
	set wurst__iterator0 = null
	set gu = null
	set tempGroup = null
	set gu_2 = null
	set temp_3 = null
endfunction

function dispatch_ControlPoint_groupCheck takes integer this_43 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.groupCheck")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.groupCheck on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_groupCheck(this_43)
endfunction

function ControlPoint_callGroupCheck takes nothing returns nothing
	call dispatch_ControlPoint_groupCheck(timer_getData(GetExpiredTimer()))
endfunction

function ControlPoint_calcDamage takes integer this_43, integer u returns real
	local real damage = ControlPoint_baseDmg + ControlPoint_dmgPerLvl * Unit_level[u]
	local real damageModifer
	if Unit_isHero[u] then
		set damage = damage + GetUnitState(Unit_u[u], UNIT_STATE_MAX_LIFE) / 100. * ControlPoint_percentualDmg
		set damage = damage + GetHeroLevel(Unit_u[u]) * ControlPoint_dmgPerLvl
	else
		set damage = damage * ControlPoint_creepDmg
	endif
	set damageModifer = (ControlPoint_allyHerosInGroup[this_43] - ControlPoint_enemyHerosInGroup[this_43]) * ControlPoint_heroDmgFactor + (ControlPoint_allysInGroup[this_43] - ControlPoint_enemysInGroup[this_43]) * ControlPoint_unitDmgFactor
	set damage = damage * (1. + damageModifer)
	return damage
endfunction

function dispatch_ControlPoint_calcDamage takes integer this_43, integer u returns real
	local real calcDamage_result
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.calcDamage")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.calcDamage on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set calcDamage_result = ControlPoint_calcDamage(this_43, u)
	return calcDamage_result
endfunction

function vec2_toVec3 takes real this_x, real this_y returns real
	set vec2_toVec3_return_x = this_x
	set vec2_toVec3_return_y = this_y
	set vec2_toVec3_return_z = 0.
	return vec2_toVec3_return_x
endfunction

function newDummy_2 takes real pos_x, real pos_y, real facing_radians returns unit
	return newDummy(vec2_toVec3(pos_x, pos_y), vec2_toVec3_return_y, vec2_toVec3_return_z, facing_radians)
endfunction

function construct_Fx_2 takes integer this_43, real pos_x, real pos_y, real facing_radians, string fxpath returns nothing
	set Fx_dummy[this_43] = null
	set Fx_fx[this_43] = null
	set Fx_zAngle[this_43] = 0.
	set Fx_dummy[this_43] = newDummy_2(pos_x, pos_y, facing_radians)
	call dispatch_Fx_setFx(this_43, fxpath)
endfunction

function new_Fx_2 takes real pos_x, real pos_y, real facing_radians, string fxpath returns integer
	local integer this_43 = alloc_Fx()
	call construct_Fx_2(this_43, pos_x, pos_y, facing_radians, fxpath)
	return this_43
endfunction

function createTimedFx takes string path, real pos_x, real pos_y, real duration returns integer
	local integer fx = new_Fx_2(pos_x, pos_y, 0., path)
	call timer_setData(timer_start(getTimer(), duration, ref_function_destroyTimedFx), fx)
	return fx
endfunction

function ControlPoint_captured takes integer this_43 returns nothing
	local integer tempIndex = this_43
	local unit u
	local integer obj
	call dispatch_Fx_setScale(createTimedFx("war3mapImported\\BlizzardEruption.mdx", vec3_toVec2(ControlPoint_pos[tempIndex], ControlPoint_pos_2[tempIndex], ControlPoint_pos_3[tempIndex]), vec3_toVec2_return_y, 3.), 4.)
	set ControlPoint_hp[this_43] = 500.
	loop
		exitwhen  not group_hasNext(ControlPoint_inRange[this_43])
		set u = group_next(ControlPoint_inRange[this_43])
		set obj = unit_getUserData(u)
		call dispatch_CaptureData_destroyCaptureData(Unit_ct[obj])
		set Unit_ct[obj] = 0
		call SetUnitAnimationByIndex(u, 0)
		if IsUnitAlly(u, ControlPoint_owner[this_43]) then
			if Unit_isHero[obj] then
				set ControlPoint_allyHerosInGroup[this_43] = ControlPoint_allyHerosInGroup[this_43] - 1
			else
				set ControlPoint_allysInGroup[this_43] = ControlPoint_allysInGroup[this_43] - 1
			endif
		elseif Unit_isHero[obj] then
			set ControlPoint_enemyHerosInGroup[this_43] = ControlPoint_enemyHerosInGroup[this_43] - 1
			call Hero_stopCaptureAnimation(obj)
		else
			set ControlPoint_enemysInGroup[this_43] = ControlPoint_enemysInGroup[this_43] - 1
		endif
	endloop
	set ControlPoint_owner[this_43] = Player(0)
	set u = null
endfunction

function dispatch_ControlPoint_captured takes integer this_43 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.captured")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.captured on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_captured(this_43)
endfunction

function ControlPoint_damage takes integer this_43, real amount_39, integer source returns nothing
	if ControlPoint_hp[this_43] - amount_39 <= 0. then
		set ControlPoint_hp[this_43] = 0.
		if Unit_ct[source] != 0 then
		endif
		call dispatch_ControlPoint_captured(this_43)
	else
		set ControlPoint_hp[this_43] = ControlPoint_hp[this_43] - amount_39
	endif
endfunction

function dispatch_ControlPoint_damage takes integer this_43, real amount_39, integer source returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.damage")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.damage on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_damage(this_43, amount_39, source)
endfunction

function getTerrainZ takes real x, real y returns real
	call MoveLocation(Terrain_tempLoc, x, y)
	return GetLocationZ(Terrain_tempLoc)
endfunction

function unit_setPos takes unit this_43, real x, real y returns unit
	call SetUnitPosition(this_43, x, y)
	return this_43
endfunction

function Fx_setPos takes integer this_43, real pos_x, real pos_y, real pos_z returns integer
	call unit_setPos(Fx_dummy[this_43], pos_x, pos_y)
	call dispatch_Fx_setZ(this_43, pos_z - getTerrainZ(pos_x, pos_y))
	return this_43
endfunction

function dispatch_Fx_setPos takes integer this_43, real pos_x, real pos_y, real pos_z returns integer
	local integer setPos_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.setPos")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.setPos on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set setPos_result = Fx_setPos(this_43, pos_x, pos_y, pos_z)
	return setPos_result
endfunction

function Event_onDestroy takes integer this_43 returns nothing
	local integer buffer1 = Event_first[this_43]
	local integer buffer2
	loop
		exitwhen  not (buffer1 != 0)
		set buffer2 = Action_next[buffer1]
		call dispatch_Action_destroyAction(buffer1)
		set buffer1 = buffer2
	endloop
endfunction

function Unit2Event_onDestroy takes integer this_43 returns nothing
	call Event_onDestroy(this_43)
endfunction

function dealloc_Unit2Event takes integer obj returns nothing
	if Event_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Unit2Event")
		call I2S(1 / 0)
	else
		set Event_nextFree[Event_lastFree] = obj
		set Event_lastFree = obj
		if Event_firstFree == 0 then
			set Event_firstFree = obj
			set Event_nextFree[obj] = 0
		endif
		set Event_typeId[obj] = 0
	endif
endfunction

function destroyUnit2Event takes integer this_43 returns nothing
	call Unit2Event_onDestroy(this_43)
	call dealloc_Unit2Event(this_43)
endfunction

function dispatch_Unit2Event_destroyUnit2Event takes integer this_43 returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit2Event.destroyUnit2Event")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit2Event.destroyUnit2Event on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyUnit2Event(this_43)
endfunction

function Shield_onDestroy takes integer this_43 returns nothing
	set ShieldList_shieldSum[Shield_referingList[this_43]] = ShieldList_shieldSum[Shield_referingList[this_43]] - Shield_amount[this_43]
	call timer_release(Shield_t[this_43])
	if Shield_shieldDestroyed[this_43] != 0 then
		call dispatch_Unit2Event_destroyUnit2Event(Shield_shieldDestroyed[this_43])
	endif
	if Shield_prev[this_43] != 0 then
		set Shield_next[Shield_prev[this_43]] = Shield_next[this_43]
	endif
	if Shield_next[this_43] != 0 then
		set Shield_prev[Shield_next[this_43]] = Shield_prev[this_43]
	endif
	if ShieldList_first[Shield_referingList[this_43]] == this_43 then
		set ShieldList_first[Shield_referingList[this_43]] = Shield_next[this_43]
	endif
	if ShieldList_last[Shield_referingList[this_43]] == this_43 then
		set ShieldList_last[Shield_referingList[this_43]] = Shield_prev[this_43]
	endif
endfunction

function dealloc_Shield takes integer obj returns nothing
	if Shield_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Shield")
		call I2S(1 / 0)
	else
		set Shield_nextFree[Shield_lastFree] = obj
		set Shield_lastFree = obj
		if Shield_firstFree == 0 then
			set Shield_firstFree = obj
			set Shield_nextFree[obj] = 0
		endif
		set Shield_typeId[obj] = 0
	endif
endfunction

function destroyShield takes integer this_43 returns nothing
	call Shield_onDestroy(this_43)
	call dealloc_Shield(this_43)
endfunction

function dispatch_Shield_destroyShield takes integer this_43 returns nothing
	if Shield_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Shield.destroyShield")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Shield.destroyShield on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyShield(this_43)
endfunction

function Units_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_Units takes integer obj returns nothing
	if Units_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Units")
		call I2S(1 / 0)
	else
		set Units_nextFree[Units_lastFree] = obj
		set Units_lastFree = obj
		if Units_firstFree == 0 then
			set Units_firstFree = obj
			set Units_nextFree[obj] = 0
		endif
		set Units_typeId[obj] = 0
	endif
endfunction

function destroyUnits takes integer this_43 returns nothing
	call Units_onDestroy(this_43)
	call dealloc_Units(this_43)
endfunction

function dispatch_Units_destroyUnits takes integer this_43 returns nothing
	if Units_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Units.destroyUnits")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Units.destroyUnits on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyUnits(this_43)
endfunction

function alloc_Units takes nothing returns integer
	local integer this_43
	if Units_firstFree == 0 then
		set Units_maxIndex = Units_maxIndex + 1
		set this_43 = Units_maxIndex
	else
		set this_43 = Units_firstFree
		set Units_firstFree = Units_nextFree[Units_firstFree]
		set Units_nextFree[this_43] = 0
	endif
	set Units_typeId[this_43] = 695
	return this_43
endfunction

function construct_Units takes integer this_43 returns nothing
endfunction

function new_Units takes nothing returns integer
	local integer this_43 = alloc_Units()
	call construct_Units(this_43)
	return this_43
endfunction

function Unit2Event_fire takes integer this_43, integer source, integer target returns nothing
	local integer data = new_Units()
	set Units_source[data] = source
	set Units_target[data] = target
	call Event_callActions(this_43, data)
	call dispatch_Units_destroyUnits(data)
endfunction

function dispatch_Unit2Event_fire takes integer this_43, integer source, integer target returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit2Event.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit2Event.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Unit2Event_fire(this_43, source, target)
endfunction

function ShieldList_damage takes integer this_43, real amount_39, integer source returns real
	local real remainingDmg
	local integer pos
	local integer buffer
	if ShieldList_first[this_43] == 0 then
		return amount_39
	endif
	if amount_39 > ShieldList_shieldSum[this_43] then
		set ShieldList_shieldSum[this_43] = 0.
	else
		set ShieldList_shieldSum[this_43] = ShieldList_shieldSum[this_43] - amount_39
	endif
	set remainingDmg = amount_39
	set pos = ShieldList_first[this_43]
	loop
		exitwhen  not (remainingDmg > 0. and pos != 0)
		if Shield_amount[pos] >= remainingDmg then
			set Shield_amount[pos] = Shield_amount[pos] - remainingDmg
			return 0.
		else
			set remainingDmg = remainingDmg - Shield_amount[pos]
			set Shield_amount[pos] = 0.
			if Shield_shieldDestroyed[pos] != 0 then
				call dispatch_Unit2Event_fire(Shield_shieldDestroyed[pos], source, Shield_target[pos])
			endif
			set buffer = pos
			set pos = Shield_next[buffer]
			call dispatch_Shield_destroyShield(buffer)
		endif
	endloop
	return remainingDmg
endfunction

function dispatch_ShieldList_damage takes integer this_43, real amount_39, integer source returns real
	local real damage_result
	if ShieldList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ShieldList.damage")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ShieldList.damage on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set damage_result = ShieldList_damage(this_43, amount_39, source)
	return damage_result
endfunction

function hashtable_loadReal takes hashtable this_43, integer parentKey, integer childKey returns real
	return LoadReal(this_43, parentKey, childKey)
endfunction

function Table_loadReal takes integer this_43, integer parentKey returns real
	return hashtable_loadReal(Table_ht, this_43, parentKey)
endfunction

function dispatch_Table_loadReal takes integer this_43, integer parentKey returns real
	local real loadReal_result
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.loadReal")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.loadReal on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set loadReal_result = Table_loadReal(this_43, parentKey)
	return loadReal_result
endfunction

function hashtable_saveReal takes hashtable this_43, integer parentKey, integer childKey, real value returns hashtable
	call SaveReal(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table_saveReal takes integer this_43, integer parentKey, real value returns nothing
	call hashtable_saveReal(Table_ht, this_43, parentKey, value)
endfunction

function dispatch_Table_saveReal takes integer this_43, integer parentKey, real value returns nothing
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.saveReal")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.saveReal on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table_saveReal(this_43, parentKey, value)
endfunction

function Unit_invuTT takes integer this_43 returns nothing
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
	endif
endfunction

function dispatch_Unit_invuTT takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.invuTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.invuTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_invuTT(this_43)
	else
		call Unit_invuTT(this_43)
	endif
endfunction

function alloc_TextTag takes nothing returns integer
	local integer this_43
	if TextTag_firstFree == 0 then
		set TextTag_maxIndex = TextTag_maxIndex + 1
		set this_43 = TextTag_maxIndex
	else
		set this_43 = TextTag_firstFree
		set TextTag_firstFree = TextTag_nextFree[TextTag_firstFree]
		set TextTag_nextFree[this_43] = 0
	endif
	set TextTag_typeId[this_43] = 615
	return this_43
endfunction

function int_toString takes integer this_43 returns string
	return I2S(this_43)
endfunction

function multiboard_getItem takes multiboard this_43, integer row, integer column returns multiboarditem
	return MultiboardGetItem(this_43, row, column)
endfunction

function multiboarditem_release takes multiboarditem this_43 returns multiboarditem
	call MultiboardReleaseItem(this_43)
	return this_43
endfunction

function multiboarditem_setValue takes multiboarditem this_43, string value returns multiboarditem
	call MultiboardSetItemValue(this_43, value)
	return this_43
endfunction

function construct_TextTag takes integer this_43, real amount_39, integer u, integer R, integer B, integer G, real size, integer tType returns nothing
	local multiboarditem mbi
	local real x
	local real y
	set InstanceBoard_count[ShowInstances_classId] = InstanceBoard_count[ShowInstances_classId] + 1
	set mbi = multiboard_getItem(InstanceBoard_mb, ShowInstances_classId, 1)
	call multiboarditem_release(multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[ShowInstances_classId])))
	set TextTag_tt[this_43] = CreateTextTag()
	set TextTag_tType[this_43] = tType
	set x = unit_getX(Unit_u[u]) - 25.
	set y = unit_getY(Unit_u[u]) - 25.
	if tType == 0 then
		set x = x + 35.
	elseif tType == 1 then
		set x = x - 35.
	elseif tType == 4 or tType == 3 then
		set y = y + 35.
	elseif tType == 5 then
		set y = y - 35.
	endif
	call SetTextTagPos(TextTag_tt[this_43], x, y, Unit_height[u] + 10.)
	call SetTextTagColor(TextTag_tt[this_43], R, B, G, 255)
	call SetTextTagPermanent(TextTag_tt[this_43], false)
	call SetTextTagLifespan(TextTag_tt[this_43], 1.)
	call SetTextTagFadepoint(TextTag_tt[this_43], 0.80)
	call SetTextTagVelocity(TextTag_tt[this_43], 0., 0.08)
	call SetTextTagVisibility(TextTag_tt[this_43], true)
	if tType == 4 then
		call SetTextTagText(TextTag_tt[this_43], "Dodge", size * 0.023 / 10.)
	elseif tType == 3 then
		call SetTextTagText(TextTag_tt[this_43], "Miss", size * 0.023 / 10.)
	elseif tType == 5 then
		call SetTextTagText(TextTag_tt[this_43], "+" + I2S(R2I(amount_39)) + "g", size * 0.023 / 10.)
	else
		call SetTextTagText(TextTag_tt[this_43], R2SW(amount_39, 0, 1), size * 0.023 / 10.)
	endif
	set TextTag_amount[this_43] = amount_39
	set TextTag_u[this_43] = u
	set TextTag_t[this_43] = getTimer()
	call timer_setData(TextTag_t[this_43], this_43)
	if tType == 2 then
		set Unit_dotTT[TextTag_u[this_43]] = this_43
		call timer_start(TextTag_t[this_43], 0.45, ref_function_TextTag_destroyTextTag)
	elseif tType == 0 then
		set Unit_damageTT[TextTag_u[this_43]] = this_43
		call timer_start(TextTag_t[this_43], 1., ref_function_TextTag_destroyTextTag_2)
	else
		set Unit_healTT[TextTag_u[this_43]] = this_43
		call timer_start(TextTag_t[this_43], 1., ref_function_TextTag_destroyTextTag_3)
	endif
	set mbi = null
endfunction

function new_TextTag takes real amount_39, integer u, integer R, integer B, integer G, real size, integer tType returns integer
	local integer this_43 = alloc_TextTag()
	call construct_TextTag(this_43, amount_39, u, R, B, G, size, tType)
	return this_43
endfunction

function Unit_goldTT takes integer this_43, real dmg, player p returns nothing
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) and GetLocalPlayer() == p then
		call new_TextTag(dmg, this_43, 255, 255, 0, 11., 5)
	endif
endfunction

function dispatch_Unit_goldTT takes integer this_43, real dmg, player p returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.goldTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.goldTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_goldTT(this_43, dmg, p)
	else
		call Unit_goldTT(this_43, dmg, p)
	endif
endfunction

function unit_kill takes unit this_43 returns unit
	call KillUnit(this_43)
	return this_43
endfunction

function Unit_kill takes integer this_43, integer source returns nothing
	local integer i_2
	if  not Unit_isDead[this_43] then
		set Unit_isDead[this_43] = true
		call unit_addAbility(Unit_u[this_43], 1684365668)
		call dispatch_Unit2Event_fire(Unit_onDeath[this_43], source, this_43)
		call dispatch_Unit2Event_fire(Unit_causeDeath[this_43], source, this_43)
		set i_2 = 0
		loop
			exitwhen i_2 > 11
			if dispatch_Table_loadReal(Unit_percentDamage[this_43], i_2) != 0. then
				call SetPlayerState(Player(i_2), PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(Player(i_2), PLAYER_STATE_RESOURCE_GOLD) + R2I(dispatch_Table_loadReal(Unit_percentDamage[this_43], i_2) * Unit_bounty[this_43] + 0.5))
				call dispatch_Unit_goldTT(this_43, dispatch_Table_loadReal(Unit_percentDamage[this_43], i_2) * Unit_bounty[this_43] + 0.50, Player(i_2))
			endif
			set i_2 = i_2 + 1
		endloop
		call unit_kill(Unit_u[this_43])
	endif
endfunction

function Bar_disable takes integer this_43 returns nothing
	call texttag_setVisibility(Bar_tt[this_43], false)
	set Bar_check[this_43] = false
endfunction

function dispatch_Bar_disable takes integer this_43 returns nothing
	if Bar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bar.disable")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bar.disable on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Bar_disable(this_43)
endfunction

function Hero_kill takes integer this_43, integer source returns nothing
	call dispatch_Bar_disable(Hero_hb[this_43])
	call Unit_kill(this_43, source)
endfunction

function dispatch_Unit_kill takes integer this_43, integer source returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.kill")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.kill on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_kill(this_43, source)
	else
		call Hero_kill(this_43, source)
	endif
endfunction

function unit_setState takes unit this_43, unitstate state, real value returns unit
	call SetUnitState(this_43, state, value)
	return this_43
endfunction

function unit_setHP takes unit this_43, real hp returns unit
	call unit_setState(this_43, UNIT_STATE_LIFE, hp)
	return this_43
endfunction

function Unit_dealDamage takes integer this_43, real amount_39, integer source returns boolean
	local real tHP
	local real currentAmount
	set Unit_lastDamager[this_43] = source
	if Unit_isHero[source] then
		set Unit_lastHeroDamager[this_43] = source
	endif
	if Unit_vunerable[this_43] then
		set tHP = unit_getHP(Unit_u[this_43])
		set currentAmount = dispatch_ShieldList_damage(Unit_shieldList[this_43], amount_39, source)
		if tHP - 0.405 <= currentAmount then
			call dispatch_Table_saveReal(Unit_percentDamage[this_43], Unit_ownerId[this_43], dispatch_Table_loadReal(Unit_percentDamage[this_43], Unit_ownerId[this_43]) + tHP / unit_getState(Unit_u[this_43], UNIT_STATE_MAX_LIFE))
			call dispatch_Unit_kill(this_43, source)
		else
			call dispatch_Table_saveReal(Unit_percentDamage[this_43], Unit_ownerId[this_43], dispatch_Table_loadReal(Unit_percentDamage[this_43], Unit_ownerId[this_43]) + amount_39 / unit_getState(Unit_u[this_43], UNIT_STATE_MAX_LIFE))
		endif
		call unit_setHP(Unit_u[this_43], tHP - currentAmount)
		if Unit_isHero[this_43] or Unit_isHero[source] then
			return true
		else
			return false
		endif
	else
		if Unit_isHero[this_43] or Unit_isHero[source] then
			call dispatch_Unit_invuTT(this_43)
		endif
		return false
	endif
endfunction

function Hero_dealDamage takes integer this_43, real amount_39, integer source returns boolean
	call dispatch_Bar_update(Hero_hb[this_43])
	return Unit_dealDamage(this_43, amount_39, source)
endfunction

function dispatch_Unit_dealDamage takes integer this_43, real amount_39, integer source returns boolean
	local boolean dealDamage_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.dealDamage")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.dealDamage on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set dealDamage_result = Unit_dealDamage(this_43, amount_39, source)
	else
		set dealDamage_result = Hero_dealDamage(this_43, amount_39, source)
	endif
	return dealDamage_result
endfunction

function Unit_damageSystem takes integer this_43, real amount_39 returns nothing
	call dispatch_Unit_dealDamage(this_43, amount_39, Unit_lastHeroDamager[this_43])
endfunction

function dispatch_Unit_damageSystem takes integer this_43, real amount_39 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.damageSystem")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.damageSystem on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_damageSystem(this_43, amount_39)
	else
		call Unit_damageSystem(this_43, amount_39)
	endif
endfunction

function Unit_getMaxHP takes integer this_43, boolean withBonus returns real
	if withBonus then
		return (Unit_life[this_43] + Unit_bonusLife[this_43]) * (1. + Unit_bonusLifePer[this_43] / 100.)
	else
		return Unit_life[this_43]
	endif
endfunction

function dispatch_Unit_getMaxHP takes integer this_43, boolean withBonus returns real
	local real getMaxHP_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.getMaxHP")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.getMaxHP on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set getMaxHP_result = Unit_getMaxHP(this_43, withBonus)
	else
		set getMaxHP_result = Unit_getMaxHP(this_43, withBonus)
	endif
	return getMaxHP_result
endfunction

function Unit_causeHeal_2 takes integer this_43, real amount_39 returns real
	local real tHP = unit_getHP(Unit_u[this_43])
	local real currentAmount = amount_39
	if dispatch_Unit_getMaxHP(this_43, true) - tHP < amount_39 then
		set currentAmount = dispatch_Unit_getMaxHP(this_43, true) - tHP
	endif
	call unit_setHP(Unit_u[this_43], tHP + amount_39)
	return currentAmount
endfunction

function Hero_causeHeal takes integer this_43, real amount_39 returns real
	call dispatch_Bar_update(Hero_hb[this_43])
	return Unit_causeHeal_2(this_43, amount_39)
endfunction

function dispatch_Unit_causeHeal takes integer this_43, real amount_39 returns real
	local real causeHeal_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.causeHeal")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.causeHeal on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set causeHeal_result = Unit_causeHeal_2(this_43, amount_39)
	else
		set causeHeal_result = Hero_causeHeal(this_43, amount_39)
	endif
	return causeHeal_result
endfunction

function Unit_healSystem takes integer this_43, real takenAmount returns nothing
	call dispatch_Unit_causeHeal(this_43, takenAmount)
endfunction

function dispatch_Unit_healSystem takes integer this_43, real takenAmount returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.healSystem")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.healSystem on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_healSystem(this_43, takenAmount)
	else
		call Unit_healSystem(this_43, takenAmount)
	endif
endfunction

function lightning_setPos takes lightning this_43, real pos1_x, real pos1_y, real pos1_z, real pos2_x, real pos2_y, real pos2_z returns nothing
	call MoveLightningEx(this_43, true, pos1_x, pos1_y, pos1_z, pos2_x, pos2_y, pos2_z)
endfunction

function vec3_op_mult takes real this_x, real this_y, real this_z, real factor returns real
	set vec3_op_mult_return_x = this_x * factor
	set vec3_op_mult_return_y = this_y * factor
	set vec3_op_mult_return_z = this_z * factor
	return vec3_op_mult_return_x
endfunction

function vec3_op_plus takes real this_x, real this_y, real this_z, real v_x, real v_y, real v_z returns real
	set vec3_op_plus_return_x_2 = this_x + v_x
	set vec3_op_plus_return_y_2 = this_y + v_y
	set vec3_op_plus_return_z_2 = this_z + v_z
	return vec3_op_plus_return_x_2
endfunction

function ControlPoint_inRangeActions takes integer this_43 returns nothing
	local group wurst__iterator1 = group_iterator(ControlPoint_inRange[this_43])
	local unit gu
	local integer obj
	local integer ct
	local real middle_x
	local real middle_y
	local real middle_z
	local real pos1_x
	local real pos1_y
	local real pos1_z
	local real mid_x
	local real mid_y
	local real mid_z
	local real pos1_x_2
	local real pos1_y_2
	local real pos1_z_2
	local real mid_x_2
	local real mid_y_2
	local real mid_z_2
	local integer tempIndex
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local real tempTupleSelectionResult_3
	local integer tempIndex_2
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real tempTupleSelectionResult_3_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local integer tempIndex_6
	local integer tempIndex_7
	local lightning temp
	local real temp_2
	local real temp_3
	local real temp_4
	local real temp_5
	local lightning temp_6
	local integer temp_7
	local real temp_8
	local real temp_9
	local real temp_10
	local lightning temp_11
	loop
		exitwhen  not group_hasNext(wurst__iterator1)
		set gu = group_next(wurst__iterator1)
		set obj = unit_getUserData(gu)
		set ct = Unit_ct[obj]
		if IsUnitAlly(gu, ControlPoint_owner[this_43]) then
			call dispatch_Unit_healSystem(obj, 2.5)
		elseif  not CaptureData_captures[ct] then
			if CaptureData_blitzPos[ct] < 0. then
				set middle_x = dispatch_Unit_getMiddle(obj)
				set middle_y = dispatch_Unit_getMiddle_return_y
				set middle_z = dispatch_Unit_getMiddle_return_z
				set temp = CaptureData_l1[ct]
				set tempIndex = this_43
				set tempTupleSelectionResult_1 = ControlPoint_pos[tempIndex]
				set tempTupleSelectionResult_2 = ControlPoint_pos_2[tempIndex]
				set tempTupleSelectionResult_3 = ControlPoint_pos_3[tempIndex]
				set temp_2 = tempTupleSelectionResult_1
				set tempIndex_2 = this_43
				set tempTupleSelectionResult_1_2 = ControlPoint_pos[tempIndex_2]
				set tempTupleSelectionResult_2_2 = ControlPoint_pos_2[tempIndex_2]
				set tempTupleSelectionResult_3_2 = ControlPoint_pos_3[tempIndex_2]
				call lightning_setPos(temp, temp_2, tempTupleSelectionResult_2_2, ControlPoint_height, middle_x, middle_y, middle_z)
				call dispatch_Fx_setPos(CaptureData_fx[ct], middle_x, middle_y, middle_z)
				call dispatch_Unit_damageSystem(obj, dispatch_ControlPoint_calcDamage(this_43, obj))
				if CaptureData_l2[ct] != null then
					call lightning_destr(CaptureData_l2[ct])
					set CaptureData_l2[ct] = null
				endif
			else
				set CaptureData_blitzPos[ct] = CaptureData_blitzPos[ct] - ControlPoint_captureSpeedPoint
				set pos1_x = dispatch_Unit_getMiddle(obj)
				set pos1_y = dispatch_Unit_getMiddle_return_y
				set pos1_z = dispatch_Unit_getMiddle_return_z
				set temp_3 = vec3_op_mult(pos1_x, pos1_y, pos1_z, 1. - CaptureData_blitzPos[ct])
				set temp_4 = vec3_op_mult_return_y
				set temp_5 = vec3_op_mult_return_z
				set tempIndex_3 = this_43
				set mid_x = vec3_op_plus(temp_3, temp_4, temp_5, vec3_op_mult(ControlPoint_pos[tempIndex_3], ControlPoint_pos_2[tempIndex_3], ControlPoint_pos_3[tempIndex_3], CaptureData_blitzPos[ct]), vec3_op_mult_return_y, vec3_op_mult_return_z)
				set mid_y = vec3_op_plus_return_y_2
				set mid_z = vec3_op_plus_return_z_2
				set temp_6 = CaptureData_l1[ct]
				set tempIndex_4 = this_43
				call lightning_setPos(temp_6, ControlPoint_pos[tempIndex_4], ControlPoint_pos_2[tempIndex_4], ControlPoint_pos_3[tempIndex_4], mid_x, mid_y, mid_z)
				call lightning_setPos(CaptureData_l2[ct], pos1_x, pos1_y, pos1_z, mid_x, mid_y, mid_z)
				call dispatch_Fx_setPos(CaptureData_fx[ct], mid_x, mid_y, mid_z)
			endif
		elseif CaptureData_blitzPos[ct] < 1. then
			set CaptureData_blitzPos[ct] = CaptureData_blitzPos[ct] + ControlPoint_captureSpeedHero
			set temp_7 = obj
			set tempIndex_5 = this_43
			set pos1_x_2 = dispatch_Hero_getCaptureAttackPoint(temp_7, ControlPoint_pos[tempIndex_5], ControlPoint_pos_2[tempIndex_5], ControlPoint_pos_3[tempIndex_5])
			set pos1_y_2 = dispatch_Hero_getCaptureAttackPoint_return_y
			set pos1_z_2 = dispatch_Hero_getCaptureAttackPoint_return_z
			set temp_8 = vec3_op_mult(pos1_x_2, pos1_y_2, pos1_z_2, 1. - CaptureData_blitzPos[ct])
			set temp_9 = vec3_op_mult_return_y
			set temp_10 = vec3_op_mult_return_z
			set tempIndex_6 = this_43
			set mid_x_2 = vec3_op_plus(temp_8, temp_9, temp_10, vec3_op_mult(ControlPoint_pos[tempIndex_6], ControlPoint_pos_2[tempIndex_6], ControlPoint_pos_3[tempIndex_6], CaptureData_blitzPos[ct]), vec3_op_mult_return_y, vec3_op_mult_return_z)
			set mid_y_2 = vec3_op_plus_return_y_2
			set mid_z_2 = vec3_op_plus_return_z_2
			set temp_11 = CaptureData_l1[ct]
			set tempIndex_7 = this_43
			call lightning_setPos(temp_11, ControlPoint_pos[tempIndex_7], ControlPoint_pos_2[tempIndex_7], ControlPoint_pos_3[tempIndex_7], mid_x_2, mid_y_2, mid_z_2)
			call lightning_setPos(CaptureData_l2[ct], pos1_x_2, pos1_y_2, pos1_z_2, mid_x_2, mid_y_2, mid_z_2)
			call dispatch_Fx_setPos(CaptureData_fx[ct], mid_x_2, mid_y_2, mid_z_2)
		else
			call dispatch_ControlPoint_damage(this_43, 2., obj)
		endif
	endloop
	call group_close(wurst__iterator1)
	set wurst__iterator1 = null
	set gu = null
	set temp = null
	set temp_6 = null
	set temp_11 = null
endfunction

function dispatch_ControlPoint_inRangeActions takes integer this_43 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.inRangeActions")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.inRangeActions on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_inRangeActions(this_43)
endfunction

function ControlPoint_callInRangeActions takes nothing returns nothing
	call dispatch_ControlPoint_inRangeActions(timer_getData(GetExpiredTimer()))
endfunction

function unit_setVertexColor_2 takes unit this_43, integer r, integer g, integer b, integer a returns unit
	call SetUnitVertexColor(this_43, r, g, b, a)
	return this_43
endfunction

function ControlPoint_hideDummy takes nothing returns nothing
	call unit_setVertexColor_2(ControlPoint_clickDummy[timer_getData(GetExpiredTimer())], 255, 255, 255, 0)
endfunction

function CustomBar_copyForce takes nothing returns nothing
	call ForceAddPlayer(CustomBar_tempForce, GetEnumPlayer())
endfunction

function CustomBar_unlock takes integer this_43 returns nothing
	local integer i_2 = 0
	if  not CustomBar_locked[this_43] then
		return
	endif
	set CustomBar_count = CustomBar_count - 1
	if CustomBar_count == 0 then
		call PauseTimer(CustomBar_animationTimer)
	endif
	set CustomBar_bars[CustomBar_lockindex[this_43]] = CustomBar_bars[CustomBar_count]
	set CustomBar_lockindex[CustomBar_bars[CustomBar_count]] = CustomBar_lockindex[this_43]
	set CustomBar_locked[this_43] = false
endfunction

function dispatch_CustomBar_unlock takes integer this_43 returns nothing
	if CustomBar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CustomBar.unlock")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CustomBar.unlock on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call CustomBar_unlock(this_43)
endfunction

function CustomBar_onDestroy takes integer this_43 returns nothing
	if CustomBar_t[this_43] != null then
		call DestroyTextTag(CustomBar_t[this_43])
	endif
	if CustomBar_locked[this_43] then
		call dispatch_CustomBar_unlock(this_43)
	endif
endfunction

function dealloc_CustomBar takes integer obj returns nothing
	if CustomBar_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type CustomBar")
		call I2S(1 / 0)
	else
		set CustomBar_nextFree[CustomBar_lastFree] = obj
		set CustomBar_lastFree = obj
		if CustomBar_firstFree == 0 then
			set CustomBar_firstFree = obj
			set CustomBar_nextFree[obj] = 0
		endif
		set CustomBar_typeId[obj] = 0
	endif
endfunction

function destroyCustomBar takes integer this_43 returns nothing
	call CustomBar_onDestroy(this_43)
	call dealloc_CustomBar(this_43)
endfunction

function dispatch_CustomBar_destroyCustomBar takes integer this_43 returns nothing
	if CustomBar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling CustomBar.destroyCustomBar")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called CustomBar.destroyCustomBar on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyCustomBar(this_43)
endfunction

function CustomBar_fadeOutCallback takes nothing returns nothing
	local integer bar = timer_getData(GetExpiredTimer())
	set CustomBar_t[bar] = null
	call dispatch_CustomBar_destroyCustomBar(bar)
	call timer_release(GetExpiredTimer())
endfunction

function CustomBar_lockCallback takes nothing returns nothing
	local integer i_2 = CustomBar_count - 1
	local integer s
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local real tempTupleSelectionResult_3
	local integer tempIndex_4
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real tempTupleSelectionResult_3_2
	local integer tempIndex_5
	local real tempTupleSelectionResult_1_3
	local real tempTupleSelectionResult_2_3
	local real tempTupleSelectionResult_3_3
	local texttag temp
	local real temp_2
	local real temp_3
	loop
		exitwhen i_2 < 0
		set s = CustomBar_bars[i_2]
		set tempIndex = s
		set CustomBar_position[tempIndex] = GetUnitX(CustomBar_u[s])
		set tempIndex_2 = s
		set CustomBar_position_2[tempIndex_2] = GetUnitY(CustomBar_u[s])
		set temp = CustomBar_t[s]
		set tempIndex_3 = s
		set tempTupleSelectionResult_1 = CustomBar_position[tempIndex_3]
		set tempTupleSelectionResult_2 = CustomBar_position_2[tempIndex_3]
		set tempTupleSelectionResult_3 = CustomBar_position_3[tempIndex_3]
		set temp_2 = tempTupleSelectionResult_1 + CustomBar_xOffset[s]
		set tempIndex_4 = s
		set tempTupleSelectionResult_1_2 = CustomBar_position[tempIndex_4]
		set tempTupleSelectionResult_2_2 = CustomBar_position_2[tempIndex_4]
		set tempTupleSelectionResult_3_2 = CustomBar_position_3[tempIndex_4]
		set temp_3 = tempTupleSelectionResult_2_2 + CustomBar_yOffset[s]
		set tempIndex_5 = s
		set tempTupleSelectionResult_1_3 = CustomBar_position[tempIndex_5]
		set tempTupleSelectionResult_2_3 = CustomBar_position_2[tempIndex_5]
		set tempTupleSelectionResult_3_3 = CustomBar_position_3[tempIndex_5]
		call SetTextTagPos(temp, temp_2, temp_3, tempTupleSelectionResult_3_3)
		set i_2 = i_2 - 1
	endloop
	set temp = null
endfunction

function LinkedListModule_getFirst takes nothing returns integer
	return LinkedListModule_first
endfunction

function LinkedListModule_getNext takes integer this_43 returns integer
	return LinkedListModule_next[this_43]
endfunction

function dispatch_Dot_getNext takes integer this_43 returns integer
	local integer getNext_result
	if Dot_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Dot.getNext")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Dot.getNext on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getNext_result = LinkedListModule_getNext(this_43)
	return getNext_result
endfunction

function TextTag_onDestroy takes integer this_43 returns nothing
	local multiboarditem mbi
	call timer_release(TextTag_t[this_43])
	call DestroyTextTag(TextTag_tt[this_43])
	if TextTag_tType[this_43] == 0 then
		set Unit_damageTT[TextTag_u[this_43]] = 0
	elseif TextTag_tType[this_43] == 1 then
		set Unit_healTT[TextTag_u[this_43]] = 0
	elseif TextTag_tType[this_43] == 2 then
		set Unit_dotTT[TextTag_u[this_43]] = 0
	endif
	set InstanceBoard_count[ShowInstances_classId] = InstanceBoard_count[ShowInstances_classId] - 1
	set mbi = multiboard_getItem(InstanceBoard_mb, ShowInstances_classId, 1)
	call multiboarditem_release(multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[ShowInstances_classId])))
	set mbi = null
endfunction

function dealloc_TextTag takes integer obj returns nothing
	if TextTag_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type TextTag")
		call I2S(1 / 0)
	else
		set TextTag_nextFree[TextTag_lastFree] = obj
		set TextTag_lastFree = obj
		if TextTag_firstFree == 0 then
			set TextTag_firstFree = obj
			set TextTag_nextFree[obj] = 0
		endif
		set TextTag_typeId[obj] = 0
	endif
endfunction

function destroyTextTag takes integer this_43 returns nothing
	call TextTag_onDestroy(this_43)
	call dealloc_TextTag(this_43)
endfunction

function dispatch_TextTag_destroyTextTag takes integer this_43 returns nothing
	if TextTag_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TextTag.destroyTextTag")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TextTag.destroyTextTag on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyTextTag(this_43)
endfunction

function Unit_dotTT_2 takes integer this_43, real dmg returns nothing
	local real tempAmount
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		if Unit_dotTT[this_43] == 0 then
			call new_TextTag(dmg, this_43, 255, 0, 255, 7., 2)
		else
			set tempAmount = TextTag_amount[Unit_dotTT[this_43]]
			call dispatch_TextTag_destroyTextTag(Unit_dotTT[this_43])
			call new_TextTag(dmg + tempAmount, this_43, 255, 0, 255, 7., 2)
		endif
	endif
endfunction

function dispatch_Unit_dotTT takes integer this_43, real dmg returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.dotTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.dotTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_dotTT_2(this_43, dmg)
	else
		call Unit_dotTT_2(this_43, dmg)
	endif
endfunction

function Unit_damageDot takes integer this_43, integer source, real amount_39 returns nothing
	if dispatch_Unit_dealDamage(this_43, amount_39, source) then
		call dispatch_Unit_dotTT(this_43, amount_39)
	endif
endfunction

function dispatch_Unit_damageDot takes integer this_43, integer source, real amount_39 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.damageDot")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.damageDot on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_damageDot(this_43, source, amount_39)
	else
		call Unit_damageDot(this_43, source, amount_39)
	endif
endfunction

function Dot_loopList takes nothing returns nothing
	local integer d = LinkedListModule_getFirst()
	local integer buffer
	loop
		exitwhen  not (d != 0)
		set buffer = d
		set d = dispatch_Dot_getNext(d)
		call dispatch_Unit_damageDot(Dot_u[buffer], Dot_source[buffer], Dot_damage[buffer])
	endloop
endfunction

function Dot_timerDestroyDot takes nothing returns nothing
	call dispatch_Dot_destroyDot(timer_getData(GetExpiredTimer()))
endfunction

function ForceIterator_callback takes nothing returns nothing
	set ForceIterator_players[ForceIterator_tempIndex] = GetEnumPlayer()
	set ForceIterator_tempIndex = ForceIterator_tempIndex + 1
endfunction

function cd takes nothing returns nothing
	call unit_addAbility(Unit_u[UnitClass_last], Cooldown_cdIcon[100])
	set Cooldown_lastAbi = 1127297072
	call timer_startPeriodic(getTimer(), 0.1, ref_function_cdt)
endfunction

function ControlPoint_conquerOrderGet takes integer this_43, integer h_2 returns nothing
	local integer obj
	if  not IsUnitAlly(Unit_u[h_2], ControlPoint_owner[this_43]) then
		set obj = Unit_ct[h_2]
		if obj != 0 and CaptureData_target[obj] == this_43 then
			if  not CaptureData_captures[obj] then
				call dispatch_ControlPoint_startCapture(this_43, h_2)
			else
				call trigger_disable(GetOrders_orderDetect)
				call IssueImmediateOrder(Unit_u[h_2], "stop")
				call trigger_enable(GetOrders_orderDetect)
			endif
		else
			call trigger_disable(GetOrders_orderDetect)
			call IssuePointOrder(Unit_u[h_2], "move", unit_getX(ControlPoint_visualDummy[this_43]), unit_getY(ControlPoint_visualDummy[this_43]))
			call trigger_enable(GetOrders_orderDetect)
			set Hero_wantCapture[h_2] = true
		endif
	endif
endfunction

function dispatch_ControlPoint_conquerOrderGet takes integer this_43, integer h_2 returns nothing
	if ControlPoint_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ControlPoint.conquerOrderGet")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ControlPoint.conquerOrderGet on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ControlPoint_conquerOrderGet(this_43, h_2)
endfunction

function HandleMap_put takes integer this_43, handle h_2, integer data returns nothing
	call hashtable_saveInt(HandleMap_ht, this_43, GetHandleId(h_2), data)
endfunction

function dispatch_HandleMap_put takes integer this_43, handle h_2, integer data returns nothing
	if HandleMap_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HandleMap.put")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HandleMap.put on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call HandleMap_put(this_43, h_2, data)
endfunction

function Hero_addAbilityCastProtection takes integer this_43, integer abiId returns nothing
	local timer t
	call SetPlayerAbilityAvailable(Unit_owner[this_43], abiId, false)
	set t = getTimer()
	call timer_setData(t, this_43)
	call dispatch_HandleMap_put(Hero_enableAbility[this_43], t, abiId)
	call timer_start(t, 0.0, ref_function_Hero_enableAbilityTimed)
	set t = null
endfunction

function dispatch_Hero_addAbilityCastProtection takes integer this_43, integer abiId returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.addAbilityCastProtection")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.addAbilityCastProtection on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_addAbilityCastProtection(this_43, abiId)
endfunction

function Hero_channelCancel_2 takes integer this_43 returns nothing
	set Hero_wantCapture[this_43] = false
	call dispatch_UnitEvent_fire(Hero_channelCancel[this_43], this_43)
endfunction

function dispatch_Hero_channelCancel takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.channelCancel")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.channelCancel on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_channelCancel_2(this_43)
endfunction

function Queue_dequeue takes integer this_43 returns integer
	local integer tmp = Queue_front[this_43]
	set Queue_front[this_43] = SEntry_next[Queue_front[this_43]]
	set Queue_size[this_43] = Queue_size[this_43] - 1
	return SEntry_elem[tmp]
endfunction

function dispatch_Queue_dequeue takes integer this_43 returns integer
	local integer dequeue_result
	if Queue_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Queue.dequeue")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Queue.dequeue on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set dequeue_result = Queue_dequeue(this_43)
	return dequeue_result
endfunction

function Hero_cleanCastQueue takes integer this_43 returns nothing
	loop
		exitwhen  not (dispatch_Queue_dequeue(Hero_castQueue[this_43]) != 0)
	endloop
endfunction

function dispatch_Hero_cleanCastQueue takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.cleanCastQueue")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.cleanCastQueue on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_cleanCastQueue(this_43)
endfunction

function Order_onDestroy takes integer this_43 returns nothing
	local multiboarditem mbi
	set InstanceBoard_count[ShowInstances_classId_2] = InstanceBoard_count[ShowInstances_classId_2] - 1
	set mbi = multiboard_getItem(InstanceBoard_mb, ShowInstances_classId_2, 1)
	call multiboarditem_release(multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[ShowInstances_classId_2])))
	set mbi = null
endfunction

function dealloc_Order takes integer obj returns nothing
	if Order_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Order")
		call I2S(1 / 0)
	else
		set Order_nextFree[Order_lastFree] = obj
		set Order_lastFree = obj
		if Order_firstFree == 0 then
			set Order_firstFree = obj
			set Order_nextFree[obj] = 0
		endif
		set Order_typeId[obj] = 0
	endif
endfunction

function destroyOrder takes integer this_43 returns nothing
	call Order_onDestroy(this_43)
	call dealloc_Order(this_43)
endfunction

function dispatch_Order_destroyOrder takes integer this_43 returns nothing
	if Order_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Order.destroyOrder")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Order.destroyOrder on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyOrder(this_43)
endfunction

function Hero_setMainOrder takes integer this_43, integer o returns nothing
	if Hero_mainOrder[this_43] != 0 then
		call dispatch_Order_destroyOrder(Hero_mainOrder[this_43])
	endif
	set Hero_mainOrder[this_43] = o
endfunction

function dispatch_Hero_setMainOrder takes integer this_43, integer o returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.setMainOrder")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.setMainOrder on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_setMainOrder(this_43, o)
endfunction

function AttackOrder_issueToUnit takes integer this_43, unit u returns boolean
	call trigger_disable(GetOrders_orderDetect)
	call IssueTargetOrderById(u, AttackOrder_atkOrderId, AttackOrder_target[this_43])
	call trigger_enable(GetOrders_orderDetect)
	return GetUnitAbilityLevel(u, 1684365668) == 1
endfunction

function CaptureOrder_issueToUnit takes integer this_43, unit u returns boolean
	local integer h_2 = unit_getUserData(u)
	call trigger_disable(GetOrders_orderDetect)
	call dispatch_ControlPoint_conquerOrderGet(CaptureOrder_cp[this_43], h_2)
	call trigger_enable(GetOrders_orderDetect)
	return Unit_ct[h_2] != 0 and CaptureData_captures[Unit_ct[h_2]]
endfunction

function MoveOrder_issueToUnit takes integer this_43, unit u returns boolean
	local real currentPos_x
	local real currentPos_y
	local boolean b
	local integer tempIndex
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_2
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local integer tempIndex_3
	local integer tempIndex_4
	local unit temp
	local integer temp_2
	local real temp_3
	local real temp_4
	call trigger_disable(GetOrders_orderDetect)
	set temp = u
	set temp_2 = MoveOrder_moveOrderId
	set tempIndex = this_43
	set tempTupleSelectionResult_1 = MoveOrder_pos[tempIndex]
	set tempTupleSelectionResult_2 = MoveOrder_pos_2[tempIndex]
	set temp_3 = tempTupleSelectionResult_1
	set tempIndex_2 = this_43
	set tempTupleSelectionResult_1_2 = MoveOrder_pos[tempIndex_2]
	set tempTupleSelectionResult_2_2 = MoveOrder_pos_2[tempIndex_2]
	call IssuePointOrderById(temp, temp_2, temp_3, tempTupleSelectionResult_2_2)
	call trigger_enable(GetOrders_orderDetect)
	set currentPos_x = unit_getPos(u)
	set currentPos_y = unit_getPos_return_y
	set temp_4 = currentPos_x
	set tempIndex_3 = this_43
	set b = temp_4 == MoveOrder_lastPos[tempIndex_3] and currentPos_y == MoveOrder_lastPos_2[tempIndex_3]
	set tempIndex_4 = this_43
	set MoveOrder_lastPos[tempIndex_4] = currentPos_x
	set MoveOrder_lastPos_2[tempIndex_4] = currentPos_y
	set temp = null
	return b
endfunction

function dispatch_Order_issueToUnit takes integer this_43, unit u returns boolean
	local boolean issueToUnit_result
	if Order_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Order.issueToUnit")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Order.issueToUnit on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Order_typeId[this_43] <= 633 then
		if Order_typeId[this_43] <= 632 then
			set issueToUnit_result = MoveOrder_issueToUnit(this_43, u)
		else
			set issueToUnit_result = AttackOrder_issueToUnit(this_43, u)
		endif
	else
		set issueToUnit_result = CaptureOrder_issueToUnit(this_43, u)
	endif
	return issueToUnit_result
endfunction

function alloc_SEntry takes nothing returns integer
	local integer this_43
	if SEntry_firstFree == 0 then
		set SEntry_maxIndex = SEntry_maxIndex + 1
		set this_43 = SEntry_maxIndex
	else
		set this_43 = SEntry_firstFree
		set SEntry_firstFree = SEntry_nextFree[SEntry_firstFree]
		set SEntry_nextFree[this_43] = 0
	endif
	set SEntry_typeId[this_43] = 621
	return this_43
endfunction

function construct_SEntry takes integer this_43, integer elem, integer next returns nothing
	set SEntry_elem[this_43] = elem
	set SEntry_next[this_43] = next
endfunction

function new_SEntry takes integer elem, integer next returns integer
	local integer this_43 = alloc_SEntry()
	call construct_SEntry(this_43, elem, next)
	return this_43
endfunction

function Queue_enqueue takes integer this_43, integer elem returns nothing
	if Queue_front[this_43] == Queue_dummy[this_43] then
		set Queue_front[this_43] = new_SEntry(elem, Queue_dummy[this_43])
		set Queue_back[this_43] = Queue_front[this_43]
	else
		set SEntry_next[Queue_back[this_43]] = new_SEntry(elem, Queue_dummy[this_43])
		set Queue_back[this_43] = SEntry_next[Queue_back[this_43]]
	endif
	set Queue_size[this_43] = Queue_size[this_43] + 1
endfunction

function dispatch_Queue_enqueue takes integer this_43, integer elem returns nothing
	if Queue_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Queue.enqueue")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Queue.enqueue on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Queue_enqueue(this_43, elem)
endfunction

function alloc_Spellcast takes nothing returns integer
	local integer this_43
	if Spellcast_firstFree == 0 then
		set Spellcast_maxIndex = Spellcast_maxIndex + 1
		set this_43 = Spellcast_maxIndex
	else
		set this_43 = Spellcast_firstFree
		set Spellcast_firstFree = Spellcast_nextFree[Spellcast_firstFree]
		set Spellcast_nextFree[this_43] = 0
	endif
	set Spellcast_typeId[this_43] = 637
	return this_43
endfunction

function construct_Spellcast takes integer this_43 returns nothing
endfunction

function new_Spellcast takes nothing returns integer
	local integer this_43 = alloc_Spellcast()
	call construct_Spellcast(this_43)
	return this_43
endfunction

function Spell_getInstantSpellCast takes integer this_43 returns integer
	local integer sc = new_Spellcast()
	set Spellcast_spell[sc] = this_43
	return sc
endfunction

function dispatch_Spell_getInstantSpellCast takes integer this_43 returns integer
	local integer getInstantSpellCast_result
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.getInstantSpellCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.getInstantSpellCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			set getInstantSpellCast_result = Spell_getInstantSpellCast(this_43)
		else
			set getInstantSpellCast_result = Spell_getInstantSpellCast(this_43)
		endif
	else
		set getInstantSpellCast_result = Spell_getInstantSpellCast(this_43)
	endif
	return getInstantSpellCast_result
endfunction

function Spell_getPointSpellCast takes integer this_43, real pos_x, real pos_y returns integer
	local integer sc = new_Spellcast()
	local integer tempIndex
	set Spellcast_spell[sc] = this_43
	set tempIndex = sc
	set Spellcast_pos[tempIndex] = pos_x
	set Spellcast_pos_2[tempIndex] = pos_y
	return sc
endfunction

function dispatch_Spell_getPointSpellCast takes integer this_43, real pos_x, real pos_y returns integer
	local integer getPointSpellCast_result
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.getPointSpellCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.getPointSpellCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			set getPointSpellCast_result = Spell_getPointSpellCast(this_43, pos_x, pos_y)
		else
			set getPointSpellCast_result = Spell_getPointSpellCast(this_43, pos_x, pos_y)
		endif
	else
		set getPointSpellCast_result = Spell_getPointSpellCast(this_43, pos_x, pos_y)
	endif
	return getPointSpellCast_result
endfunction

function Spell_getUnitSpellCast takes integer this_43, unit target returns integer
	local integer sc = new_Spellcast()
	set Spellcast_spell[sc] = this_43
	set Spellcast_target[sc] = target
	return sc
endfunction

function dispatch_Spell_getUnitSpellCast takes integer this_43, unit target returns integer
	local integer getUnitSpellCast_result
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.getUnitSpellCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.getUnitSpellCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			set getUnitSpellCast_result = Spell_getUnitSpellCast(this_43, target)
		else
			set getUnitSpellCast_result = Spell_getUnitSpellCast(this_43, target)
		endif
	else
		set getUnitSpellCast_result = Spell_getUnitSpellCast(this_43, target)
	endif
	return getUnitSpellCast_result
endfunction

function alloc_AttackOrder takes nothing returns integer
	local integer this_43
	if Order_firstFree == 0 then
		set Order_maxIndex = Order_maxIndex + 1
		set this_43 = Order_maxIndex
	else
		set this_43 = Order_firstFree
		set Order_firstFree = Order_nextFree[Order_firstFree]
		set Order_nextFree[this_43] = 0
	endif
	set Order_typeId[this_43] = 633
	return this_43
endfunction

function construct_Order takes integer this_43 returns nothing
	local multiboarditem mbi
	set InstanceBoard_count[ShowInstances_classId_2] = InstanceBoard_count[ShowInstances_classId_2] + 1
	set mbi = multiboard_getItem(InstanceBoard_mb, ShowInstances_classId_2, 1)
	call multiboarditem_release(multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[ShowInstances_classId_2])))
	set mbi = null
endfunction

function construct_AttackOrder takes integer this_43, unit target returns nothing
	call construct_Order(this_43)
	set Order_orderId[this_43] = Order_orderId[this_43]
	set AttackOrder_target[this_43] = target
endfunction

function new_AttackOrder takes unit target returns integer
	local integer this_43 = alloc_AttackOrder()
	call construct_AttackOrder(this_43, target)
	return this_43
endfunction

function alloc_CaptureOrder takes nothing returns integer
	local integer this_43
	if Order_firstFree == 0 then
		set Order_maxIndex = Order_maxIndex + 1
		set this_43 = Order_maxIndex
	else
		set this_43 = Order_firstFree
		set Order_firstFree = Order_nextFree[Order_firstFree]
		set Order_nextFree[this_43] = 0
	endif
	set Order_typeId[this_43] = 634
	return this_43
endfunction

function construct_CaptureOrder takes integer this_43, integer cp returns nothing
	call construct_Order(this_43)
	set CaptureOrder_cp[this_43] = cp
endfunction

function new_CaptureOrder takes integer cp returns integer
	local integer this_43 = alloc_CaptureOrder()
	call construct_CaptureOrder(this_43, cp)
	return this_43
endfunction

function alloc_MoveOrder takes nothing returns integer
	local integer this_43
	if Order_firstFree == 0 then
		set Order_maxIndex = Order_maxIndex + 1
		set this_43 = Order_maxIndex
	else
		set this_43 = Order_firstFree
		set Order_firstFree = Order_nextFree[Order_firstFree]
		set Order_nextFree[this_43] = 0
	endif
	set Order_typeId[this_43] = 632
	return this_43
endfunction

function construct_MoveOrder takes integer this_43, real pos_x, real pos_y returns nothing
	local integer tempIndex
	local integer tempIndex_2
	call construct_Order(this_43)
	set tempIndex = this_43
	set MoveOrder_lastPos[tempIndex] = 0.
	set MoveOrder_lastPos_2[tempIndex] = 0.
	set Order_orderId[this_43] = Order_orderId[this_43]
	set tempIndex_2 = this_43
	set MoveOrder_pos[tempIndex_2] = pos_x
	set MoveOrder_pos_2[tempIndex_2] = pos_y
endfunction

function new_MoveOrder takes real pos_x, real pos_y returns integer
	local integer this_43 = alloc_MoveOrder()
	call construct_MoveOrder(this_43, pos_x, pos_y)
	return this_43
endfunction

function Hero_onOrder takes integer this_43, real pos_x, real pos_y, unit target, integer orderId returns nothing
	local integer temp
	local integer temp_2
	local integer casted
	local integer temp_3
	set Hero_lastOrdered[this_43] = 0
	set temp = orderId
	if temp == OrderHandling_exitDetectId then
		call SetPlayerAbilityAvailable(Unit_owner[this_43], 1702390132, false)
		call cd()
		return
	elseif temp == OrderHandling_scoreboardId then
		call dispatch_Hero_addAbilityCastProtection(this_43, 1935896434)
		return
	endif
	if Hero_acceptOrders[this_43] then
		set temp_2 = orderId
		if temp_2 == OrderHandling_smartId then
			if target == null then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(pos_x, pos_y))
				call dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43])
			elseif IsUnitAlly(target, Unit_owner[this_43]) then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(unit_getPos(target), unit_getPos_return_y))
				call dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43])
			else
				call dispatch_Hero_setMainOrder(this_43, new_AttackOrder(target))
				call dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43])
			endif
		elseif temp_2 == OrderHandling_attackId then
			if IsUnitAlly(target, Unit_owner[this_43]) then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(unit_getPos(target), unit_getPos_return_y))
				call dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43])
			else
				call dispatch_Hero_setMainOrder(this_43, new_AttackOrder(target))
				call dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43])
			endif
		elseif temp_2 == OrderHandling_stopId then
			call dispatch_Hero_setMainOrder(this_43, 0)
			call IssueImmediateOrderById(Unit_u[this_43], 851972)
		endif
		if Hero_channelCancel[this_43] != 0 and GetUnitTypeId(target) != 1668314229 then
			call dispatch_Hero_channelCancel(this_43)
		elseif GetUnitTypeId(target) == 1668314229 then
			call dispatch_ControlPoint_conquerOrderGet(unit_getUserData(target), this_43)
		endif
	else
		set casted = 0
		set temp_3 = orderId
		if temp_3 == OrderHandling_smartId then
			call dispatch_Hero_cleanCastQueue(this_43)
			if target == null then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(pos_x, pos_y))
			elseif IsUnitAlly(target, Unit_owner[this_43]) then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(unit_getPos(target), unit_getPos_return_y))
			else
				call dispatch_Hero_setMainOrder(this_43, new_AttackOrder(target))
			endif
		elseif temp_3 == OrderHandling_attackId then
			call dispatch_Hero_cleanCastQueue(this_43)
			call dispatch_Hero_addAbilityCastProtection(this_43, OrderHandling_attackSpell)
			if IsUnitAlly(target, Unit_owner[this_43]) then
				call dispatch_Hero_setMainOrder(this_43, new_MoveOrder(unit_getPos(target), unit_getPos_return_y))
			else
				call dispatch_Hero_setMainOrder(this_43, new_AttackOrder(target))
			endif
		elseif temp_3 == OrderHandling_stopId then
			call dispatch_Hero_cleanCastQueue(this_43)
			call dispatch_Hero_addAbilityCastProtection(this_43, OrderHandling_stopSpell)
			call dispatch_Hero_setMainOrder(this_43, 0)
		elseif temp_3 == Spell_qSpellId then
			set casted = Hero_spellQ[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellQ[this_43]])
		elseif temp_3 == Spell_wSpellId then
			set casted = Hero_spellW[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellW[this_43]])
		elseif temp_3 == Spell_eSpellId then
			set casted = Hero_spellE[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellE[this_43]])
		elseif temp_3 == Spell_rSpellId then
			set casted = Hero_spellR[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellR[this_43]])
		elseif temp_3 == Spell_dSpellId then
			set casted = Hero_spellD[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellD[this_43]])
		elseif temp_3 == Spell_fSpellId then
			set casted = Hero_spellF[this_43]
			call dispatch_Hero_addAbilityCastProtection(this_43, Spell_spell[Hero_spellF[this_43]])
		endif
		if casted != 0 then
			if target == null then
				if pos_x == 0. and pos_y == 0. then
					call dispatch_Queue_enqueue(Hero_castQueue[this_43], dispatch_Spell_getInstantSpellCast(casted))
				else
					call dispatch_Queue_enqueue(Hero_castQueue[this_43], dispatch_Spell_getPointSpellCast(casted, pos_x, pos_y))
				endif
			else
				call dispatch_Queue_enqueue(Hero_castQueue[this_43], dispatch_Spell_getUnitSpellCast(casted, target))
			endif
		endif
		if Hero_channelCancel[this_43] != 0 and GetUnitTypeId(target) != 1668314229 then
			call dispatch_Hero_channelCancel(this_43)
		elseif GetUnitTypeId(target) == 1668314229 then
			call dispatch_Hero_setMainOrder(this_43, new_CaptureOrder(unit_getUserData(target)))
		endif
	endif
endfunction

function dispatch_Hero_onOrder takes integer this_43, real pos_x, real pos_y, unit target, integer orderId returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.onOrder")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.onOrder on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_onOrder(this_43, pos_x, pos_y, target, orderId)
endfunction

function GetOrders_callOnOrder takes nothing returns nothing
	call trigger_disable(GetOrders_orderDetect)
	call dispatch_Hero_onOrder(unit_getUserData(GetTriggerUnit()), GetOrderPointX(), GetOrderPointY(), GetOrderTargetUnit(), GetIssuedOrderId())
	call trigger_enable(GetOrders_orderDetect)
endfunction

function Queue_getSize takes integer this_43 returns integer
	return Queue_size[this_43]
endfunction

function dispatch_Queue_getSize takes integer this_43 returns integer
	local integer getSize_result
	if Queue_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Queue.getSize")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Queue.getSize on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getSize_result = Queue_getSize(this_43)
	return getSize_result
endfunction

function Spellcast_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_Spellcast takes integer obj returns nothing
	if Spellcast_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Spellcast")
		call I2S(1 / 0)
	else
		set Spellcast_nextFree[Spellcast_lastFree] = obj
		set Spellcast_lastFree = obj
		if Spellcast_firstFree == 0 then
			set Spellcast_firstFree = obj
			set Spellcast_nextFree[obj] = 0
		endif
		set Spellcast_typeId[obj] = 0
	endif
endfunction

function destroySpellcast takes integer this_43 returns nothing
	call Spellcast_onDestroy(this_43)
	call dealloc_Spellcast(this_43)
endfunction

function dispatch_Spellcast_destroySpellcast takes integer this_43 returns nothing
	if Spellcast_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spellcast.destroySpellcast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spellcast.destroySpellcast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroySpellcast(this_43)
endfunction

function SpellType_toOrderId takes integer this_43 returns integer
	local integer temp = this_43
	if temp == 0 then
		return Spell_qSpellId
	elseif temp == 1 then
		return Spell_wSpellId
	elseif temp == 2 then
		return Spell_eSpellId
	elseif temp == 3 then
		return Spell_rSpellId
	elseif temp == 4 then
		return Spell_dSpellId
	elseif temp == 5 then
		return Spell_fSpellId
	else
		return -1
	endif
endfunction

function Spell_disableCastDummyTimed takes integer this_43 returns nothing
	call timer_start(timer_setData(getTimer(), this_43), 0.0, ref_function_Spell_timedDisableCastDummy)
endfunction

function dispatch_Spell_disableCastDummyTimed takes integer this_43 returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.disableCastDummyTimed")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.disableCastDummyTimed on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			call Spell_disableCastDummyTimed(this_43)
		else
			call Spell_disableCastDummyTimed(this_43)
		endif
	else
		call Spell_disableCastDummyTimed(this_43)
	endif
endfunction

function Spell_enableCastDummy takes integer this_43 returns nothing
	call SetPlayerAbilityAvailable(Unit_owner[Spell_owner[this_43]], Spell_castDummy[this_43], true)
endfunction

function dispatch_Spell_enableCastDummy takes integer this_43 returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.enableCastDummy")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.enableCastDummy on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			call Spell_enableCastDummy(this_43)
		else
			call Spell_enableCastDummy(this_43)
		endif
	else
		call Spell_enableCastDummy(this_43)
	endif
endfunction

function InstantSpell_forceCast takes integer this_43, integer sc returns nothing
	call dispatch_Spell_enableCastDummy(this_43)
	call IssueImmediateOrderById(Unit_u[Spell_owner[this_43]], SpellType_toOrderId(Spell_st[this_43]))
	call dispatch_Spell_disableCastDummyTimed(this_43)
endfunction

function PointOrUnitSpell_forceCast takes integer this_43, integer sc returns nothing
	local integer tempIndex
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_2
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local unit temp
	local integer temp_2
	local real temp_3
	call dispatch_Spell_enableCastDummy(this_43)
	if Spellcast_target[sc] == null then
		set temp = Unit_u[Spell_owner[this_43]]
		set temp_2 = SpellType_toOrderId(Spell_st[this_43])
		set tempIndex = sc
		set tempTupleSelectionResult_1 = Spellcast_pos[tempIndex]
		set tempTupleSelectionResult_2 = Spellcast_pos_2[tempIndex]
		set temp_3 = tempTupleSelectionResult_1
		set tempIndex_2 = sc
		set tempTupleSelectionResult_1_2 = Spellcast_pos[tempIndex_2]
		set tempTupleSelectionResult_2_2 = Spellcast_pos_2[tempIndex_2]
		call IssuePointOrderById(temp, temp_2, temp_3, tempTupleSelectionResult_2_2)
	else
		call IssueTargetOrderById(Unit_u[Spell_owner[this_43]], SpellType_toOrderId(Spell_st[this_43]), Spellcast_target[sc])
	endif
	call dispatch_Spell_disableCastDummyTimed(this_43)
	set temp = null
endfunction

function PointSpell_forceCast takes integer this_43, integer sc returns nothing
	local unit temp = Unit_u[Spell_owner[this_43]]
	local integer temp_2 = SpellType_toOrderId(Spell_st[this_43])
	local integer tempIndex = sc
	local real tempTupleSelectionResult_1 = Spellcast_pos[tempIndex]
	local real tempTupleSelectionResult_2 = Spellcast_pos_2[tempIndex]
	local real temp_3 = tempTupleSelectionResult_1
	local integer tempIndex_2 = sc
	local real tempTupleSelectionResult_1_2 = Spellcast_pos[tempIndex_2]
	local real tempTupleSelectionResult_2_2 = Spellcast_pos_2[tempIndex_2]
	call IssuePointOrderById(temp, temp_2, temp_3, tempTupleSelectionResult_2_2)
	set temp = null
endfunction

function UnitSpell_forceCast takes integer this_43, integer sc returns nothing
	call dispatch_Spell_enableCastDummy(this_43)
	call IssueTargetOrderById(Unit_u[Spell_owner[this_43]], SpellType_toOrderId(Spell_st[this_43]), Spellcast_target[sc])
	call dispatch_Spell_disableCastDummyTimed(this_43)
endfunction

function dispatch_Spell_forceCast takes integer this_43, integer sc returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.forceCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.forceCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 641 then
		if Spell_typeId[this_43] <= 640 then
			if Spell_typeId[this_43] <= 639 then
				call InstantSpell_forceCast(this_43, sc)
			else
				call PointSpell_forceCast(this_43, sc)
			endif
		else
			call UnitSpell_forceCast(this_43, sc)
		endif
	elseif Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			call PointOrUnitSpell_forceCast(this_43, sc)
		else
			call PointSpell_forceCast(this_43, sc)
		endif
	else
		call PointSpell_forceCast(this_43, sc)
	endif
endfunction

function Spellcast_force takes integer this_43 returns nothing
	call dispatch_Spell_forceCast(Spellcast_spell[this_43], this_43)
endfunction

function dispatch_Spellcast_force takes integer this_43 returns nothing
	if Spellcast_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spellcast.force")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spellcast.force on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Spellcast_force(this_43)
endfunction

function Hero_nextOrder takes integer this_43 returns nothing
	local integer sc
	if dispatch_Queue_getSize(Hero_castQueue[this_43]) <= 0 then
		if Hero_mainOrder[this_43] != 0 and Hero_mainOrder[this_43] != Hero_lastOrdered[this_43] then
			set Hero_lastOrdered[this_43] = Hero_mainOrder[this_43]
			if dispatch_Order_issueToUnit(Hero_mainOrder[this_43], Unit_u[this_43]) then
				call dispatch_Hero_setMainOrder(this_43, 0)
			endif
		endif
	else
		set sc = dispatch_Queue_dequeue(Hero_castQueue[this_43])
		call dispatch_Spellcast_force(sc)
		call dispatch_Spellcast_destroySpellcast(sc)
	endif
endfunction

function dispatch_Hero_nextOrder takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.nextOrder")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.nextOrder on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_nextOrder(this_43)
endfunction

function Hero_checkOrders_2 takes nothing returns nothing
	local integer buffer = LinkedListModule_first_4
	loop
		exitwhen  not (buffer != 0)
		if Hero_acceptOrders[buffer] and GetUnitCurrentOrder(Unit_u[buffer]) == 0 then
			call dispatch_Hero_nextOrder(buffer)
		endif
		set buffer = LinkedListModule_next_4[buffer]
	endloop
endfunction

function HandleMap_get takes integer this_43, handle h_2 returns integer
	return hashtable_loadInt(HandleMap_ht, this_43, GetHandleId(h_2))
endfunction

function dispatch_HandleMap_get takes integer this_43, handle h_2 returns integer
	local integer get_result
	if HandleMap_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HandleMap.get")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HandleMap.get on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set get_result = HandleMap_get(this_43, h_2)
	return get_result
endfunction

function Hero_enableAbilityTimed takes nothing returns nothing
	local timer t = GetExpiredTimer()
	local integer obj = timer_getData(t)
	call SetPlayerAbilityAvailable(Unit_owner[obj], dispatch_HandleMap_get(Hero_enableAbility[obj], t), true)
	call timer_release(t)
	set t = null
	set t = null
endfunction

function HashMap_get takes integer this_43, integer key returns integer
	return hashtable_loadInt(HashMap_ht, this_43, key)
endfunction

function dispatch_HashMap_get takes integer this_43, integer key returns integer
	local integer get_result
	if HashMap_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HashMap.get")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HashMap.get on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set get_result = HashMap_get(this_43, key)
	return get_result
endfunction

function dispatch_InstantSpell_onCast takes integer this_43, integer caster returns nothing
endfunction

function InstantSpell_callOnCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y, integer target returns nothing
	call dispatch_InstantSpell_onCast(this_43, caster)
endfunction

function dispatch_PointOrUnitSpell_onPointCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y returns nothing
endfunction

function dispatch_PointOrUnitSpell_onUnitCast takes integer this_43, integer caster, integer target returns nothing
endfunction

function PointOrUnitSpell_callOnCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y, integer target returns nothing
	if target == 0 then
		call dispatch_PointOrUnitSpell_onPointCast(this_43, caster, targetPos_x, targetPos_y)
	else
		call dispatch_PointOrUnitSpell_onUnitCast(this_43, caster, target)
	endif
endfunction

function alloc_SamplePointSpell takes nothing returns integer
	local integer this_43
	if SamplePointSpell_firstFree == 0 then
		set SamplePointSpell_maxIndex = SamplePointSpell_maxIndex + 1
		set this_43 = SamplePointSpell_maxIndex
	else
		set this_43 = SamplePointSpell_firstFree
		set SamplePointSpell_firstFree = SamplePointSpell_nextFree[SamplePointSpell_firstFree]
		set SamplePointSpell_nextFree[this_43] = 0
	endif
	set SamplePointSpell_typeId[this_43] = 714
	return this_43
endfunction

function construct_SamplePointSpell takes integer this_43, integer caster, real pos_x, real pos_y, integer setupData returns nothing
	set SamplePointSpell_t[this_43] = getTimer()
	call timer_setData(SamplePointSpell_t[this_43], this_43)
	call timer_startPeriodic(SamplePointSpell_t[this_43], 0.03, ref_function_SamplePointSpell_callCallback)
endfunction

function new_SamplePointSpell takes integer caster, real pos_x, real pos_y, integer setupData returns integer
	local integer this_43 = alloc_SamplePointSpell()
	call construct_SamplePointSpell(this_43, caster, pos_x, pos_y, setupData)
	return this_43
endfunction

function SamplePointSpellSetup_onCast takes integer this_43, integer caster, real pos_x, real pos_y returns nothing
	call new_SamplePointSpell(caster, pos_x, pos_y, this_43)
endfunction

function alloc_TestSpell1 takes nothing returns integer
	local integer this_43
	if TestSpell1_firstFree == 0 then
		set TestSpell1_maxIndex = TestSpell1_maxIndex + 1
		set this_43 = TestSpell1_maxIndex
	else
		set this_43 = TestSpell1_firstFree
		set TestSpell1_firstFree = TestSpell1_nextFree[TestSpell1_firstFree]
		set TestSpell1_nextFree[this_43] = 0
	endif
	set TestSpell1_typeId[this_43] = 716
	return this_43
endfunction

function Hero_spellStart takes integer this_43 returns nothing
	set Hero_acceptOrders[this_43] = false
endfunction

function dispatch_Hero_spellStart takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.spellStart")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.spellStart on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_spellStart(this_43)
endfunction

function construct_TestSpell1 takes integer this_43, integer caster, integer setup returns nothing
	call SetUnitAnimationByIndex(Unit_u[caster], TestSpell1_animationType)
	call timer_start(getTimer(), 0.0, ref_function_TestSpell1_bla)
	set TestSpell1_setup[this_43] = setup
	set TestSpell1_caster[this_43] = caster
	call dispatch_Hero_spellStart(caster)
	set TestSpell1_t[this_43] = getTimer()
	call timer_setData(TestSpell1_t[this_43], this_43)
	call timer_start(TestSpell1_t[this_43], int_toReal(Spell_lvl[setup]) + 3., ref_function_TestSpell1_callCallback)
endfunction

function new_TestSpell1 takes integer caster, integer setup returns integer
	local integer this_43 = alloc_TestSpell1()
	call construct_TestSpell1(this_43, caster, setup)
	return this_43
endfunction

function TestSpell1Setup_onCast takes integer this_43, integer caster, real pos_x, real pos_y returns nothing
	call new_TestSpell1(caster, this_43)
endfunction

function dispatch_PointSpell_onCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling PointSpell.onCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called PointSpell.onCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		call SamplePointSpellSetup_onCast(this_43, caster, targetPos_x, targetPos_y)
	else
		call TestSpell1Setup_onCast(this_43, caster, targetPos_x, targetPos_y)
	endif
endfunction

function PointSpell_callOnCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y, integer target returns nothing
	call dispatch_PointSpell_onCast(this_43, caster, targetPos_x, targetPos_y)
endfunction

function dispatch_UnitSpell_onCast takes integer this_43, integer caster, integer target returns nothing
endfunction

function UnitSpell_callOnCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y, integer target returns nothing
	call dispatch_UnitSpell_onCast(this_43, caster, target)
endfunction

function dispatch_Spell_callOnCast takes integer this_43, integer caster, real targetPos_x, real targetPos_y, integer target returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.callOnCast")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.callOnCast on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 641 then
		if Spell_typeId[this_43] <= 640 then
			if Spell_typeId[this_43] <= 639 then
				call InstantSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
			else
				call PointSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
			endif
		else
			call UnitSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
		endif
	elseif Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			call PointOrUnitSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
		else
			call PointSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
		endif
	else
		call PointSpell_callOnCast(this_43, caster, targetPos_x, targetPos_y, target)
	endif
endfunction

function Hero_handleCasts takes nothing returns nothing
	local integer s = dispatch_HashMap_get(Hero_abiIdToSpell, GetSpellAbilityId())
	local integer h_2
	local real pos_x
	local real pos_y
	local integer un
	if s != 0 then
		set h_2 = unit_getUserData(GetTriggerUnit())
		set pos_x = GetSpellTargetX()
		set pos_y = GetSpellTargetY()
		set un = unit_getUserData(GetSpellTargetUnit())
		call dispatch_Spell_callOnCast(s, h_2, pos_x, pos_y, un)
	endif
endfunction

function createImage takes string path, real pos_x, real pos_y, real sizeX, real sizeY, integer layer returns image
	local image temp = CreateImage(path, sizeX, sizeY, 0., pos_x, pos_y, 0., sizeX / 2., sizeY / 2., 0., layer + 1)
	call SetImageConstantHeight(temp, true,  - 2.9)
	set createImagetempReturn_2 = temp
	set temp = null
	return createImagetempReturn_2
endfunction

function image_show takes image this_43 returns nothing
	call SetImageRenderAlways(this_43, true)
endfunction

function Image_growCallback takes integer this_43, player p, timer t returns nothing
	local integer currentTick = dispatch_HandleMap_get(Image_tick, t)
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_6
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real temp
	local real temp_2
	local integer temp_3
	local string temp_4
	local real temp_5
	local real temp_6
	local real temp_7
	local integer temp_8
	if GetLocalPlayer() == p then
		set tempIndex = this_43
		set temp_3 = tempIndex
		set tempIndex_2 = this_43
		set temp = Image_realSize[tempIndex_2]
		set temp_2 = Image_realSize_2[tempIndex_2]
		set tempIndex_3 = this_43
		set Image_realSize[temp_3] = vec2_op_plus(temp, temp_2, Image_resizeRate[tempIndex_3], Image_resizeRate_2[tempIndex_3])
		set Image_realSize_2[tempIndex] = vec2_op_plus_return_y
		if Image_img[this_43] != null then
			call image_remove(Image_img[this_43])
			set temp_8 = this_43
			set temp_4 = Image_filePath[this_43]
			set tempIndex_4 = this_43
			set temp_5 = Image_realPos[tempIndex_4]
			set temp_6 = Image_realPos_2[tempIndex_4]
			set tempIndex_5 = this_43
			set tempTupleSelectionResult_1 = Image_realSize[tempIndex_5]
			set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_5]
			set temp_7 = tempTupleSelectionResult_1
			set tempIndex_6 = this_43
			set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_6]
			set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_6]
			set Image_img[temp_8] = createImage(temp_4, temp_5, temp_6, temp_7, tempTupleSelectionResult_2_2, Image_layer[this_43])
			call image_show(Image_img[this_43])
		endif
	endif
	if currentTick > 1 then
		call dispatch_HandleMap_put(Image_tick, t, currentTick - 1)
	else
		call timer_release(GetExpiredTimer())
	endif
endfunction

function dispatch_Image_growCallback takes integer this_43, player p, timer t returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.growCallback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.growCallback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_growCallback(this_43, p, t)
endfunction

function Image_callGrowCallback takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Image_growCallback(timer_getData(t), playerFromIndex(dispatch_HandleMap_get(Image_timerOwner, t)), t)
	set t = null
endfunction

function image_setColor takes image this_43, integer col_red, integer col_green, integer col_blue, integer col_alpha returns nothing
	call SetImageColor(this_43, col_red, col_green, col_blue, col_alpha)
endfunction

function Image_hideFadedCallback takes integer this_43, player p, timer t returns nothing
	local integer currentTick = dispatch_HandleMap_get(Image_tick, t)
	local integer tempIndex
	local integer tempIndex_2
	local integer tempTupleSelectionResult_1
	local integer tempTupleSelectionResult_2
	local integer tempTupleSelectionResult_3
	local integer tempTupleSelectionResult_4
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local integer temp
	local image temp_2
	local image temp_3
	if currentTick < 0 then
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp = tempIndex
			set tempIndex_2 = this_43
			set tempTupleSelectionResult_1 = Image_col[tempIndex_2]
			set tempTupleSelectionResult_2 = Image_col_2[tempIndex_2]
			set tempTupleSelectionResult_3 = Image_col_3[tempIndex_2]
			set tempTupleSelectionResult_4 = Image_col_4[tempIndex_2]
			set Image_col_4[temp] = tempTupleSelectionResult_4 - 31
			set temp_2 = Image_img[this_43]
			set tempIndex_3 = this_43
			call image_setColor(temp_2, Image_col[tempIndex_3], Image_col_2[tempIndex_3], Image_col_3[tempIndex_3], Image_col_4[tempIndex_3])
		endif
		call dispatch_HandleMap_put(Image_tick, t, currentTick + 1)
	else
		call timer_release(GetExpiredTimer())
		if GetLocalPlayer() == p then
			set tempIndex_4 = this_43
			set Image_col_4[tempIndex_4] = 0
			set temp_3 = Image_img[this_43]
			set tempIndex_5 = this_43
			call image_setColor(temp_3, Image_col[tempIndex_5], Image_col_2[tempIndex_5], Image_col_3[tempIndex_5], Image_col_4[tempIndex_5])
			call image_remove(Image_img[this_43])
			set Image_img[this_43] = null
		endif
	endif
	set temp_2 = null
	set temp_3 = null
endfunction

function dispatch_Image_hideFadedCallback takes integer this_43, player p, timer t returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.hideFadedCallback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.hideFadedCallback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_hideFadedCallback(this_43, p, t)
endfunction

function Image_callHideFadedCallback takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Image_hideFadedCallback(timer_getData(t), playerFromIndex(dispatch_HandleMap_get(Image_timerOwner, t)), t)
	set t = null
endfunction

function Image_showFadedCallback takes integer this_43, player p, timer t returns nothing
	local integer currentTick = dispatch_HandleMap_get(Image_tick, t)
	local integer tempIndex
	local integer tempIndex_2
	local integer tempTupleSelectionResult_1
	local integer tempTupleSelectionResult_2
	local integer tempTupleSelectionResult_3
	local integer tempTupleSelectionResult_4
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local integer temp
	local image temp_2
	local image temp_3
	if currentTick > 0 then
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp = tempIndex
			set tempIndex_2 = this_43
			set tempTupleSelectionResult_1 = Image_col[tempIndex_2]
			set tempTupleSelectionResult_2 = Image_col_2[tempIndex_2]
			set tempTupleSelectionResult_3 = Image_col_3[tempIndex_2]
			set tempTupleSelectionResult_4 = Image_col_4[tempIndex_2]
			set Image_col_4[temp] = tempTupleSelectionResult_4 + 31
			set temp_2 = Image_img[this_43]
			set tempIndex_3 = this_43
			call image_setColor(temp_2, Image_col[tempIndex_3], Image_col_2[tempIndex_3], Image_col_3[tempIndex_3], Image_col_4[tempIndex_3])
		endif
		call dispatch_HandleMap_put(Image_tick, t, currentTick - 1)
	else
		if GetLocalPlayer() == p then
			set tempIndex_4 = this_43
			set Image_col_4[tempIndex_4] = 255
			set temp_3 = Image_img[this_43]
			set tempIndex_5 = this_43
			call image_setColor(temp_3, Image_col[tempIndex_5], Image_col_2[tempIndex_5], Image_col_3[tempIndex_5], Image_col_4[tempIndex_5])
		endif
		call timer_release(t)
	endif
	set temp_2 = null
	set temp_3 = null
endfunction

function dispatch_Image_showFadedCallback takes integer this_43, player p, timer t returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.showFadedCallback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.showFadedCallback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_showFadedCallback(this_43, p, t)
endfunction

function Image_callShowFadedCallback takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Image_showFadedCallback(timer_getData(t), playerFromIndex(dispatch_HandleMap_get(Image_timerOwner, t)), t)
	set t = null
endfunction

function vec2_op_minus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_minus_return_x = this_x - v_x
	set vec2_op_minus_return_y = this_y - v_y
	return vec2_op_minus_return_x
endfunction

function Image_srinkCallback takes integer this_43, player p, timer t returns nothing
	local integer currentTick = dispatch_HandleMap_get(Image_tick, t)
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_6
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real temp
	local real temp_2
	local integer temp_3
	local string temp_4
	local real temp_5
	local real temp_6
	local real temp_7
	local integer temp_8
	if GetLocalPlayer() == p then
		set tempIndex = this_43
		set temp_3 = tempIndex
		set tempIndex_2 = this_43
		set temp = Image_realSize[tempIndex_2]
		set temp_2 = Image_realSize_2[tempIndex_2]
		set tempIndex_3 = this_43
		set Image_realSize[temp_3] = vec2_op_minus(temp, temp_2, Image_resizeRate[tempIndex_3], Image_resizeRate_2[tempIndex_3])
		set Image_realSize_2[tempIndex] = vec2_op_minus_return_y
		if Image_img[this_43] != null then
			call image_remove(Image_img[this_43])
			set temp_8 = this_43
			set temp_4 = Image_filePath[this_43]
			set tempIndex_4 = this_43
			set temp_5 = Image_realPos[tempIndex_4]
			set temp_6 = Image_realPos_2[tempIndex_4]
			set tempIndex_5 = this_43
			set tempTupleSelectionResult_1 = Image_realSize[tempIndex_5]
			set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_5]
			set temp_7 = tempTupleSelectionResult_1
			set tempIndex_6 = this_43
			set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_6]
			set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_6]
			set Image_img[temp_8] = createImage(temp_4, temp_5, temp_6, temp_7, tempTupleSelectionResult_2_2, Image_layer[this_43])
			call image_show(Image_img[this_43])
		endif
	endif
	if currentTick > 1 then
		call dispatch_HandleMap_put(Image_tick, t, currentTick - 1)
	else
		call timer_release(GetExpiredTimer())
	endif
endfunction

function dispatch_Image_srinkCallback takes integer this_43, player p, timer t returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.srinkCallback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.srinkCallback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_srinkCallback(this_43, p, t)
endfunction

function Image_callSrinkCallback takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Image_srinkCallback(timer_getData(t), playerFromIndex(dispatch_HandleMap_get(Image_timerOwner, t)), t)
	set t = null
endfunction

function Fx_getX takes integer this_43 returns real
	return unit_getX(Fx_dummy[this_43])
endfunction

function dispatch_Fx_getX takes integer this_43 returns real
	local real getX_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.getX")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.getX on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getX_result = Fx_getX(this_43)
	return getX_result
endfunction

function Fx_getY takes integer this_43 returns real
	return unit_getY(Fx_dummy[this_43])
endfunction

function dispatch_Fx_getY takes integer this_43 returns real
	local real getY_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.getY")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.getY on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getY_result = Fx_getY(this_43)
	return getY_result
endfunction

function Fx_getPos2 takes integer this_43 returns real
	set Fx_getPos2_return_x = dispatch_Fx_getX(this_43)
	set Fx_getPos2_return_y = dispatch_Fx_getY(this_43)
	return Fx_getPos2_return_x
endfunction

function dispatch_Fx_getPos2 takes integer this_43 returns real
	local real getPos2_result_x
	local real getPos2_result_y
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.getPos2")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.getPos2 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getPos2_result_x = Fx_getPos2(this_43)
	set getPos2_result_y = Fx_getPos2_return_y
	set dispatch_Fx_getPos2_return_x = getPos2_result_x
	set dispatch_Fx_getPos2_return_y = getPos2_result_y
	return dispatch_Fx_getPos2_return_x
endfunction

function Fx_setPos_2 takes integer this_43, real pos_x, real pos_y returns integer
	call unit_setPos(Fx_dummy[this_43], pos_x, pos_y)
	return this_43
endfunction

function dispatch_Fx_setPos_2 takes integer this_43, real pos_x, real pos_y returns integer
	local integer setPos_result
	if Fx_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Fx.setPos")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Fx.setPos on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set setPos_result = Fx_setPos_2(this_43, pos_x, pos_y)
	return setPos_result
endfunction

function Missle_onDestroy takes integer this_43 returns nothing
	call dispatch_Unit2Event_destroyUnit2Event(Missle_atHit[this_43])
	call dispatch_Unit2Event_destroyUnit2Event(Missle_atEnd[this_43])
	call timer_release(Missle_t[this_43])
	call dispatch_Fx_destroyFx(Missle_fx[this_43])
endfunction

function dealloc_Missle takes integer obj returns nothing
	if Missle_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Missle")
		call I2S(1 / 0)
	else
		set Missle_nextFree[Missle_lastFree] = obj
		set Missle_lastFree = obj
		if Missle_firstFree == 0 then
			set Missle_firstFree = obj
			set Missle_nextFree[obj] = 0
		endif
		set Missle_typeId[obj] = 0
	endif
endfunction

function destroyMissle takes integer this_43 returns nothing
	call Missle_onDestroy(this_43)
	call dealloc_Missle(this_43)
endfunction

function dispatch_Missle_destroyMissle takes integer this_43 returns nothing
	if Missle_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Missle.destroyMissle")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Missle.destroyMissle on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyMissle(this_43)
endfunction

function Missle_move takes integer this_43 returns nothing
	local group g
	local unit u
	local real prePos_x
	local real prePos_y
	local unit hitUnit
	local real minDist
	local unit lu
	local real targetPos_x
	local real targetPos_y
	local real currentDist
	local integer tempIndex
	local integer tempIndex_2
	local real temp
	local real temp_2
	local integer temp_3
	local real temp_4
	local real temp_5
	if Missle_dl[this_43] <= 0 then
		call dispatch_Unit2Event_fire(Missle_atEnd[this_43], Missle_source[this_43], 0)
		call dispatch_Missle_destroyMissle(this_43)
	else
		set temp_3 = Missle_fx[this_43]
		set temp = dispatch_Fx_getPos2(Missle_fx[this_43])
		set temp_2 = dispatch_Fx_getPos2_return_y
		set tempIndex = this_43
		call dispatch_Fx_setPos_2(temp_3, vec2_op_plus(temp, temp_2, Missle_vel[tempIndex], Missle_vel_2[tempIndex]), vec2_op_plus_return_y)
		set g = CreateGroup()
		set Filter_filterCheckUnit = Unit_u[Missle_source[this_43]]
		set Filter_filterCheckPlayer = Unit_owner[Missle_source[this_43]]
		call GroupEnumUnitsInRange(g, dispatch_Fx_getX(Missle_fx[this_43]), dispatch_Fx_getY(Missle_fx[this_43]), Missle_radius[this_43], Missle_filter[this_43])
		set u = FirstOfGroup(g)
		if u == null then
			set Missle_dl[this_43] = Missle_dl[this_43] - 1
		else
			call GroupRemoveUnit(g, u)
			if FirstOfGroup(g) == null then
				call dispatch_Unit2Event_fire(Missle_atHit[this_43], Missle_source[this_43], unit_getUserData(u))
				call DestroyGroup(g)
				call dispatch_Missle_destroyMissle(this_43)
				set g = null
				set u = null
			else
				call GroupAddUnit(g, u)
				set temp_4 = dispatch_Fx_getPos2(Missle_fx[this_43])
				set temp_5 = dispatch_Fx_getPos2_return_y
				set tempIndex_2 = this_43
				set prePos_x = vec2_op_minus(temp_4, temp_5, Missle_vel[tempIndex_2], Missle_vel_2[tempIndex_2])
				set prePos_y = vec2_op_minus_return_y
				set hitUnit = null
				set minDist = 10000.
				loop
					exitwhen  not group_hasNext(g)
					set lu = group_next(g)
					set targetPos_x = unit_getPos(lu)
					set targetPos_y = unit_getPos_return_y
					set currentDist = vec2_distToVec(targetPos_x, targetPos_y, prePos_x, prePos_y)
					if currentDist > minDist then
						set minDist = currentDist
						set hitUnit = lu
					endif
				endloop
				call dispatch_Unit2Event_fire(Missle_atHit[this_43], Missle_source[this_43], unit_getUserData(hitUnit))
				call DestroyGroup(g)
				set u = null
				set g = null
				set hitUnit = null
				call dispatch_Missle_destroyMissle(this_43)
			endif
		endif
	endif
	set g = null
	set u = null
	set hitUnit = null
	set lu = null
endfunction

function dispatch_Missle_move takes integer this_43 returns nothing
	if Missle_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Missle.move")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Missle.move on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Missle_move(this_43)
endfunction

function Missle_callMove takes nothing returns nothing
	call dispatch_Missle_move(timer_getData(GetExpiredTimer()))
endfunction

function Preload_createBackground takes nothing returns nothing
	local integer i1 = 0
	local integer i2
	loop
		exitwhen i1 > 4
		set i2 = 0
		loop
			exitwhen i2 > 2
			call image_show(createImage("war3mapImported\\background.blp", Setup_menuStart_x + 2.5 + i1 * 9.9, Setup_menuStart_y + 2.5 + i2 * 9.9, 10., 10., 1))
			set i2 = i2 + 1
		endloop
		set i1 = i1 + 1
	endloop
endfunction

function TList_getSize takes integer this_43 returns integer
	return TList_size[this_43]
endfunction

function dispatch_TList_getSize takes integer this_43 returns integer
	local integer getSize_result
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.getSize")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.getSize on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getSize_result = TList_getSize(this_43)
	return getSize_result
endfunction

function Preload_createItems takes nothing returns real
	set Setup_permAttackTome[Preload_itemCounter] = CreateItem(dispatch_TList_get(Setup_permAttackTomeId, Preload_itemCounter), Setup_recycleGraveyard_x, Setup_recycleGraveyard_y)
	if Preload_itemCounter >= dispatch_TList_getSize(Setup_permAttackTomeId) - 1 then
		return 0.
	else
		set Preload_itemCounter = Preload_itemCounter + 1
		return 0.05
	endif
endfunction

function alloc_Trackable takes nothing returns integer
	local integer this_43
	if Trackable_firstFree == 0 then
		set Trackable_maxIndex = Trackable_maxIndex + 1
		set this_43 = Trackable_maxIndex
	else
		set this_43 = Trackable_firstFree
		set Trackable_firstFree = Trackable_nextFree[Trackable_firstFree]
		set Trackable_nextFree[this_43] = 0
	endif
	set Trackable_typeId[this_43] = 702
	return this_43
endfunction

function construct_Trackable takes integer this_43, real pos_x, real pos_y, string path, player owner returns nothing
	local integer tempIndex
	set Trackable_owner[this_43] = null
	set Trackable_doubleHit[this_43] = null
	set Trackable_wasHit[this_43] = false
	set Trackable_doubleHitTimer[this_43] = getTimer()
	set tempIndex = this_43
	set Trackable_pos[tempIndex] = pos_x
	set Trackable_pos_2[tempIndex] = pos_y
	set Trackable_owner[this_43] = owner
	set Trackable_filePath[this_43] = path
endfunction

function new_Trackable takes real pos_x, real pos_y, string path, player owner returns integer
	local integer this_43 = alloc_Trackable()
	call construct_Trackable(this_43, pos_x, pos_y, path, owner)
	return this_43
endfunction

function createTrackableForPlayer takes real pos_x, real pos_y, string path, player p returns trackable
	local string newPath = ""
	local trackable t
	if GetLocalPlayer() == p then
		set newPath = path
	endif
	set t = CreateTrackable(newPath, pos_x, pos_y, 0.)
	call dispatch_HandleMap_put(Trackable_trackData, t, new_Trackable(pos_x, pos_y, path, p))
	set createTrackableForPlayertempReturn = t
	set t = null
	return createTrackableForPlayertempReturn
endfunction

function hashtable_saveTrackableHandle takes hashtable this_43, integer parentKey, integer childKey, trackable value returns hashtable
	call SaveTrackableHandle(this_43, parentKey, childKey, value)
	return this_43
endfunction

function Table3D_put takes integer this_43, integer key1, integer key2, integer key3, trackable t returns nothing
	call hashtable_saveTrackableHandle(Table3D_ht[this_43], key1, key2 * Table3D_key3IndexSize[this_43] + key3, t)
endfunction

function dispatch_Table3D_put takes integer this_43, integer key1, integer key2, integer key3, trackable t returns nothing
	if Table3D_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table3D.put")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table3D.put on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Table3D_put(this_43, key1, key2, key3, t)
endfunction

function hashtable_hasBoolean takes hashtable this_43, integer parentKey, integer childKey returns boolean
	return HaveSavedBoolean(this_43, parentKey, childKey)
endfunction

function trigger_registerTrackableHitEvent takes trigger this_43, trackable whichTrackable returns trigger
	call TriggerRegisterTrackableHitEvent(this_43, whichTrackable)
	return this_43
endfunction

function trigger_registerTrackableDoubleHitEvent takes trigger this_43, trackable t returns nothing
	local integer tr = dispatch_HandleMap_get(Trackable_trackData, t)
	set Trackable_doubleHit[tr] = this_43
	call trigger_registerTrackableHitEvent(Trackable_doubleHitDetect, t)
endfunction

function trigger_registerTrackableTrackEvent takes trigger this_43, trackable whichTrackable returns trigger
	call TriggerRegisterTrackableTrackEvent(this_43, whichTrackable)
	return this_43
endfunction

function Preload_createTrackables takes nothing returns real
	local integer i1 = 1
	local real trackVec_x
	local real trackVec_y
	local trackable t
	local integer i2
	loop
		exitwhen i1 > 10
		set Preload_trackCounter = Preload_trackCounter + 1
		if Preload_trackCounter <= 968 then
			if  not hashtable_hasBoolean(Setup_trackBlacklist, Preload_trackPos_i1, Preload_trackPos_i2) then
				set trackVec_x = Setup_menuStart_x + Preload_trackPos_i1
				set trackVec_y = Setup_menuStart_y + Preload_trackPos_i2
				set t = null
				set i2 = 0
				loop
					exitwhen i2 > 11
					set t = createTrackableForPlayer(trackVec_x, trackVec_y, "war3mapImported\\1x1TrackC.mdx", Player(i2))
					call trigger_registerTrackableHitEvent(Setup_trackableHitTrigger, t)
					call trigger_registerTrackableTrackEvent(Setup_trackableTrackTrigger, t)
					call trigger_registerTrackableDoubleHitEvent(Setup_trackableDoubleHitTrigger, t)
					call dispatch_Table3D_put(Setup_trackableMap, Preload_trackPos_i1, Preload_trackPos_i2, i2, t)
					set i2 = i2 + 1
				endloop
			endif
			if Preload_trackPos_i2 >= Setup_menuHeight then
				set Preload_trackPos_i2 = 1
				set Preload_trackPos_i1 = Preload_trackPos_i1 + 1
			else
				set Preload_trackPos_i2 = Preload_trackPos_i2 + 1
			endif
		else
			set t = null
			return 0.
		endif
		set i1 = i1 + 1
	endloop
	set t = null
	return 0.025
endfunction

function SpellType_toId takes integer this_43 returns integer
	local integer temp = this_43
	if temp == 0 then
		return 81
	elseif temp == 1 then
		return 87
	elseif temp == 2 then
		return 69
	elseif temp == 3 then
		return 82
	elseif temp == 4 then
		return 68
	elseif temp == 5 then
		return 70
	else
		return -1
	endif
endfunction

function ObjId_getId takes integer this_43 returns integer
	return ObjId_id1[this_43] + ObjId_id2[this_43] + ObjId_id3[this_43] + ObjId_id4[this_43]
endfunction

function dispatch_ObjId_getId takes integer this_43 returns integer
	local integer getId_result
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.getId")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.getId on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getId_result = ObjId_getId(this_43)
	return getId_result
endfunction

function ObjId_setId1 takes integer this_43, integer char1 returns nothing
	set ObjId_id1[this_43] = char1 * 16777216
endfunction

function dispatch_ObjId_setId1 takes integer this_43, integer char1 returns nothing
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.setId1")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.setId1 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ObjId_setId1(this_43, char1)
endfunction

function ObjId_setId2 takes integer this_43, integer char2 returns nothing
	set ObjId_id2[this_43] = char2 * 65536
endfunction

function dispatch_ObjId_setId2 takes integer this_43, integer char2 returns nothing
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.setId2")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.setId2 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ObjId_setId2(this_43, char2)
endfunction

function ObjId_setId3 takes integer this_43, integer char3 returns nothing
	set ObjId_id3[this_43] = char3 * 256
endfunction

function dispatch_ObjId_setId3 takes integer this_43, integer char3 returns nothing
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.setId3")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.setId3 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ObjId_setId3(this_43, char3)
endfunction

function char takes string s returns integer
	local integer a
	if "\\" == s then
		return 92
	endif
	set a = Char_s2c[StringHash(s) / 2033480 + 1002]
	if s != Char_c2s[a] then
		return a + 32
	endif
	return a
endfunction

function char_toInt takes integer this_c returns integer
	return this_c
endfunction

function string_charAt takes string this_43, integer index returns string
	return SubString(this_43, index, index + 1)
endfunction

function ObjId_setId4 takes integer this_43, string char4 returns nothing
	set ObjId_id4[this_43] = char_toInt(char(string_charAt(char4, 3)))
endfunction

function dispatch_ObjId_setId4 takes integer this_43, string char4 returns nothing
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.setId4")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.setId4 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ObjId_setId4(this_43, char4)
endfunction

function alloc_ObjId takes nothing returns integer
	local integer this_43
	if ObjId_firstFree == 0 then
		set ObjId_maxIndex = ObjId_maxIndex + 1
		set this_43 = ObjId_maxIndex
	else
		set this_43 = ObjId_firstFree
		set ObjId_firstFree = ObjId_nextFree[ObjId_firstFree]
		set ObjId_nextFree[this_43] = 0
	endif
	set ObjId_typeId[this_43] = 635
	return this_43
endfunction

function construct_ObjId takes integer this_43 returns nothing
endfunction

function new_ObjId takes nothing returns integer
	local integer this_43 = alloc_ObjId()
	call construct_ObjId(this_43)
	return this_43
endfunction

function Preload_disableAbilitys takes nothing returns real
	local integer id = new_ObjId()
	local integer i1
	local integer i2
	local integer i3
	call dispatch_ObjId_setId2(id, 83)
	call dispatch_ObjId_setId3(id, 80)
	set i1 = 0
	loop
		exitwhen i1 > 5
		call dispatch_ObjId_setId1(id, SpellType_toId(i1))
		set i2 = 0
		loop
			exitwhen i2 > 3
			call dispatch_ObjId_setId4(id, int_toString(i2))
			set i3 = 0
			loop
				exitwhen i3 > 11
				call SetPlayerAbilityAvailable(Player(i3), dispatch_ObjId_getId(id), false)
				set i3 = i3 + 1
			endloop
			set i2 = i2 + 1
		endloop
		set i1 = i1 + 1
	endloop
	return 0.
endfunction

function debugIdInteger2IdString takes integer value returns string
	local string charMap = ".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
	local string result = ""
	local integer remainingValue = value
	local integer byteno = 0
	local integer charValue
	loop
		exitwhen byteno > 3
		set charValue = ModuloInteger(remainingValue, 256)
		set remainingValue = remainingValue / 256
		set result = SubString(charMap, charValue, charValue + 1) + result
		set byteno = byteno + 1
	endloop
	return result
endfunction

function Preload_preloadAbilitys takes nothing returns real
	call unit_addAbility(Preload_preloadDummy, dispatch_TList_get(Setup_preloadAbi, Preload_abiCounter))
	if GetUnitAbilityLevel(Preload_preloadDummy, dispatch_TList_get(Setup_preloadAbi, Preload_abiCounter)) == 0 then
		call print("The Ability " + debugIdInteger2IdString(dispatch_TList_get(Setup_preloadAbi, Preload_abiCounter)) + " was not sucessfully loaded")
		return  - 1.
	endif
	if Preload_abiCounter >= dispatch_TList_getSize(Setup_preloadAbi) - 1 then
		return 0.
	else
		call SetUnitAbilityLevel(Preload_preloadDummy, dispatch_TList_get(Setup_preloadAbi, Preload_abiCounter), 100)
		set Preload_abiCounter = Preload_abiCounter + 1
		return Setup_abilityLoadTime + GetUnitAbilityLevel(Preload_preloadDummy, dispatch_TList_get(Setup_preloadAbi, Preload_abiCounter - 1)) * Setup_abilityLoadTimeLevelBonus
	endif
endfunction

function SimpleEvent_onDestroy takes integer this_43 returns nothing
	call Event_onDestroy(this_43)
endfunction

function dealloc_SimpleEvent takes integer obj returns nothing
	if Event_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type SimpleEvent")
		call I2S(1 / 0)
	else
		set Event_nextFree[Event_lastFree] = obj
		set Event_lastFree = obj
		if Event_firstFree == 0 then
			set Event_firstFree = obj
			set Event_nextFree[obj] = 0
		endif
		set Event_typeId[obj] = 0
	endif
endfunction

function destroySimpleEvent takes integer this_43 returns nothing
	call SimpleEvent_onDestroy(this_43)
	call dealloc_SimpleEvent(this_43)
endfunction

function dispatch_SimpleEvent_destroySimpleEvent takes integer this_43 returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SimpleEvent.destroySimpleEvent")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SimpleEvent.destroySimpleEvent on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroySimpleEvent(this_43)
endfunction

function SimpleEvent_fire takes integer this_43 returns nothing
	call Event_callActions(this_43, 0)
endfunction

function dispatch_SimpleEvent_fire takes integer this_43 returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SimpleEvent.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SimpleEvent.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SimpleEvent_fire(this_43)
endfunction

function real_toString takes real this_43 returns string
	return R2S(this_43)
endfunction

function Preload_preload takes nothing returns nothing
	local real check = -1.
	local integer temp = Preload_preloadStatus
	if temp == 0 then
		set check = Preload_createTrackables()
	elseif temp == 1 then
		set check = Preload_preloadAbilitys()
	elseif temp == 2 then
		set check = Preload_createItems()
	elseif temp == 3 then
		set check = Preload_disableAbilitys()
	elseif temp == 4 then
		call ClearTextMessages()
		call print("Preload Done")
		call timer_release(GetExpiredTimer())
		call unit_remove(Preload_preloadDummy)
		call dispatch_SimpleEvent_fire(Preload_preloadEnd)
		call dispatch_SimpleEvent_destroySimpleEvent(Preload_preloadEnd)
		return
	else
		call printError("Invaild preload Status")
	endif
	if check == -1. then
		call printError("An error while Preloading has ocurred")
	elseif check == 0. then
		set Preload_preloadStatus = Preload_preloadStatus + 1
		call timer_start(GetExpiredTimer(), 0.05, ref_function_Preload_preload_2)
		set Preload_progress = Preload_progress + 0.05
	else
		call timer_start(GetExpiredTimer(), check, ref_function_Preload_preload_3)
		set Preload_progress = Preload_progress + check
	endif
	if Preload_showProgress then
		call ClearTextMessages()
		call print("Loaded: " + real_toString(100. * (Preload_progress / Preload_maxProgress)) + "%")
	endif
endfunction

function TList_add takes integer this_43, integer elem returns nothing
	call hashtable_saveInt(TList_ht, this_43, TList_size[this_43], elem)
	set TList_size[this_43] = TList_size[this_43] + 1
endfunction

function dispatch_TList_add takes integer this_43, integer elem returns nothing
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.add")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.add on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TList_add(this_43, elem)
endfunction

function Unit_addKnock takes integer this_43, real x, real y returns nothing
	set Unit_wallLocX[this_43] = 0.
	set Unit_wallLocY[this_43] = 0.
	set Unit_knockX[this_43] = Unit_knockX[this_43] + x
	set Unit_knockY[this_43] = Unit_knockY[this_43] + y
	if  not Unit_hasKnockback[this_43] then
		set Unit_hasKnockback[this_43] = true
		call dispatch_TList_add(UnitClass_knocklist, this_43)
	endif
	set Unit_lastCollision[this_43] = 0
endfunction

function dispatch_Unit_addKnock takes integer this_43, real x, real y returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.addKnock")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.addKnock on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_addKnock(this_43, x, y)
	else
		call Unit_addKnock(this_43, x, y)
	endif
endfunction

function distanceBetweenCoords takes real x1, real y1, real x2, real y2 returns real
	return SquareRoot((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
endfunction

function isTerrainWalkable takes real x, real y returns boolean
	call MoveRectTo(Terrain_find, x, y)
	call EnumItemsInRect(Terrain_find, null, ref_function_hideItem)
	call SetItemPosition(Terrain_dItem, x, y)
	set Terrain_X = GetItemX(Terrain_dItem)
	set Terrain_Y = GetItemY(Terrain_dItem)
	call SetItemVisible(Terrain_dItem, false)
	loop
		exitwhen  not (Terrain_hidMax > 0)
		set Terrain_hidMax = Terrain_hidMax - 1
		call SetItemVisible(Terrain_hid[Terrain_hidMax], true)
		set Terrain_hid[Terrain_hidMax] = null
	endloop
	return (Terrain_X - x) * (Terrain_X - x) + (Terrain_Y - y) * (Terrain_Y - y) <= Terrain_MAX_RANGE * Terrain_MAX_RANGE and ( not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY))
endfunction

function Pull2_theSpell takes integer this_43 returns nothing
	local real dist
	local real x
	local real y
	set Pull2_i[this_43] = Pull2_i[this_43] - 1
	call SetLightningColor(Pull2_l[this_43], Pull2_i[this_43] * 1. / Pull2_imax[this_43], Pull2_i[this_43] * 1. / Pull2_imax[this_43], Pull2_i[this_43] * 1. / Pull2_imax[this_43], 1.)
	call MoveLightningEx(Pull2_l[this_43], true, unit_getX(Pull2_u[this_43]), unit_getY(Pull2_u[this_43]), 50., unit_getX(Pull2_ut[this_43]), unit_getY(Pull2_ut[this_43]), 50.)
	set dist = distanceBetweenCoords(unit_getX(Pull2_u[this_43]), unit_getY(Pull2_u[this_43]), unit_getX(Pull2_ut[this_43]), unit_getY(Pull2_ut[this_43]))
	if Pull2_i[this_43] <= 0 then
		call timer_release(Pull2_t[this_43])
		call DestroyLightning(Pull2_l[this_43])
	elseif dist > 100. then
		set Unit_knockX[Pull2_uut[this_43]] = Unit_knockX[Pull2_uut[this_43]] * 0.5
		set Unit_knockY[Pull2_uut[this_43]] = Unit_knockY[Pull2_uut[this_43]] * 0.5
		set x = 0.
		set y = 0.
		if isTerrainWalkable(unit_getX(Pull2_ut[this_43]) + x, unit_getY(Pull2_ut[this_43]) + y) == true then
			call print(R2S(RAbsBJ(x) + RAbsBJ(y)))
			set Unit_lastKnocker[Pull2_uut[this_43]] = unit_getUserData(Pull2_u[this_43])
			call dispatch_Unit_addKnock(Pull2_uut[this_43], x, y)
		else
			set Pull2_i[this_43] = 0
		endif
	else
		set Pull2_i[this_43] = 0
	endif
endfunction

function dispatch_Pull2_theSpell takes integer this_43 returns nothing
	if Pull2_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Pull2.theSpell")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Pull2.theSpell on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Pull2_theSpell(this_43)
endfunction

function Pull2_blackHCall takes nothing returns nothing
	call dispatch_Pull2_theSpell(timer_getData(GetExpiredTimer()))
endfunction

function RockThrow_rockMove takes integer this_43 returns nothing
	local real terrainZ
	local group wurst__iterator0
	local unit u
	local integer rocky
	set RockThrow_i[this_43] = RockThrow_i[this_43] - 1
	set RockThrow_c[this_43] = RockThrow_c[this_43] + 1
	call SetUnitPosition(RockThrow_dummy[this_43], unit_getX(RockThrow_dummy[this_43]) + RockThrow_x[this_43], unit_getY(RockThrow_dummy[this_43]) + RockThrow_y[this_43])
	call SetUnitFacing(RockThrow_dummy[this_43], I2R(RockThrow_c[this_43]))
	set RockThrow_currentZ[this_43] = RockThrow_currentZ[this_43] + RockThrow_z[this_43]
	set terrainZ = getTerrainZ(unit_getX(RockThrow_dummy[this_43]), unit_getY(RockThrow_dummy[this_43]))
	call SetUnitFlyHeight(RockThrow_dummy[this_43], RockThrow_currentZ[this_43] - terrainZ, 0.)
	set RockThrow_z[this_43] = RockThrow_z[this_43] - RockThrow_grav[this_43]
	if RockThrow_i[this_43] <= 0 then
		set RockThrow_e[this_43] = AddSpecialEffect("Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl", unit_getX(RockThrow_dummy[this_43]), unit_getY(RockThrow_dummy[this_43]))
		call effect_destr(RockThrow_e[this_43])
		set RockThrow_g[this_43] = CreateGroup()
		call GroupEnumUnitsInRange(RockThrow_g[this_43], unit_getX(RockThrow_dummy[this_43]), unit_getY(RockThrow_dummy[this_43]), RockThrow_range[this_43], null)
		set wurst__iterator0 = group_iterator(RockThrow_g[this_43])
		loop
			exitwhen  not group_hasNext(wurst__iterator0)
			set u = group_next(wurst__iterator0)
			set RockThrow_distd[this_43] = 1. - distanceBetweenCoords(unit_getX(u), unit_getY(u), unit_getX(RockThrow_dummy[this_43]), unit_getY(RockThrow_dummy[this_43])) / RockThrow_range[this_43]
			set RockThrow_ang[this_43] = 1.
			set RockThrow_x[this_43] = 1.
			set RockThrow_y[this_43] = 1.
			set rocky = GetUnitUserData(u)
			call dispatch_Unit_addKnock(rocky, RockThrow_x[this_43], RockThrow_y[this_43])
			set Unit_lastKnocker[rocky] = unit_getUserData(RockThrow_u[this_43])
		endloop
		call group_close(wurst__iterator0)
		call DestroyGroup(RockThrow_g[this_43])
		call RemoveUnit(RockThrow_dummy[this_43])
		call timer_release(RockThrow_t[this_43])
	endif
	set wurst__iterator0 = null
	set u = null
endfunction

function dispatch_RockThrow_rockMove takes integer this_43 returns nothing
	if RockThrow_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling RockThrow.rockMove")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called RockThrow.rockMove on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call RockThrow_rockMove(this_43)
endfunction

function RockThrow_rockMoveCall takes nothing returns nothing
	local timer t = GetExpiredTimer()
	local integer i_2 = timer_getData(t)
	local integer tempObject = i_2
	call dispatch_RockThrow_rockMove(tempObject)
	set t = null
endfunction

function SamplePointSpell_callback takes integer this_43 returns nothing
endfunction

function dispatch_SamplePointSpell_callback takes integer this_43 returns nothing
	if SamplePointSpell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SamplePointSpell.callback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SamplePointSpell.callback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SamplePointSpell_callback(this_43)
endfunction

function SamplePointSpell_callCallback takes nothing returns nothing
	call dispatch_SamplePointSpell_callback(timer_getData(GetExpiredTimer()))
endfunction

function Shield_onExpire takes nothing returns nothing
	call dispatch_Shield_destroyShield(timer_getData(GetExpiredTimer()))
endfunction

function Spell_timedDisableCastDummy takes nothing returns nothing
	local timer t = GetExpiredTimer()
	local integer s = timer_getData(t)
	call SetPlayerAbilityAvailable(Unit_owner[Spell_owner[s]], Spell_castDummy[s], false)
	call timer_release(t)
	set t = null
	set t = null
endfunction

function Stun_onDestroy takes integer this_43 returns nothing
	call UnitRemoveAbility(Unit_u[Stun_u[this_43]], 1112560453)
	set Unit_stun[Stun_u[this_43]] = 0
	call timer_release(Stun_t[this_43])
endfunction

function dealloc_Stun takes integer obj returns nothing
	if Stun_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type Stun")
		call I2S(1 / 0)
	else
		set Stun_nextFree[Stun_lastFree] = obj
		set Stun_lastFree = obj
		if Stun_firstFree == 0 then
			set Stun_firstFree = obj
			set Stun_nextFree[obj] = 0
		endif
		set Stun_typeId[obj] = 0
	endif
endfunction

function destroyStun takes integer this_43 returns nothing
	call Stun_onDestroy(this_43)
	call dealloc_Stun(this_43)
endfunction

function dispatch_Stun_destroyStun takes integer this_43 returns nothing
	if Stun_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Stun.destroyStun")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Stun.destroyStun on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyStun(this_43)
endfunction

function Stun_destroyStun takes nothing returns nothing
	call dispatch_Stun_destroyStun(timer_getData(GetExpiredTimer()))
endfunction

function TestSpell1_bla takes nothing returns nothing
	call SetUnitAnimationByIndex(Unit_u[UnitClass_last], TestSpell1_animationType)
endfunction

function Hero_spellEnd takes integer this_43 returns nothing
	set Hero_acceptOrders[this_43] = true
	call dispatch_Hero_nextOrder(this_43)
endfunction

function dispatch_Hero_spellEnd takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.spellEnd")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.spellEnd on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_spellEnd(this_43)
endfunction

function TestSpell1_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_TestSpell1 takes integer obj returns nothing
	if TestSpell1_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type TestSpell1")
		call I2S(1 / 0)
	else
		set TestSpell1_nextFree[TestSpell1_lastFree] = obj
		set TestSpell1_lastFree = obj
		if TestSpell1_firstFree == 0 then
			set TestSpell1_firstFree = obj
			set TestSpell1_nextFree[obj] = 0
		endif
		set TestSpell1_typeId[obj] = 0
	endif
endfunction

function destroyTestSpell1 takes integer this_43 returns nothing
	call TestSpell1_onDestroy(this_43)
	call dealloc_TestSpell1(this_43)
endfunction

function dispatch_TestSpell1_destroyTestSpell1 takes integer this_43 returns nothing
	if TestSpell1_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TestSpell1.destroyTestSpell1")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TestSpell1.destroyTestSpell1 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyTestSpell1(this_43)
endfunction

function TestSpell1_callback takes integer this_43 returns nothing
	call ResetUnitAnimation(Unit_u[TestSpell1_caster[this_43]])
	call dispatch_Hero_spellEnd(TestSpell1_caster[this_43])
	call dispatch_TestSpell1_destroyTestSpell1(this_43)
endfunction

function dispatch_TestSpell1_callback takes integer this_43 returns nothing
	if TestSpell1_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TestSpell1.callback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TestSpell1.callback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TestSpell1_callback(this_43)
endfunction

function TestSpell1_callCallback takes nothing returns nothing
	call dispatch_TestSpell1_callback(timer_getData(GetExpiredTimer()))
endfunction

function TextTag_destroyTextTag takes nothing returns nothing
	call dispatch_TextTag_destroyTextTag(timer_getData(GetExpiredTimer()))
endfunction

function Trig_Unbezeichneter_Ausl__ser_003_Actions takes nothing returns nothing
	call CameraSetupApplyForPlayer(true, gg_cam_Camera_001, Player(0), 0.)
	call FogEnableOff()
	call FogMaskEnableOff()
endfunction

function Unit_makeVunerable takes integer this_43 returns nothing
	set Unit_vunerableCount[this_43] = Unit_vunerableCount[this_43] - 1
	if Unit_vunerableCount[this_43] <= 0 then
		set Unit_vunerable[this_43] = true
		set Unit_vunerableCount[this_43] = 0
	endif
endfunction

function dispatch_Unit_makeVunerable takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.makeVunerable")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.makeVunerable on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_makeVunerable(this_43)
	else
		call Unit_makeVunerable(this_43)
	endif
endfunction

function Unit_callMakeVunerable takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Unit_makeVunerable(timer_getData(t))
	call timer_release(t)
	set t = null
	set t = null
endfunction

function OnDamageData_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_OnDamageData takes integer obj returns nothing
	if OnDamageData_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type OnDamageData")
		call I2S(1 / 0)
	else
		set OnDamageData_nextFree[OnDamageData_lastFree] = obj
		set OnDamageData_lastFree = obj
		if OnDamageData_firstFree == 0 then
			set OnDamageData_firstFree = obj
			set OnDamageData_nextFree[obj] = 0
		endif
		set OnDamageData_typeId[obj] = 0
	endif
endfunction

function destroyOnDamageData takes integer this_43 returns nothing
	call OnDamageData_onDestroy(this_43)
	call dealloc_OnDamageData(this_43)
endfunction

function dispatch_OnDamageData_destroyOnDamageData takes integer this_43 returns nothing
	if OnDamageData_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling OnDamageData.destroyOnDamageData")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called OnDamageData.destroyOnDamageData on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyOnDamageData(this_43)
endfunction

function alloc_OnDamageData takes nothing returns integer
	local integer this_43
	if OnDamageData_firstFree == 0 then
		set OnDamageData_maxIndex = OnDamageData_maxIndex + 1
		set this_43 = OnDamageData_maxIndex
	else
		set this_43 = OnDamageData_firstFree
		set OnDamageData_firstFree = OnDamageData_nextFree[OnDamageData_firstFree]
		set OnDamageData_nextFree[this_43] = 0
	endif
	set OnDamageData_typeId[this_43] = 690
	return this_43
endfunction

function construct_OnDamageData takes integer this_43 returns nothing
	set OnDamageData_stop[this_43] = false
endfunction

function new_OnDamageData takes nothing returns integer
	local integer this_43 = alloc_OnDamageData()
	call construct_OnDamageData(this_43)
	return this_43
endfunction

function OnDamageEvent_fire takes integer this_43, integer source, real dmg returns real
	local integer data = new_OnDamageData()
	local real finalDmg
	set OnDamageData_source[data] = source
	set OnDamageData_target[data] = OnDamageEvent_target[this_43]
	set OnDamageData_damage[data] = dmg
	call Event_callActions(this_43, data)
	set finalDmg = OnDamageData_damage[data]
	call dispatch_OnDamageData_destroyOnDamageData(data)
	return finalDmg
endfunction

function dispatch_OnDamageEvent_fire takes integer this_43, integer source, real dmg returns real
	local real fire_result
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling OnDamageEvent.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called OnDamageEvent.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set fire_result = OnDamageEvent_fire(this_43, source, dmg)
	return fire_result
endfunction

function PreDamageData_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_PreDamageData takes integer obj returns nothing
	if PreDamageData_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type PreDamageData")
		call I2S(1 / 0)
	else
		set PreDamageData_nextFree[PreDamageData_lastFree] = obj
		set PreDamageData_lastFree = obj
		if PreDamageData_firstFree == 0 then
			set PreDamageData_firstFree = obj
			set PreDamageData_nextFree[obj] = 0
		endif
		set PreDamageData_typeId[obj] = 0
	endif
endfunction

function destroyPreDamageData takes integer this_43 returns nothing
	call PreDamageData_onDestroy(this_43)
	call dealloc_PreDamageData(this_43)
endfunction

function dispatch_PreDamageData_destroyPreDamageData takes integer this_43 returns nothing
	if PreDamageData_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling PreDamageData.destroyPreDamageData")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called PreDamageData.destroyPreDamageData on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyPreDamageData(this_43)
endfunction

function alloc_PreDamageData takes nothing returns integer
	local integer this_43
	if PreDamageData_firstFree == 0 then
		set PreDamageData_maxIndex = PreDamageData_maxIndex + 1
		set this_43 = PreDamageData_maxIndex
	else
		set this_43 = PreDamageData_firstFree
		set PreDamageData_firstFree = PreDamageData_nextFree[PreDamageData_firstFree]
		set PreDamageData_nextFree[this_43] = 0
	endif
	set PreDamageData_typeId[this_43] = 688
	return this_43
endfunction

function construct_PreDamageData takes integer this_43 returns nothing
endfunction

function new_PreDamageData takes nothing returns integer
	local integer this_43 = alloc_PreDamageData()
	call construct_PreDamageData(this_43)
	return this_43
endfunction

function PreDamageEvent_fire takes integer this_43, integer source returns nothing
	local integer data = new_PreDamageData()
	set PreDamageData_source[data] = source
	set PreDamageData_target[data] = PreDamageEvent_target[this_43]
	call Event_callActions(this_43, data)
	call dispatch_PreDamageData_destroyPreDamageData(data)
endfunction

function dispatch_PreDamageEvent_fire takes integer this_43, integer source returns nothing
	if Event_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling PreDamageEvent.fire")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called PreDamageEvent.fire on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call PreDamageEvent_fire(this_43, source)
endfunction

function Unit_critTT takes integer this_43, real dmg returns nothing
	local real tempAmount
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		if Unit_damageTT[this_43] == 0 then
			call new_TextTag(dmg, this_43, 255, 20, 20, 10., 0)
		else
			set tempAmount = TextTag_amount[Unit_damageTT[this_43]]
			call dispatch_TextTag_destroyTextTag(Unit_damageTT[this_43])
			call new_TextTag(dmg + tempAmount, this_43, 255, 20, 20, 10., 0)
		endif
	endif
endfunction

function dispatch_Unit_critTT takes integer this_43, real dmg returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.critTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.critTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_critTT(this_43, dmg)
	else
		call Unit_critTT(this_43, dmg)
	endif
endfunction

function Unit_absoluteTT takes integer this_43, real dmg returns nothing
	local real tempAmount
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		if Unit_damageTT[this_43] == 0 then
			call new_TextTag(dmg, this_43, 0, 0, 0, 9., 0)
		else
			set tempAmount = TextTag_amount[Unit_damageTT[this_43]]
			call dispatch_TextTag_destroyTextTag(Unit_damageTT[this_43])
			call new_TextTag(dmg + tempAmount, this_43, 0, 0, 0, 9., 0)
		endif
	endif
endfunction

function dispatch_Unit_absoluteTT takes integer this_43, real dmg returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.absoluteTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.absoluteTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_absoluteTT(this_43, dmg)
	else
		call Unit_absoluteTT(this_43, dmg)
	endif
endfunction

function Unit_damageAbs takes integer this_43, integer source, real amount_39 returns nothing
	if dispatch_Unit_dealDamage(this_43, amount_39, source) then
		call dispatch_Unit_absoluteTT(this_43, amount_39)
	endif
endfunction

function dispatch_Unit_damageAbs takes integer this_43, integer source, real amount_39 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.damageAbs")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.damageAbs on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_damageAbs(this_43, source, amount_39)
	else
		call Unit_damageAbs(this_43, source, amount_39)
	endif
endfunction

function Unit_dodgeTT takes integer this_43 returns nothing
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		call new_TextTag(0., this_43, 0, 255, 128, 8., 4)
	endif
endfunction

function dispatch_Unit_dodgeTT takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.dodgeTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.dodgeTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_dodgeTT(this_43)
	else
		call Unit_dodgeTT(this_43)
	endif
endfunction

function Unit_getArmor takes integer this_43, boolean withBonus returns real
	if withBonus then
		return (Unit_armor[this_43] + Unit_bonusArmor[this_43]) * (1. + Unit_bonusArmorPer[this_43] / 100.)
	else
		return Unit_armor[this_43]
	endif
endfunction

function dispatch_Unit_getArmor takes integer this_43, boolean withBonus returns real
	local real getArmor_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.getArmor")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.getArmor on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set getArmor_result = Unit_getArmor(this_43, withBonus)
	else
		set getArmor_result = Unit_getArmor(this_43, withBonus)
	endif
	return getArmor_result
endfunction

function Unit_getAttack takes integer this_43, boolean withBonus returns real
	if withBonus then
		return (Unit_attack[this_43] + Unit_bonusAttack[this_43]) * (1. + Unit_bonusAttackPer[this_43] / 100.)
	else
		return Unit_attack[this_43]
	endif
endfunction

function dispatch_Unit_getAttack takes integer this_43, boolean withBonus returns real
	local real getAttack_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.getAttack")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.getAttack on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set getAttack_result = Unit_getAttack(this_43, withBonus)
	else
		set getAttack_result = Unit_getAttack(this_43, withBonus)
	endif
	return getAttack_result
endfunction

function Unit_missTT takes integer this_43 returns nothing
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		call new_TextTag(0., this_43, 0, 255, 255, 8., 3)
	endif
endfunction

function dispatch_Unit_missTT takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.missTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.missTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_missTT(this_43)
	else
		call Unit_missTT(this_43)
	endif
endfunction

function Unit_normalTT takes integer this_43, real dmg returns nothing
	local real tempAmount
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		if Unit_damageTT[this_43] == 0 then
			call new_TextTag(dmg, this_43, 255, 50, 50, 10., 0)
		else
			set tempAmount = TextTag_amount[Unit_damageTT[this_43]]
			call dispatch_TextTag_destroyTextTag(Unit_damageTT[this_43])
			call new_TextTag(dmg + tempAmount, this_43, 255, 50, 50, 9., 0)
		endif
	endif
endfunction

function dispatch_Unit_normalTT takes integer this_43, real dmg returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.normalTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.normalTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_normalTT(this_43, dmg)
	else
		call Unit_normalTT(this_43, dmg)
	endif
endfunction

function Unit_damageAtk takes integer this_43, integer source returns nothing
	local real rand = GetRandomReal(0., 100.)
	local real amount_39
	local boolean crit
	local real tempArmor
	call dispatch_PreDamageEvent_fire(Unit_takeHitPre[this_43], source)
	call dispatch_PreDamageEvent_fire(Unit_causeHitPre[source], this_43)
	if rand <= Unit_hitchance[source] then
		set rand = GetRandomReal(0., 100.)
		if rand > Unit_evade[this_43] then
			set rand = GetRandomReal(0., 100.)
			set amount_39 = dispatch_Unit_getAttack(source, true) + GetRandomReal( - (dispatch_Unit_getAttack(source, true) / 10.), dispatch_Unit_getAttack(source, true) / 10.)
			set crit = false
			set rand = GetRandomReal(0., 100.)
			if rand <= Unit_critchance[source] then
				set amount_39 = amount_39 * (2. + Unit_critdamage[source] / 100.)
				set crit = true
			endif
			set amount_39 = amount_39 * (1. + Unit_bonusDamage[source])
			set tempArmor = dispatch_Unit_getArmor(this_43, true)
			if tempArmor < 0. then
				set amount_39 = amount_39 * (1. + (2. - Pow(0.94,  - tempArmor)))
			else
				set amount_39 = amount_39 * (1. - tempArmor * 0.04 / (1. + 0.04 * tempArmor))
			endif
			set amount_39 = amount_39 * (1. - Unit_normalReduction[this_43] / 100.)
			if Unit_takeHitOn[this_43] != 0 then
				set amount_39 = dispatch_OnDamageEvent_fire(Unit_takeHitOn[this_43], source, amount_39)
			endif
			if Unit_causeHitOn[source] != 0 then
				set amount_39 = dispatch_OnDamageEvent_fire(Unit_causeHitOn[source], this_43, amount_39)
			endif
			if crit then
				if Unit_takeCritHitOn[this_43] != 0 then
					set amount_39 = dispatch_OnDamageEvent_fire(Unit_takeCritHitOn[this_43], source, amount_39)
				endif
				if Unit_causeCritHitOn[source] != 0 then
					set amount_39 = dispatch_OnDamageEvent_fire(Unit_causeCritHitOn[source], this_43, amount_39)
				endif
			endif
			if dispatch_Unit_dealDamage(this_43, amount_39, source) then
				if Unit_isHero[this_43] or Unit_isHero[source] then
					if crit then
						call dispatch_Unit_critTT(this_43, amount_39)
					else
						call dispatch_Unit_normalTT(this_43, amount_39)
					endif
				endif
			endif
			if amount_39 > 0. and Unit_normalDeflection[this_43] > 0. then
				call dispatch_Unit_damageAbs(source, this_43, amount_39 * (Unit_normalDeflection[this_43] / 100.))
			endif
		else
			if Unit_isHero[this_43] or Unit_isHero[source] then
				call dispatch_Unit_dodgeTT(this_43)
			endif
			if Unit_onDodge[this_43] != 0 then
				call dispatch_Unit2Event_fire(Unit_onDodge[this_43], source, this_43)
			endif
		endif
	else
		if Unit_isHero[this_43] or Unit_isHero[source] then
			call dispatch_Unit_missTT(source)
		endif
		if Unit_onMiss[source] != 0 then
			call dispatch_Unit2Event_fire(Unit_onMiss[source], source, this_43)
		endif
	endif
endfunction

function dispatch_Unit_damageAtk takes integer this_43, integer source returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.damageAtk")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.damageAtk on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_damageAtk(this_43, source)
	else
		call Unit_damageAtk(this_43, source)
	endif
endfunction

function Unit_tookDamage takes nothing returns nothing
	if GetEventDamage() == 1. then
		call dispatch_Unit_damageAtk(unit_getUserData(GetTriggerUnit()), unit_getUserData(GetEventDamageSource()))
	endif
endfunction

function getHandleCount takes nothing returns integer
	local integer next = 0
	local integer prevIndex = 0
	local integer index = 0
	local integer a = 0
	local location array loc
	loop
		exitwhen  not (next < HandleCounter_stackEndTreshold)
		set loc[a] = Location(0., 0.)
		set index = GetHandleId(loc[a]) - 1048576
		set a = a + 1
		if index == prevIndex + 1 then
			set next = next + 1
		else
			set next = 0
		endif
		set prevIndex = index
	endloop
	set index = index - a
	loop
		exitwhen  not (a > 0)
		set a = a - 1
		call RemoveLocation(loc[a])
		set loc[a] = null
	endloop
	if index > HandleCounter_maxHandleCount then
		set HandleCounter_maxHandleCount = index
	endif
	return index
endfunction

function getMaxHandleCount takes nothing returns integer
	call getHandleCount()
	return HandleCounter_maxHandleCount
endfunction

function getTime takes nothing returns integer
	return HandleCounter_seconds
endfunction

function actions takes nothing returns nothing
	set HandleCounter_board = CreateLeaderboard()
	call LeaderboardSetLabel(HandleCounter_board, HandleCounter_TITLE)
	call PlayerSetLeaderboard(GetLocalPlayer(), HandleCounter_board)
	call LeaderboardDisplay(HandleCounter_board, true)
	call LeaderboardAddItem(HandleCounter_board, HandleCounter_HANDLE_TEXT, 0, HandleCounter_HANDLE)
	call LeaderboardSetItemValue(HandleCounter_board, 0, getHandleCount())
	call LeaderboardAddItem(HandleCounter_board, HandleCounter_MAX_HANDLE_TEXT, 1, HandleCounter_MAX_HANDLE)
	call LeaderboardSetItemValue(HandleCounter_board, 1, getMaxHandleCount())
	call LeaderboardAddItem(HandleCounter_board, HandleCounter_TIME_TEXT, 2, HandleCounter_TIME)
	call LeaderboardSetItemValue(HandleCounter_board, 2, getTime())
	call LeaderboardSetSizeByItemCount(HandleCounter_board, 3)
	call TimerStart(GetExpiredTimer(), HandleCounter_updatePeriod, true, ref_function_callback)
endfunction

function TIterator_onDestroy takes integer this_43 returns nothing
endfunction

function dealloc_TIterator takes integer obj returns nothing
	if TIterator_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type TIterator")
		call I2S(1 / 0)
	else
		set TIterator_nextFree[TIterator_lastFree] = obj
		set TIterator_lastFree = obj
		if TIterator_firstFree == 0 then
			set TIterator_firstFree = obj
			set TIterator_nextFree[obj] = 0
		endif
		set TIterator_typeId[obj] = 0
	endif
endfunction

function destroyTIterator takes integer this_43 returns nothing
	call TIterator_onDestroy(this_43)
	call dealloc_TIterator(this_43)
endfunction

function dispatch_TIterator_destroyTIterator takes integer this_43 returns nothing
	if TIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TIterator.destroyTIterator")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TIterator.destroyTIterator on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyTIterator(this_43)
endfunction

function TIterator_close takes integer this_43 returns nothing
	call dispatch_TIterator_destroyTIterator(this_43)
endfunction

function dispatch_TIterator_close takes integer this_43 returns nothing
	if TIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TIterator.close")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TIterator.close on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call TIterator_close(this_43)
endfunction

function TIterator_hasNext takes integer this_43 returns boolean
	return TIterator_pos[this_43] < dispatch_TList_getSize(TIterator_list[this_43]) - 1
endfunction

function dispatch_TIterator_hasNext takes integer this_43 returns boolean
	local boolean hasNext_result
	if TIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TIterator.hasNext")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TIterator.hasNext on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set hasNext_result = TIterator_hasNext(this_43)
	return hasNext_result
endfunction

function TIterator_next takes integer this_43 returns integer
	set TIterator_pos[this_43] = TIterator_pos[this_43] + 1
	return dispatch_TList_get(TIterator_list[this_43], TIterator_pos[this_43])
endfunction

function dispatch_TIterator_next takes integer this_43 returns integer
	local integer next_result
	if TIterator_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TIterator.next")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TIterator.next on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set next_result = TIterator_next(this_43)
	return next_result
endfunction

function alloc_TIterator takes nothing returns integer
	local integer this_43
	if TIterator_firstFree == 0 then
		set TIterator_maxIndex = TIterator_maxIndex + 1
		set this_43 = TIterator_maxIndex
	else
		set this_43 = TIterator_firstFree
		set TIterator_firstFree = TIterator_nextFree[TIterator_firstFree]
		set TIterator_nextFree[this_43] = 0
	endif
	set TIterator_typeId[this_43] = 13
	return this_43
endfunction

function construct_TIterator takes integer this_43, integer list returns nothing
	set TIterator_pos[this_43] = -1
	set TIterator_list[this_43] = list
endfunction

function new_TIterator takes integer list returns integer
	local integer this_43 = alloc_TIterator()
	call construct_TIterator(this_43, list)
	return this_43
endfunction

function TList_iterator takes integer this_43 returns integer
	return new_TIterator(this_43)
endfunction

function dispatch_TList_iterator takes integer this_43 returns integer
	local integer iterator_result
	if TList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling TList.iterator")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called TList.iterator on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set iterator_result = TList_iterator(this_43)
	return iterator_result
endfunction

function Unit_setKnock takes integer this_43, real x, real y returns nothing
	set Unit_wallLocX[this_43] = 0.
	set Unit_wallLocY[this_43] = 0.
	set Unit_knockX[this_43] = x
	set Unit_knockY[this_43] = y
	if  not Unit_hasKnockback[this_43] then
		set Unit_hasKnockback[this_43] = true
		call dispatch_TList_add(UnitClass_knocklist, this_43)
	endif
	set Unit_lastCollision[this_43] = 0
endfunction

function dispatch_Unit_setKnock takes integer this_43, real x, real y returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.setKnock")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.setKnock on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_setKnock(this_43, x, y)
	else
		call Unit_setKnock(this_43, x, y)
	endif
endfunction

function vec2_dot takes real this_x, real this_y, real v_x, real v_y returns real
	return this_x * v_x + this_y * v_y
endfunction

function vec2_length takes real this_x, real this_y returns real
	return SquareRoot(this_x * this_x + this_y * this_y)
endfunction

function vec2_op_mult takes real this_x, real this_y, real factor returns real
	set vec2_op_mult_return_x = this_x * factor
	set vec2_op_mult_return_y = this_y * factor
	return vec2_op_mult_return_x
endfunction

function Unit_collision takes integer this_43, integer otherUnit returns nothing
	local real pos1_x
	local real pos1_y
	local real pos2_x
	local real pos2_y
	local real vel1_x
	local real vel1_y
	local real vel2_x
	local real vel2_y
	local real delta_x
	local real delta_y
	local real deltaLen
	local real deltaNorm_x
	local real deltaNorm_y
	local real speed1central
	local real speed2central
	local real intersectionWidth
	local real futurePos1_x
	local real futurePos1_y
	local real futurePos2_x
	local real futurePos2_y
	local real futureDelta_x
	local real futureDelta_y
	local real vel1central_x
	local real vel1central_y
	local real vel1orthogonal_x
	local real vel1orthogonal_y
	local real vel2central_x
	local real vel2central_y
	local real vel2orthogonal_x
	local real vel2orthogonal_y
	set Unit_lastCollision[this_43] = otherUnit
	set Unit_lastCollision[otherUnit] = this_43
	if  not IsUnitAlly(Unit_u[otherUnit], Unit_owner[this_43]) then
		set Unit_lastKnocker[otherUnit] = Unit_lastKnocker[this_43]
	endif
	set pos1_x = unit_getX(Unit_u[this_43])
	set pos1_y = unit_getY(Unit_u[this_43])
	set pos2_x = unit_getX(Unit_u[otherUnit])
	set pos2_y = unit_getY(Unit_u[otherUnit])
	set vel1_x = Unit_knockX[this_43]
	set vel1_y = Unit_knockY[this_43]
	set vel2_x = Unit_knockX[otherUnit]
	set vel2_y = Unit_knockY[otherUnit]
	set delta_x = vec2_op_minus(pos2_x, pos2_y, pos1_x, pos1_y)
	set delta_y = vec2_op_minus_return_y
	set deltaLen = vec2_length(delta_x, delta_y)
	if deltaLen == 0. then
		set deltaNorm_x = 0.
		set deltaNorm_y = 1.
	else
		set deltaNorm_x = vec2_op_mult(delta_x, delta_y, 1. / deltaLen)
		set deltaNorm_y = vec2_op_mult_return_y
	endif
	set speed1central = vec2_dot(vel1_x, vel1_y, deltaNorm_x, deltaNorm_y)
	set speed2central = vec2_dot(vel2_x, vel2_y, deltaNorm_x, deltaNorm_y)
	set intersectionWidth = Unit_radius[this_43] + Unit_radius[otherUnit] - deltaLen
	set futurePos1_x = vec2_op_plus(pos1_x, pos1_y, vec2_op_mult(vel1_x, vel1_y, 0.01), vec2_op_mult_return_y)
	set futurePos1_y = vec2_op_plus_return_y
	set futurePos2_x = vec2_op_plus(pos2_x, pos2_y, vec2_op_mult(vel2_x, vel2_y, 0.01), vec2_op_mult_return_y)
	set futurePos2_y = vec2_op_plus_return_y
	set futureDelta_x = vec2_op_minus(futurePos2_x, futurePos2_y, futurePos1_x, futurePos1_y)
	set futureDelta_y = vec2_op_minus_return_y
	if vec2_length(futureDelta_x, futureDelta_y) < deltaLen then
		set vel1central_x = vec2_op_mult(deltaNorm_x, deltaNorm_y, speed1central)
		set vel1central_y = vec2_op_mult_return_y
		set vel1orthogonal_x = vec2_op_minus(vel1_x, vel1_y, vel1central_x, vel1central_y)
		set vel1orthogonal_y = vec2_op_minus_return_y
		set vel2central_x = vec2_op_mult(deltaNorm_x, deltaNorm_y, speed2central)
		set vel2central_y = vec2_op_mult_return_y
		set vel2orthogonal_x = vec2_op_minus(vel2_x, vel2_y, vel2central_x, vel2central_y)
		set vel2orthogonal_y = vec2_op_minus_return_y
		set vel1_x = vec2_op_plus(vel1_x, vel1_y, vec2_op_mult(vec2_op_minus(vel2central_x, vel2central_y, vel1central_x, vel1central_y), vec2_op_minus_return_y, Unit_bounceFactor), vec2_op_mult_return_y)
		set vel1_y = vec2_op_plus_return_y
		set vel2_x = vec2_op_plus(vel2_x, vel2_y, vec2_op_mult(vec2_op_minus(vel1central_x, vel1central_y, vel2central_x, vel2central_y), vec2_op_minus_return_y, Unit_bounceFactor), vec2_op_mult_return_y)
		set vel2_y = vec2_op_plus_return_y
		call dispatch_Unit_setKnock(this_43, vel1_x, vel1_y)
		call dispatch_Unit_setKnock(otherUnit, vel2_x, vel2_y)
	endif
endfunction

function dispatch_Unit_collision takes integer this_43, integer otherUnit returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.collision")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.collision on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_collision(this_43, otherUnit)
	else
		call Unit_collision(this_43, otherUnit)
	endif
endfunction

function vec3_project takes real this_x, real this_y, real this_z, real direction_x, real direction_y, real direction_z returns real
	local real l = direction_x * direction_x + direction_y * direction_y + direction_z * direction_z
	if l == 0.0 then
		call printError("vector.projectVector error: The length of the direction vector is 0.0!")
		set vec3_project_return_x = 0.
		set vec3_project_return_y = 0.
		set vec3_project_return_z = 0.
		return vec3_project_return_x
	endif
	set l = (this_x * direction_x + this_y * direction_y + this_z * direction_z) / l
	set vec3_project_return_x = direction_x * l
	set vec3_project_return_y = direction_y * l
	set vec3_project_return_z = direction_z * l
	return vec3_project_return_x
endfunction

function getBounceVec takes real vel2_x, real vel2_y, real nor2_x, real nor2_y returns real
	local real vel3_x = vec2_toVec3(vel2_x, vel2_y)
	local real vel3_y = vec2_toVec3_return_y
	local real vel3_z = vec2_toVec3_return_z
	local real nor3_x = vec2_toVec3(nor2_x, nor2_y)
	local real nor3_y = vec2_toVec3_return_y
	local real nor3_z = vec2_toVec3_return_z
	local real pv3_x = vec3_project(vel3_x, vel3_y, vel3_z, nor3_x, nor3_y, nor3_z)
	local real pv3_y = vec3_project_return_y
	local real pv3_z = vec3_project_return_z
	local real pv2_x = vec3_toVec2(pv3_x, pv3_y, pv3_z)
	local real pv2_y = vec3_toVec2_return_y
	local real nvel2_x
	local real nvel2_y
	set pv2_x = vec2_op_mult(pv2_x, pv2_y,  - 2.)
	set pv2_y = vec2_op_mult_return_y
	set nvel2_x = vel2_x
	set nvel2_y = vel2_y
	set nvel2_x = vec2_op_plus(nvel2_x, nvel2_y, pv2_x, pv2_y)
	set nvel2_y = vec2_op_plus_return_y
	set getBounceVec_return_x = nvel2_x
	set getBounceVec_return_y = nvel2_y
	return getBounceVec_return_x
endfunction

function vec2_setLength takes real this_x, real this_y, real length returns real
	local real l = SquareRoot(this_x * this_x + this_y * this_y)
	if l == 0.0 then
		call printError("vector.setLength error: The length of the vector is 0.0!")
		set vec2_setLength_return_x = 0.
		set vec2_setLength_return_y = 0.
		return vec2_setLength_return_x
	endif
	set l = length / l
	set vec2_setLength_return_x = this_x * l
	set vec2_setLength_return_y = this_y * l
	return vec2_setLength_return_x
endfunction

function getPathingNormal takes real pos_x, real pos_y returns real
	local integer numberOfTests = 60
	local real radius = 64.
	local real addedVecs_x = 0.
	local real addedVecs_y = 0.
	local integer i_2 = 1
	local integer temp = numberOfTests
	local real direction_x
	local real direction_y
	local real testPoint_x
	local real testPoint_y
	loop
		exitwhen i_2 > temp
		set direction_x = vec2_polarOffset(0., 0., real_asAngleRadians(i_2 * 2 * bj_PI / numberOfTests), radius)
		set direction_y = vec2_polarOffset_return_y
		set testPoint_x = vec2_op_plus(pos_x, pos_y, direction_x, direction_y)
		set testPoint_y = vec2_op_plus_return_y
		if isTerrainWalkable(testPoint_x, testPoint_y) then
			set addedVecs_x = vec2_op_plus(addedVecs_x, addedVecs_y, direction_x, direction_y)
			set addedVecs_y = vec2_op_plus_return_y
		endif
		set i_2 = i_2 + 1
	endloop
	set getPathingNormal_return_x = vec2_op_mult(vec2_setLength(addedVecs_x, addedVecs_y, 1.), vec2_setLength_return_y,  - 1.)
	set getPathingNormal_return_y = vec2_op_mult_return_y
	return getPathingNormal_return_x
endfunction

function unit_setX takes unit this_43, real x returns unit
	call SetUnitX(this_43, x)
	return this_43
endfunction

function unit_setY takes unit this_43, real y returns unit
	call SetUnitY(this_43, y)
	return this_43
endfunction

function Unit_knockback takes integer this_43 returns nothing
	local real x
	local real y
	local group g
	local integer u2
	local real ox
	local real oy
	local real speed
	local real nor_x
	local real nor_y
	local real vel_x
	local real vel_y
	local real nvel_x
	local real nvel_y
	local real nx
	local real ny
	if RAbsBJ(Unit_knockX[this_43]) <= 0.5 and RAbsBJ(Unit_knockY[this_43]) <= 0.5 then
		call dispatch_TList_remove(UnitClass_knocklist, this_43)
		set Unit_hasKnockback[this_43] = false
		set Unit_knockX[this_43] = 0.
		set Unit_knockY[this_43] = 0.
	else
		set x = unit_getX(Unit_u[this_43])
		set y = unit_getY(Unit_u[this_43])
		if isTerrainWalkable(x, y) == true or IsUnitInRangeXY(Unit_u[this_43], Unit_wallLocX[this_43], Unit_wallLocY[this_43], 30.) == true then
			set g = CreateGroup()
			set Filter_filterCheckUnit = Unit_u[this_43]
			call GroupEnumUnitsInRange(g, x, y, Unit_radius[this_43], Condition(ref_function_notUnit))
			if FirstOfGroup(g) == null then
				set x = x + Unit_knockX[this_43]
				set y = y + Unit_knockY[this_43]
				call unit_setX(Unit_u[this_43], x)
				call unit_setY(Unit_u[this_43], y)
				set Unit_knockX[this_43] = Unit_knockX[this_43] - Unit_knockX[this_43] * (Unit_mass[this_43] / Unit_knockbackFactor)
				set Unit_knockY[this_43] = Unit_knockY[this_43] - Unit_knockY[this_43] * (Unit_mass[this_43] / 5000.)
			else
				set u2 = unit_getUserData(FirstOfGroup(g))
				if  not (u2 == Unit_lastCollision[this_43]) then
					call dispatch_Unit_collision(this_43, u2)
					set x = x + Unit_knockX[this_43]
					set y = y + Unit_knockY[this_43]
					call unit_setX(Unit_u[this_43], x)
					call unit_setY(Unit_u[this_43], y)
					set Unit_knockX[this_43] = Unit_knockX[this_43] - Unit_knockX[this_43] * (Unit_mass[this_43] / Unit_knockbackFactor)
					set Unit_knockY[this_43] = Unit_knockY[this_43] - Unit_knockY[this_43] * (Unit_mass[this_43] / Unit_knockbackFactor)
					set ox = unit_getX(Unit_u[u2])
					set oy = unit_getY(Unit_u[u2])
					set ox = ox + Unit_knockX[u2]
					set oy = oy + Unit_knockY[u2]
					call unit_setX(Unit_u[u2], ox)
					call unit_setY(Unit_u[u2], oy)
					set Unit_knockX[u2] = Unit_knockX[u2] - Unit_knockX[u2] * (Unit_mass[u2] / Unit_knockbackFactor)
					set Unit_knockY[u2] = Unit_knockY[u2] - Unit_knockY[u2] * (Unit_mass[u2] / Unit_knockbackFactor)
				else
					set x = x + Unit_knockX[this_43]
					set y = y + Unit_knockY[this_43]
					call unit_setX(Unit_u[this_43], x)
					call unit_setY(Unit_u[this_43], y)
					set Unit_knockX[this_43] = Unit_knockX[this_43] - Unit_knockX[this_43] * (Unit_mass[this_43] / Unit_knockbackFactor)
					set Unit_knockY[this_43] = Unit_knockY[this_43] - Unit_knockY[this_43] * (Unit_mass[this_43] / Unit_knockbackFactor)
				endif
			endif
			call DestroyGroup(g)
			set g = null
		else
			set Unit_wallLocX[this_43] = x
			set Unit_wallLocY[this_43] = y
			set speed = RAbsBJ(Unit_knockX[this_43]) + RAbsBJ(Unit_knockY[this_43])
			call dispatch_Unit_damageAbs(this_43, Unit_lastKnocker[this_43], unit_getState(Unit_u[this_43], UNIT_STATE_MAX_LIFE) * (speed / 200.))
			set nor_x = getPathingNormal(x, y)
			set nor_y = getPathingNormal_return_y
			set vel_x = Unit_knockX[this_43]
			set vel_y = Unit_knockY[this_43]
			set nvel_x = getBounceVec(vel_x, vel_y, nor_x, nor_y)
			set nvel_y = getBounceVec_return_y
			set nx = nvel_x
			set ny = nvel_y
			set x = x + nx
			set y = y + ny
			call unit_setX(Unit_u[this_43], x)
			call unit_setY(Unit_u[this_43], y)
			set Unit_knockX[this_43] = nx - nx * (Unit_mass[this_43] / 5000.)
			set Unit_knockY[this_43] = ny - ny * (Unit_mass[this_43] / 5000.)
			set Unit_lastCollision[this_43] = 0
		endif
	endif
	set g = null
endfunction

function dispatch_Unit_knockback takes integer this_43 returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.knockback")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.knockback on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_knockback(this_43)
	else
		call Unit_knockback(this_43)
	endif
endfunction

function callKnockback takes nothing returns nothing
	local integer wurst__iterator0 = dispatch_TList_iterator(UnitClass_knocklist)
	local integer obj
	loop
		exitwhen  not dispatch_TIterator_hasNext(wurst__iterator0)
		set obj = dispatch_TIterator_next(wurst__iterator0)
		call dispatch_Unit_knockback(obj)
	endloop
	call dispatch_TIterator_close(wurst__iterator0)
endfunction

function callback takes nothing returns nothing
	call LeaderboardSetItemValue(HandleCounter_board, 0, getHandleCount())
	call LeaderboardSetItemValue(HandleCounter_board, 1, getTime())
endfunction

function Unit_manaTT takes integer this_43, real dmg returns nothing
	local real tempAmount
	if IsVisibleToPlayer(unit_getX(Unit_u[this_43]), unit_getY(Unit_u[this_43]), GetLocalPlayer()) then
		if Unit_healTT[this_43] == 0 then
			call new_TextTag(dmg, this_43, 80, 255, 80, 9., 1)
		else
			set tempAmount = TextTag_amount[Unit_healTT[this_43]]
			call dispatch_TextTag_destroyTextTag(Unit_healTT[this_43])
			call new_TextTag(dmg + tempAmount, this_43, 80, 255, 80, 9., 1)
		endif
	endif
endfunction

function dispatch_Unit_manaTT takes integer this_43, real dmg returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.manaTT")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.manaTT on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		call Unit_manaTT(this_43, dmg)
	else
		call Unit_manaTT(this_43, dmg)
	endif
endfunction

function camTest takes nothing returns nothing
	call dispatch_Unit_manaTT(UnitClass_last, 1.)
	call dispatch_Unit_dodgeTT(UnitClass_last)
	call dispatch_Unit_goldTT(UnitClass_last, 1., Player(0))
	call dispatch_Unit_normalTT(UnitClass_last, 1.)
endfunction

function cdt takes nothing returns nothing
	set Cooldown_count = Cooldown_count - 1
	if Cooldown_count >= 10 then
		if ModuloInteger(Cooldown_count, 10) == 0 then
			call unit_removeAbility(Unit_u[UnitClass_last], Cooldown_lastAbi)
			call unit_addAbility(Unit_u[UnitClass_last], Cooldown_cdIcon[Cooldown_count])
			set Cooldown_lastAbi = Cooldown_cdIcon[Cooldown_count]
		endif
	elseif Cooldown_count == 0 then
		call unit_removeAbility(Unit_u[UnitClass_last], Cooldown_lastAbi)
		call SetPlayerAbilityAvailable(Unit_owner[UnitClass_last], 1702390132, true)
		set Cooldown_lastAbi = 0
		set Cooldown_count = 100
		call timer_release(GetExpiredTimer())
	else
		call unit_removeAbility(Unit_u[UnitClass_last], Cooldown_lastAbi)
		call unit_addAbility(Unit_u[UnitClass_last], Cooldown_cdIcon[Cooldown_count])
		set Cooldown_lastAbi = Cooldown_cdIcon[Cooldown_count]
	endif
endfunction

function charMessung takes nothing returns nothing
endfunction

function LinkedListModule_remove_2 takes integer this_43 returns nothing
	set LinkedListModule_size_3 = LinkedListModule_size_3 - 1
	if this_43 != LinkedListModule_first_3 then
		set LinkedListModule_next_3[LinkedListModule_prev_3[this_43]] = LinkedListModule_next_3[this_43]
	endif
	if this_43 != LinkedListModule_last_3 then
		set LinkedListModule_prev_3[LinkedListModule_next_3[this_43]] = LinkedListModule_prev_3[this_43]
	endif
	if this_43 == LinkedListModule_last_3 then
		set LinkedListModule_last_3 = LinkedListModule_prev_3[this_43]
	endif
	if this_43 == LinkedListModule_first_3 then
		set LinkedListModule_first_3 = LinkedListModule_next_3[this_43]
	endif
endfunction

function dispatch_DelayData_remove takes integer this_43 returns nothing
	if DelayData_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling DelayData.remove")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called DelayData.remove on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call LinkedListModule_remove_2(this_43)
endfunction

function DelayData_onDestroy takes integer this_43 returns nothing
	call dispatch_DelayData_remove(this_43)
endfunction

function dealloc_DelayData takes integer obj returns nothing
	if DelayData_typeId[obj] == 0 then
		call BJDebugMsg("Double free: object of type DelayData")
		call I2S(1 / 0)
	else
		set DelayData_nextFree[DelayData_lastFree] = obj
		set DelayData_lastFree = obj
		if DelayData_firstFree == 0 then
			set DelayData_firstFree = obj
			set DelayData_nextFree[obj] = 0
		endif
		set DelayData_typeId[obj] = 0
	endif
endfunction

function destroyDelayData takes integer this_43 returns nothing
	call DelayData_onDestroy(this_43)
	call dealloc_DelayData(this_43)
endfunction

function dispatch_DelayData_destroyDelayData takes integer this_43 returns nothing
	if DelayData_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling DelayData.destroyDelayData")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called DelayData.destroyDelayData on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call destroyDelayData(this_43)
endfunction

function checkDelayed takes nothing returns nothing
	local integer data = LinkedListModule_first_3
	loop
		exitwhen  not (data != 0)
		set DelayData_dT[data] = DelayData_dT[data] -  .1
		if DelayData_dT[data] <= 0. then
			call recycleDummy(DelayData_dum[data])
			call dispatch_DelayData_destroyDelayData(data)
		endif
		set data = LinkedListModule_next_3[data]
	endloop
endfunction

function multiboard_display takes multiboard this_43, boolean show returns multiboard
	call MultiboardDisplay(this_43, show)
	return this_43
endfunction

function multiboard_setColumnCount takes multiboard this_43, integer count returns multiboard
	call MultiboardSetColumnCount(this_43, count)
	return this_43
endfunction

function multiboard_setItemsStyle takes multiboard this_43, boolean showValues, boolean showIcons returns multiboard
	call MultiboardSetItemsStyle(this_43, showValues, showIcons)
	return this_43
endfunction

function multiboard_setItemsWidth takes multiboard this_43, real width returns multiboard
	call MultiboardSetItemsWidth(this_43, width)
	return this_43
endfunction

function multiboard_setRowCount takes multiboard this_43, integer count returns multiboard
	call MultiboardSetRowCount(this_43, count)
	return this_43
endfunction

function multiboard_setTitle takes multiboard this_43, string label returns multiboard
	call MultiboardSetTitleText(this_43, label)
	return this_43
endfunction

function createMultiboard takes nothing returns nothing
	local multiboarditem mbi
	local integer i_2
	local integer temp
	local string s
	set InstanceBoard_mb = CreateMultiboard()
	call multiboard_setColumnCount(InstanceBoard_mb, 2)
	call multiboard_setRowCount(InstanceBoard_mb, InstanceBoard_classes + 1)
	call multiboard_setItemsStyle(InstanceBoard_mb, true, false)
	call multiboard_setItemsWidth(InstanceBoard_mb, 0.10)
	call multiboard_setTitle(InstanceBoard_mb, "Instance Board")
	set mbi = multiboard_getItem(InstanceBoard_mb, 0, 0)
	call multiboarditem_setValue(mbi, "ClassName")
	set mbi = multiboard_getItem(InstanceBoard_mb, 0, 1)
	call multiboarditem_setValue(mbi, "Instance count")
	set i_2 = 1
	set temp = InstanceBoard_classes
	loop
		exitwhen i_2 > temp
		set s = InstanceBoard_nameOfClass[i_2]
		if s != null then
			set mbi = multiboard_getItem(InstanceBoard_mb, i_2, 0)
			call multiboarditem_setValue(mbi, s)
			set mbi = multiboard_getItem(InstanceBoard_mb, i_2, 1)
			call multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[i_2]))
		endif
		set i_2 = i_2 + 1
	endloop
	call multiboard_display(InstanceBoard_mb, true)
	set mbi = null
endfunction

function hashtable_loadEffectHandle takes hashtable this_43, integer parentKey, integer childKey returns effect
	return LoadEffectHandle(this_43, parentKey, childKey)
endfunction

function Table_loadEffect takes integer this_43, integer parentKey returns effect
	return hashtable_loadEffectHandle(Table_ht, this_43, parentKey)
endfunction

function dispatch_Table_loadEffect takes integer this_43, integer parentKey returns effect
	local effect loadEffect_result
	if Table_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Table.loadEffect")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Table.loadEffect on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set loadEffect_result = Table_loadEffect(this_43, parentKey)
	set dispatch_Table_loadEffecttempReturn = loadEffect_result
	set loadEffect_result = null
	return dispatch_Table_loadEffecttempReturn
endfunction

function destroyTimedEffect takes nothing returns nothing
	call effect_destr(dispatch_Table_loadEffect(TimedEffect_effectData, GetHandleId(GetExpiredTimer())))
endfunction

function destroyTimedFx takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call dispatch_Fx_destroyFx(timer_getData(t))
	call timer_release(t)
	set t = null
endfunction

function trigger_execute takes trigger this_43 returns trigger
	call TriggerExecute(this_43)
	return this_43
endfunction

function doubleHit takes nothing returns nothing
	local integer tr = dispatch_HandleMap_get(Trackable_trackData, GetTriggeringTrackable())
	local timer t
	if  not Trackable_wasHit[tr] then
		set Trackable_wasHit[tr] = true
		set t = Trackable_doubleHitTimer[tr]
		call timer_setData(t, tr)
		call timer_start(t, Trackable_doubleHitSpeed, ref_function_resetDoubleHit)
		set Trackable_doubleHitTimer[tr] = t
	else
		set Trackable_triggeringTrackable = GetTriggeringTrackable()
		call trigger_execute(Trackable_doubleHit[tr])
		set Trackable_wasHit[tr] = false
	endif
	set t = null
endfunction

function forceKey takes nothing returns nothing
endfunction

function dispatch_OnCast_run takes integer this_43, unit caster returns nothing
endfunction

function dispatch_OnPointCast_run takes integer this_43, unit caster, real pos_x, real pos_y returns nothing
endfunction

function dispatch_OnUnitCast_run takes integer this_43, unit caster, unit target returns nothing
endfunction

function handleCasts takes nothing returns nothing
	local integer c
	local integer c_2
	local integer c_3
	if GetSpellTargetUnit() != null then
		set c = dispatch_HashMap_get(OnUnitCast_casts, GetSpellAbilityId())
		if c != 0 then
			call dispatch_OnUnitCast_run(c, GetTriggerUnit(), GetSpellTargetUnit())
		endif
	elseif GetSpellTargetX() != 0. then
		set c_2 = dispatch_HashMap_get(OnPointCast_casts, GetSpellAbilityId())
		if c_2 != 0 then
			call dispatch_OnPointCast_run(c_2, GetTriggerUnit(), GetSpellTargetX(), GetSpellTargetY())
		endif
	else
		set c_3 = dispatch_HashMap_get(OnCast_casts, GetSpellAbilityId())
		if c_3 != 0 then
			call dispatch_OnCast_run(c_3, GetTriggerUnit())
		endif
	endif
endfunction

function hideItem takes nothing returns nothing
	if IsItemVisible(GetEnumItem()) then
		set Terrain_hid[Terrain_hidMax] = GetEnumItem()
		call SetItemVisible(Terrain_hid[Terrain_hidMax], false)
		set Terrain_hidMax = Terrain_hidMax + 1
	endif
endfunction

function kill takes nothing returns nothing
	call RemoveUnit(PreloadHandler_dum)
	call DestroyTimer(GetExpiredTimer())
endfunction

function notDead takes nothing returns boolean
	return GetUnitAbilityLevel(GetFilterUnit(), 1684365668) != 1
endfunction

function notUnit takes nothing returns boolean
	return ( not IsUnitType(GetFilterUnit(), UNIT_TYPE_UNDEAD)) and Filter_filterCheckUnit != GetFilterUnit()
endfunction

function onEsc takes nothing returns nothing
	call print("onEsc")
endfunction

function playAnimation takes nothing returns nothing
	local integer h_2 = timer_getData(GetExpiredTimer())
	call SetUnitAnimationByIndex(Unit_u[h_2], Hero_animationIndex[h_2])
endfunction

function resetCam takes nothing returns nothing
	local timer t = GetExpiredTimer()
	call CameraClearNoiseForPlayer(Player(timer_getData(t)))
	call timer_release(t)
	set t = null
endfunction

function resetDoubleHit takes nothing returns nothing
	set Trackable_wasHit[timer_getData(GetExpiredTimer())] = false
endfunction

function Bar_enable takes integer this_43 returns nothing
	call texttag_setVisibility(Bar_tt[this_43], true)
	set Bar_check[this_43] = true
	call dispatch_Bar_update(this_43)
endfunction

function dispatch_Bar_enable takes integer this_43 returns nothing
	if Bar_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Bar.enable")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Bar.enable on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Bar_enable(this_43)
endfunction

function Hero_revive takes integer this_43, real pos_x, real pos_y returns nothing
	local integer i_2
	call ReviveHero(Unit_u[this_43], pos_x, pos_y, true)
	call dispatch_Bar_enable(Hero_hb[this_43])
	call unit_removeAbility(Unit_u[this_43], 1684365668)
	set Unit_isDead[this_43] = false
	set i_2 = 0
	loop
		exitwhen i_2 > 11
		call dispatch_Table_saveReal(Unit_percentDamage[this_43], i_2, 0.)
		set i_2 = i_2 + 1
	endloop
endfunction

function dispatch_Hero_revive takes integer this_43, real pos_x, real pos_y returns nothing
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Hero.revive")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Hero.revive on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Hero_revive(this_43, pos_x, pos_y)
endfunction

function Image_disable takes integer this_43, player p returns nothing
	local integer tempIndex
	local integer tempIndex_2
	local integer tempTupleSelectionResult_1
	local integer tempTupleSelectionResult_2
	local integer tempTupleSelectionResult_3
	local integer tempTupleSelectionResult_4
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempTupleSelectionResult_1_2
	local integer tempTupleSelectionResult_2_2
	local integer tempTupleSelectionResult_3_2
	local integer tempTupleSelectionResult_4_2
	local integer tempIndex_5
	local integer tempIndex_6
	local integer tempTupleSelectionResult_1_3
	local integer tempTupleSelectionResult_2_3
	local integer tempTupleSelectionResult_3_3
	local integer tempTupleSelectionResult_4_3
	local integer tempIndex_7
	local integer temp
	local integer temp_2
	local integer temp_3
	local image temp_4
	if p != null then
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp = tempIndex
			set tempIndex_2 = this_43
			set tempTupleSelectionResult_1 = Image_col[tempIndex_2]
			set tempTupleSelectionResult_2 = Image_col_2[tempIndex_2]
			set tempTupleSelectionResult_3 = Image_col_3[tempIndex_2]
			set tempTupleSelectionResult_4 = Image_col_4[tempIndex_2]
			set Image_col[temp] = real_toInt(tempTupleSelectionResult_1 * 0.5)
			set tempIndex_3 = this_43
			set temp_2 = tempIndex_3
			set tempIndex_4 = this_43
			set tempTupleSelectionResult_1_2 = Image_col[tempIndex_4]
			set tempTupleSelectionResult_2_2 = Image_col_2[tempIndex_4]
			set tempTupleSelectionResult_3_2 = Image_col_3[tempIndex_4]
			set tempTupleSelectionResult_4_2 = Image_col_4[tempIndex_4]
			set Image_col_2[temp_2] = real_toInt(tempTupleSelectionResult_2_2 * 0.5)
			set tempIndex_5 = this_43
			set temp_3 = tempIndex_5
			set tempIndex_6 = this_43
			set tempTupleSelectionResult_1_3 = Image_col[tempIndex_6]
			set tempTupleSelectionResult_2_3 = Image_col_2[tempIndex_6]
			set tempTupleSelectionResult_3_3 = Image_col_3[tempIndex_6]
			set tempTupleSelectionResult_4_3 = Image_col_4[tempIndex_6]
			set Image_col_3[temp_3] = real_toInt(tempTupleSelectionResult_3_3 * 0.5)
			set temp_4 = Image_img[this_43]
			set tempIndex_7 = this_43
			call image_setColor(temp_4, Image_col[tempIndex_7], Image_col_2[tempIndex_7], Image_col_3[tempIndex_7], Image_col_4[tempIndex_7])
		endif
	else
		call printError("Nullpoiter in function disable line 164 ImageEx.wurst")
	endif
	set temp_4 = null
endfunction

function dispatch_Image_disable takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.disable")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.disable on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_disable(this_43, p)
endfunction

function Image_enable takes integer this_43, player p returns nothing
	local integer tempIndex
	local integer tempIndex_2
	local integer tempTupleSelectionResult_1
	local integer tempTupleSelectionResult_2
	local integer tempTupleSelectionResult_3
	local integer tempTupleSelectionResult_4
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempTupleSelectionResult_1_2
	local integer tempTupleSelectionResult_2_2
	local integer tempTupleSelectionResult_3_2
	local integer tempTupleSelectionResult_4_2
	local integer tempIndex_5
	local integer tempIndex_6
	local integer tempTupleSelectionResult_1_3
	local integer tempTupleSelectionResult_2_3
	local integer tempTupleSelectionResult_3_3
	local integer tempTupleSelectionResult_4_3
	local integer tempIndex_7
	local integer temp
	local integer temp_2
	local integer temp_3
	local image temp_4
	if p != null then
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp = tempIndex
			set tempIndex_2 = this_43
			set tempTupleSelectionResult_1 = Image_col[tempIndex_2]
			set tempTupleSelectionResult_2 = Image_col_2[tempIndex_2]
			set tempTupleSelectionResult_3 = Image_col_3[tempIndex_2]
			set tempTupleSelectionResult_4 = Image_col_4[tempIndex_2]
			set Image_col[temp] = tempTupleSelectionResult_1 * 2
			set tempIndex_3 = this_43
			set temp_2 = tempIndex_3
			set tempIndex_4 = this_43
			set tempTupleSelectionResult_1_2 = Image_col[tempIndex_4]
			set tempTupleSelectionResult_2_2 = Image_col_2[tempIndex_4]
			set tempTupleSelectionResult_3_2 = Image_col_3[tempIndex_4]
			set tempTupleSelectionResult_4_2 = Image_col_4[tempIndex_4]
			set Image_col_2[temp_2] = tempTupleSelectionResult_2_2 * 2
			set tempIndex_5 = this_43
			set temp_3 = tempIndex_5
			set tempIndex_6 = this_43
			set tempTupleSelectionResult_1_3 = Image_col[tempIndex_6]
			set tempTupleSelectionResult_2_3 = Image_col_2[tempIndex_6]
			set tempTupleSelectionResult_3_3 = Image_col_3[tempIndex_6]
			set tempTupleSelectionResult_4_3 = Image_col_4[tempIndex_6]
			set Image_col_3[temp_3] = tempTupleSelectionResult_3_3 * 2
			set temp_4 = Image_img[this_43]
			set tempIndex_7 = this_43
			call image_setColor(temp_4, Image_col[tempIndex_7], Image_col_2[tempIndex_7], Image_col_3[tempIndex_7], Image_col_4[tempIndex_7])
		endif
	else
		call printError("Nullpoiter in function srink line 174 ImageEx.wurst")
	endif
	set temp_4 = null
endfunction

function dispatch_Image_enable takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.enable")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.enable on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_enable(this_43, p)
endfunction

function handle_getHandleId takes handle this_43 returns integer
	return GetHandleId(this_43)
endfunction

function playerToIndex takes player object returns integer
	return handle_getHandleId(object)
endfunction

function Image_grow takes integer this_43, player p returns nothing
	local timer t
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_6
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real temp
	local real temp_2
	local integer temp_3
	local string temp_4
	local real temp_5
	local real temp_6
	local real temp_7
	local integer temp_8
	if p != null then
		set t = getTimer()
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp_3 = tempIndex
			set tempIndex_2 = this_43
			set temp = Image_realSize[tempIndex_2]
			set temp_2 = Image_realSize_2[tempIndex_2]
			set tempIndex_3 = this_43
			set Image_realSize[temp_3] = vec2_op_plus(temp, temp_2, Image_resizeRate[tempIndex_3], Image_resizeRate_2[tempIndex_3])
			set Image_realSize_2[tempIndex] = vec2_op_plus_return_y
			if Image_img[this_43] != null then
				call image_remove(Image_img[this_43])
				set temp_8 = this_43
				set temp_4 = Image_filePath[this_43]
				set tempIndex_4 = this_43
				set temp_5 = Image_realPos[tempIndex_4]
				set temp_6 = Image_realPos_2[tempIndex_4]
				set tempIndex_5 = this_43
				set tempTupleSelectionResult_1 = Image_realSize[tempIndex_5]
				set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_5]
				set temp_7 = tempTupleSelectionResult_1
				set tempIndex_6 = this_43
				set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_6]
				set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_6]
				set Image_img[temp_8] = createImage(temp_4, temp_5, temp_6, temp_7, tempTupleSelectionResult_2_2, Image_layer[this_43])
				call image_show(Image_img[this_43])
			endif
		endif
		call dispatch_HandleMap_put(Image_tick, t, Image_resizeTicks)
		call timer_setData(t, this_43)
		call dispatch_HandleMap_put(Image_timerOwner, t, playerToIndex(p))
		call timer_startPeriodic(t, 0.02, ref_function_Image_callGrowCallback)
	else
		call printError("Nullpoiter in function srink line 218 ImageEx.wurst")
	endif
	set t = null
endfunction

function dispatch_Image_grow takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.grow")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.grow on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_grow(this_43, p)
endfunction

function Image_hideDirect takes integer this_43, player p returns nothing
	if p != null then
		if GetLocalPlayer() == p and Image_img[this_43] != null then
			call image_remove(Image_img[this_43])
			set Image_img[this_43] = null
		endif
	else
		call printError("Nullpoiter in function hideDirect line 93 ImageEx.wurst")
	endif
endfunction

function TextBox_hideDirect takes integer this_43, player p returns nothing
endfunction

function dispatch_Image_hideDirect takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.hideDirect")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.hideDirect on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Widget_typeId[this_43] <= 708 then
		call Image_hideDirect(this_43, p)
	else
		call TextBox_hideDirect(this_43, p)
	endif
endfunction

function Image_hideFaded takes integer this_43, player p returns nothing
	local timer t
	local integer tempIndex
	local integer tempIndex_2
	local image temp
	if p != null then
		set t = getTimer()
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set Image_col_4[tempIndex] = 255
			set temp = Image_img[this_43]
			set tempIndex_2 = this_43
			call image_setColor(temp, Image_col[tempIndex_2], Image_col_2[tempIndex_2], Image_col_3[tempIndex_2], Image_col_4[tempIndex_2])
		endif
		call dispatch_HandleMap_put(Image_tick, t, Image_fadeTicks * -1)
		call timer_setData(t, this_43)
		call dispatch_HandleMap_put(Image_timerOwner, t, playerToIndex(p))
		call timer_startPeriodic(t, 0.02, ref_function_Image_callHideFadedCallback)
	else
		call printError("Nullpoiter in function hideFaded line 171 ImageEx.wurst")
	endif
	set t = null
	set temp = null
endfunction

function dispatch_Image_hideFaded takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.hideFaded")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.hideFaded on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_hideFaded(this_43, p)
endfunction

function Image_setRealSize takes integer this_43, real newSize_x, real newSize_y, player p returns nothing
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_4
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local string temp
	local real temp_2
	local real temp_3
	local real temp_4
	local integer temp_5
	if p != null then
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set Image_realSize[tempIndex] = newSize_x
			set Image_realSize_2[tempIndex] = newSize_y
			if Image_img[this_43] != null then
				call image_remove(Image_img[this_43])
				set temp_5 = this_43
				set temp = Image_filePath[this_43]
				set tempIndex_2 = this_43
				set temp_2 = Image_realPos[tempIndex_2]
				set temp_3 = Image_realPos_2[tempIndex_2]
				set tempIndex_3 = this_43
				set tempTupleSelectionResult_1 = Image_realSize[tempIndex_3]
				set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_3]
				set temp_4 = tempTupleSelectionResult_1
				set tempIndex_4 = this_43
				set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_4]
				set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_4]
				set Image_img[temp_5] = createImage(temp, temp_2, temp_3, temp_4, tempTupleSelectionResult_2_2, Image_layer[this_43])
				call image_show(Image_img[this_43])
			endif
		endif
	else
		call printError("Nullpoiter in function setSize line 204 ImageEx.wurst")
	endif
endfunction

function dispatch_Image_setRealSize takes integer this_43, real newSize_x, real newSize_y, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.setRealSize")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.setRealSize on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_setRealSize(this_43, newSize_x, newSize_y, p)
endfunction

function Image_showDirect takes integer this_43, player p returns nothing
	local integer tempIndex
	local integer tempIndex_2
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_3
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local string temp
	local real temp_2
	local real temp_3
	local real temp_4
	local integer temp_5
	if p != null then
		if GetLocalPlayer() == p then
			if Image_img[this_43] == null then
				set temp_5 = this_43
				set temp = Image_filePath[this_43]
				set tempIndex = this_43
				set temp_2 = Image_realPos[tempIndex]
				set temp_3 = Image_realPos_2[tempIndex]
				set tempIndex_2 = this_43
				set tempTupleSelectionResult_1 = Image_realSize[tempIndex_2]
				set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_2]
				set temp_4 = tempTupleSelectionResult_1
				set tempIndex_3 = this_43
				set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_3]
				set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_3]
				set Image_img[temp_5] = createImage(temp, temp_2, temp_3, temp_4, tempTupleSelectionResult_2_2, Image_layer[this_43])
			endif
			call image_show(Image_img[this_43])
		endif
	else
		call printError("Nullpoiter in function showDirect line 84 ImageEx.wurst")
	endif
endfunction

function dispatch_Image_showDirect takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.showDirect")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.showDirect on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_showDirect(this_43, p)
endfunction

function Image_showFaded takes integer this_43, player p returns nothing
	local timer t
	local integer tempIndex
	local integer tempIndex_2
	local image temp
	if p != null then
		call dispatch_Image_showDirect(this_43, p)
		set t = getTimer()
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set Image_col_4[tempIndex] = 0
			set temp = Image_img[this_43]
			set tempIndex_2 = this_43
			call image_setColor(temp, Image_col[tempIndex_2], Image_col_2[tempIndex_2], Image_col_3[tempIndex_2], Image_col_4[tempIndex_2])
		endif
		call dispatch_HandleMap_put(Image_tick, t, Image_fadeTicks)
		call timer_setData(t, this_43)
		call dispatch_HandleMap_put(Image_timerOwner, t, playerToIndex(p))
		call timer_startPeriodic(t, 0.02, ref_function_Image_callShowFadedCallback)
	else
		call printError("Nullpoiter in function showFaded line 101 ImageEx.wurst")
	endif
	set t = null
	set temp = null
endfunction

function dispatch_Image_showFaded takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.showFaded")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.showFaded on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_showFaded(this_43, p)
endfunction

function Image_srink takes integer this_43, player p returns nothing
	local timer t
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local real tempTupleSelectionResult_1
	local real tempTupleSelectionResult_2
	local integer tempIndex_6
	local real tempTupleSelectionResult_1_2
	local real tempTupleSelectionResult_2_2
	local real temp
	local real temp_2
	local integer temp_3
	local string temp_4
	local real temp_5
	local real temp_6
	local real temp_7
	local integer temp_8
	if p != null then
		set t = getTimer()
		if GetLocalPlayer() == p then
			set tempIndex = this_43
			set temp_3 = tempIndex
			set tempIndex_2 = this_43
			set temp = Image_realSize[tempIndex_2]
			set temp_2 = Image_realSize_2[tempIndex_2]
			set tempIndex_3 = this_43
			set Image_realSize[temp_3] = vec2_op_minus(temp, temp_2, Image_resizeRate[tempIndex_3], Image_resizeRate_2[tempIndex_3])
			set Image_realSize_2[tempIndex] = vec2_op_minus_return_y
			if Image_img[this_43] != null then
				call image_remove(Image_img[this_43])
				set temp_8 = this_43
				set temp_4 = Image_filePath[this_43]
				set tempIndex_4 = this_43
				set temp_5 = Image_realPos[tempIndex_4]
				set temp_6 = Image_realPos_2[tempIndex_4]
				set tempIndex_5 = this_43
				set tempTupleSelectionResult_1 = Image_realSize[tempIndex_5]
				set tempTupleSelectionResult_2 = Image_realSize_2[tempIndex_5]
				set temp_7 = tempTupleSelectionResult_1
				set tempIndex_6 = this_43
				set tempTupleSelectionResult_1_2 = Image_realSize[tempIndex_6]
				set tempTupleSelectionResult_2_2 = Image_realSize_2[tempIndex_6]
				set Image_img[temp_8] = createImage(temp_4, temp_5, temp_6, temp_7, tempTupleSelectionResult_2_2, Image_layer[this_43])
				call image_show(Image_img[this_43])
			endif
		endif
		call dispatch_HandleMap_put(Image_tick, t, Image_resizeTicks)
		call timer_setData(t, this_43)
		call dispatch_HandleMap_put(Image_timerOwner, t, playerToIndex(p))
		call timer_startPeriodic(t, 0.02, ref_function_Image_callSrinkCallback)
	else
		call printError("Nullpoiter in function srink line 184 ImageEx.wurst")
	endif
	set t = null
endfunction

function dispatch_Image_srink takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Image.srink")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Image.srink on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Image_srink(this_43, p)
endfunction

function Shield_getRemainingTime takes integer this_43 returns real
	return TimerGetRemaining(Shield_t[this_43])
endfunction

function dispatch_Shield_getRemainingTime takes integer this_43 returns real
	local real getRemainingTime_result
	if Shield_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Shield.getRemainingTime")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Shield.getRemainingTime on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set getRemainingTime_result = Shield_getRemainingTime(this_43)
	return getRemainingTime_result
endfunction

function ShieldList_add takes integer this_43, integer s returns nothing
	local real time
	local integer pos
	local integer buffer
	set ShieldList_shieldSum[this_43] = ShieldList_shieldSum[this_43] + Shield_amount[s]
	if ShieldList_first[this_43] == 0 then
		set ShieldList_first[this_43] = s
		set ShieldList_last[this_43] = s
	else
		set time = dispatch_Shield_getRemainingTime(s)
		set pos = ShieldList_first[this_43]
		loop
			exitwhen  not (pos != 0)
			if dispatch_Shield_getRemainingTime(ShieldList_first[this_43]) > time then
				set buffer = Shield_prev[pos]
				set Shield_prev[pos] = s
				set Shield_next[buffer] = s
				set Shield_prev[s] = buffer
				set Shield_next[s] = pos
				exitwhen true
			else
				set pos = Shield_next[pos]
			endif
		endloop
	endif
endfunction

function dispatch_ShieldList_add takes integer this_43, integer s returns nothing
	if ShieldList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ShieldList.add")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ShieldList.add on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ShieldList_add(this_43, s)
endfunction

function alloc_Shield takes nothing returns integer
	local integer this_43
	if Shield_firstFree == 0 then
		set Shield_maxIndex = Shield_maxIndex + 1
		set this_43 = Shield_maxIndex
	else
		set this_43 = Shield_firstFree
		set Shield_firstFree = Shield_nextFree[Shield_firstFree]
		set Shield_nextFree[this_43] = 0
	endif
	set Shield_typeId[this_43] = 617
	return this_43
endfunction

function construct_Shield takes integer this_43, integer u, real amount_39, real time, integer referingList returns nothing
	set Shield_t[this_43] = getTimer()
	set Shield_shieldDestroyed[this_43] = 0
	set Shield_target[this_43] = u
	set Shield_amount[this_43] = amount_39
	set Shield_referingList[this_43] = referingList
	call timer_setData(Shield_t[this_43], this_43)
	call timer_start(Shield_t[this_43], time, ref_function_Shield_onExpire)
endfunction

function new_Shield takes integer u, real amount_39, real time, integer referingList returns integer
	local integer this_43 = alloc_Shield()
	call construct_Shield(this_43, u, amount_39, time, referingList)
	return this_43
endfunction

function Unit_addShield takes integer this_43, real amount_39, real duration returns integer
	local integer s = new_Shield(this_43, amount_39, duration, Unit_shieldList[this_43])
	call dispatch_ShieldList_add(Unit_shieldList[this_43], s)
	return s
endfunction

function dispatch_Unit_addShield takes integer this_43, real amount_39, real duration returns integer
	local integer addShield_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.addShield")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.addShield on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set addShield_result = Unit_addShield(this_43, amount_39, duration)
	else
		set addShield_result = Unit_addShield(this_43, amount_39, duration)
	endif
	return addShield_result
endfunction

function alloc_Closure_9 takes nothing returns integer
	local integer this_43
	if Bonus_firstFree == 0 then
		set Bonus_maxIndex = Bonus_maxIndex + 1
		set this_43 = Bonus_maxIndex
	else
		set this_43 = Bonus_firstFree
		set Bonus_firstFree = Bonus_nextFree[Bonus_firstFree]
		set Bonus_nextFree[this_43] = 0
	endif
	set Bonus_typeId[this_43] = 669
	return this_43
endfunction

function Unit_bonusLife_2 takes integer this_43, real amount_39 returns integer
	local integer clVar
	set Unit_bonusLife[this_43] = Unit_bonusLife[this_43] + amount_39
	call dispatch_Unit_updateLife(this_43)
	set clVar = alloc_Closure_9()
	set this_26[clVar] = this_43
	set amount_23[clVar] = amount_39
	return clVar
endfunction

function dispatch_Unit_bonusLife takes integer this_43, real amount_39 returns integer
	local integer bonusLife_result
	if Unit_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Unit.bonusLife")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Unit.bonusLife on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Unit_typeId[this_43] <= 645 then
		set bonusLife_result = Unit_bonusLife_2(this_43, amount_39)
	else
		set bonusLife_result = Unit_bonusLife_2(this_43, amount_39)
	endif
	return bonusLife_result
endfunction

function setCallLimit takes nothing returns nothing
	local string chatString = GetEventPlayerChatString()
	local string cuttet
	local string temp
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local real temp_2
	local real temp_3
	local integer temp_4
	local real temp_5
	local real temp_6
	local integer temp_7
	if SubString(chatString, 0, 1) == "a" then
		set cuttet = SubString(chatString, 1, 5)
		call SetUnitAnimationByIndex(Unit_u[UnitClass_last], S2I(cuttet))
	endif
	set temp = chatString
	if temp == "showD" then
		call dispatch_Image_showDirect(GameStart_testImg, Player(0))
		call dispatch_Image_showDirect(GameStart_testImg, Player(1))
	elseif temp == "hideD" then
		call dispatch_Image_hideDirect(GameStart_testImg, Player(0))
		call dispatch_Image_hideDirect(GameStart_testImg, Player(1))
	elseif temp == "showF" then
		call dispatch_Image_showFaded(GameStart_testImg, Player(0))
		call dispatch_Image_showFaded(GameStart_testImg, Player(1))
	elseif temp == "hideF" then
		call dispatch_Image_hideFaded(GameStart_testImg, Player(0))
		call dispatch_Image_hideFaded(GameStart_testImg, Player(1))
	elseif temp == "dis" then
		call dispatch_Image_disable(GameStart_testImg, Player(0))
	elseif temp == "en" then
		call dispatch_Image_enable(GameStart_testImg, Player(0))
	elseif temp == "grow" then
		call dispatch_Image_grow(GameStart_testImg, Player(0))
	elseif temp == "srink" then
		call dispatch_Image_srink(GameStart_testImg, Player(0))
	elseif temp == "size+" then
		set temp_4 = GameStart_testImg
		set tempIndex = GameStart_testImg
		set temp_2 = Image_realSize[tempIndex]
		set temp_3 = Image_realSize_2[tempIndex]
		set tempIndex_2 = GameStart_testImg
		call dispatch_Image_setRealSize(temp_4, vec2_op_plus(temp_2, temp_3, vec2_op_mult(Image_size[tempIndex_2], Image_size_2[tempIndex_2], 1.05), vec2_op_mult_return_y), vec2_op_plus_return_y, Player(0))
	elseif temp == "size-" then
		set temp_7 = GameStart_testImg
		set tempIndex_3 = GameStart_testImg
		set temp_5 = Image_realSize[tempIndex_3]
		set temp_6 = Image_realSize_2[tempIndex_3]
		set tempIndex_4 = GameStart_testImg
		call dispatch_Image_setRealSize(temp_7, vec2_op_plus(temp_5, temp_6, vec2_op_mult(Image_size[tempIndex_4], Image_size_2[tempIndex_4], 0.95), vec2_op_mult_return_y), vec2_op_plus_return_y, Player(0))
	elseif temp == "drag t t" then
		call EnableDragSelect(true, true)
	elseif temp == "drag t f" then
		call EnableDragSelect(true, false)
	elseif temp == "drag f t" then
		call EnableDragSelect(false, true)
	elseif temp == "drag f f" then
		call EnableDragSelect(false, false)
	elseif temp == "pre t t" then
		call EnablePreSelect(true, true)
	elseif temp == "pre t f" then
		call EnablePreSelect(true, false)
	elseif temp == "pre f t" then
		call EnablePreSelect(false, true)
	elseif temp == "pre f f" then
		call EnablePreSelect(false, false)
	elseif temp == "sel t t" then
		call EnableSelect(true, true)
	elseif temp == "sel t f" then
		call EnableSelect(true, false)
	elseif temp == "sel f t" then
		call EnableSelect(false, true)
	elseif temp == "sel f f" then
		call EnableSelect(false, false)
	elseif temp == "last" then
		call SelectUnitForPlayerSingle(Unit_u[UnitClass_last], Player(0))
	elseif temp == "hp+" then
		call dispatch_Unit_bonusLife(UnitClass_last, 10.)
	elseif temp == "hp++" then
		call dispatch_Unit_bonusLife(UnitClass_last, 100.)
	elseif temp == "hp+++" then
		call dispatch_Unit_bonusLife(UnitClass_last, 1000.)
	elseif temp == "hp-" then
		call dispatch_Unit_bonusLife(UnitClass_last, -10.)
	elseif temp == "hp--" then
		call dispatch_Unit_bonusLife(UnitClass_last, -100.)
	elseif temp == "hp---" then
		call dispatch_Unit_bonusLife(UnitClass_last, -1000.)
	elseif temp == "rev" then
		call dispatch_Hero_revive(UnitClass_last, 100., 100.)
	elseif temp == "shield1" then
		call dispatch_Unit_addShield(UnitClass_last, 10., 10.)
	elseif temp == "shield2" then
		call dispatch_Unit_addShield(UnitClass_last, 100., 10.)
	elseif temp == "shield3" then
		call dispatch_Unit_addShield(UnitClass_last, 1000., 10.)
	elseif temp == "canMove f" then
		set Hero_acceptOrders[UnitClass_last] = false
	elseif temp == "canMove t" then
		set Hero_acceptOrders[UnitClass_last] = true
	elseif temp == "swap" then
		call SetPlayerAbilityAvailable(Player(0), 1094269238, false)
		call SetPlayerAbilityAvailable(Player(0), 1094269241, true)
	elseif temp == "bswap" then
		call SetPlayerAbilityAvailable(Player(0), 1094269238, true)
		call SetPlayerAbilityAvailable(Player(0), 1094269241, false)
	elseif temp == "slot" then
		call SetPlayerAbilityAvailable(Player(0), 1935896434, false)
	elseif temp == "key" then
		call print(int_toString(GetLocalizedHotkey("ESC")))
	elseif temp == "abi" then
		call print(int_toString(GetUnitAbilityLevel(Unit_u[UnitClass_last], 1935896434)))
		call SetUnitAbilityLevel(Unit_u[UnitClass_last], 1935896434, 2)
		call print(int_toString(GetUnitAbilityLevel(Unit_u[UnitClass_last], 1935896434)))
	elseif temp == "cast" then
		call IssueInstantPointOrder(Unit_u[UnitClass_last], "ancestralspirit", 0., 0., null)
	elseif temp == "cd" then
		call cd()
	endif
endfunction

function spellCondition takes nothing returns boolean
	if GetSpellAbilityId() == 1096115059 then
		return true
	else
		return false
	endif
endfunction

function alloc_Pull2 takes nothing returns integer
	local integer this_43
	if Pull2_firstFree == 0 then
		set Pull2_maxIndex = Pull2_maxIndex + 1
		set this_43 = Pull2_maxIndex
	else
		set this_43 = Pull2_firstFree
		set Pull2_firstFree = Pull2_nextFree[Pull2_firstFree]
		set Pull2_nextFree[this_43] = 0
	endif
	set Pull2_typeId[this_43] = 720
	return this_43
endfunction

function construct_Pull2 takes integer this_43, unit u, unit ut returns nothing
	set Pull2_u[this_43] = u
	set Pull2_ut[this_43] = ut
	set Pull2_uut[this_43] = GetUnitUserData(ut)
	set Pull2_i[this_43] = R2I(distanceBetweenCoords(unit_getX(u), unit_getY(u), unit_getX(ut), unit_getY(ut)) / 20.)
	set Pull2_imax[this_43] = Pull2_i[this_43]
	set Pull2_l[this_43] = AddLightningEx("LEAS", true, unit_getX(u), unit_getY(u), 50., unit_getX(ut), unit_getY(ut), 50.)
	set Pull2_t[this_43] = getTimer()
	call timer_setData(Pull2_t[this_43], this_43)
	call timer_startPeriodic(Pull2_t[this_43], 0.03, ref_function_Pull2_blackHCall)
endfunction

function new_Pull2 takes unit u, unit ut returns integer
	local integer this_43 = alloc_Pull2()
	call construct_Pull2(this_43, u, ut)
	return this_43
endfunction

function spellStart takes nothing returns nothing
	call new_Pull2(GetTriggerUnit(), GetSpellTargetUnit())
endfunction

function textTag takes nothing returns nothing
endfunction

function Button_onDoubleHit takes integer this_43, player p returns nothing
	if Button_onDoubleHitAction[this_43] != null then
		set Menu_clickingPlayer = dispatch_HandleMap_get(PlayerClass_playerData, p)
		set Menu_clickedButton = this_43
		call trigger_execute(Button_onDoubleHitAction[this_43])
	endif
endfunction

function dispatch_Button_onDoubleHit takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Button.onDoubleHit")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Button.onDoubleHit on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Button_onDoubleHit(this_43, p)
endfunction

function HTable_get takes integer this_43, handle parentKey, integer childKey returns integer
	return hashtable_loadInt(HTable_ht[this_43], GetHandleId(parentKey), childKey)
endfunction

function dispatch_HTable_get takes integer this_43, handle parentKey, integer childKey returns integer
	local integer get_result
	if HTable_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HTable.get")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HTable.get on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	set get_result = HTable_get(this_43, parentKey, childKey)
	return get_result
endfunction

function trackable_getOwner takes trackable this_43 returns player
	return Trackable_owner[dispatch_HandleMap_get(Trackable_trackData, this_43)]
endfunction

function trackableDoubleHitHandler takes nothing returns nothing
	local player p = trackable_getOwner(GetTriggeringTrackable())
	local integer b = dispatch_HTable_get(TrackableEventHandler_trackableDoubleHitAction, GetTriggeringTrackable(), TrackableEventHandler_currentMenuOfPlayer[GetPlayerId(p)])
	if b != 0 then
		call dispatch_Button_onDoubleHit(b, p)
	endif
	set p = null
endfunction

function Button_onHit takes integer this_43, player p returns nothing
	if Button_onHitAction[this_43] != null then
		set Menu_clickingPlayer = dispatch_HandleMap_get(PlayerClass_playerData, p)
		set Menu_clickedButton = this_43
		call trigger_execute(Button_onHitAction[this_43])
	endif
endfunction

function dispatch_Button_onHit takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Button.onHit")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Button.onHit on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Button_onHit(this_43, p)
endfunction

function trackableHitHandler takes nothing returns nothing
	local player p = trackable_getOwner(GetTriggeringTrackable())
	local integer b = dispatch_HTable_get(TrackableEventHandler_trackableHitAction, GetTriggeringTrackable(), TrackableEventHandler_currentMenuOfPlayer[GetPlayerId(p)])
	if b != 0 then
		call dispatch_Button_onHit(b, p)
	endif
	set p = null
endfunction

function Button_onTrack takes integer this_43, player p returns nothing
	if Button_onTrackAction[this_43] != null then
		set Menu_clickingPlayer = dispatch_HandleMap_get(PlayerClass_playerData, p)
		set Menu_clickedButton = this_43
		call trigger_execute(Button_onTrackAction[this_43])
	endif
endfunction

function dispatch_Button_onTrack takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Button.onTrack")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Button.onTrack on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Button_onTrack(this_43, p)
endfunction

function Button_onUnTrack takes integer this_43, player p returns nothing
	if Button_onHitAction[this_43] != null then
		set Menu_clickingPlayer = dispatch_HandleMap_get(PlayerClass_playerData, p)
		set Menu_clickedButton = this_43
		call trigger_execute(Button_onUnTrackAction[this_43])
	endif
endfunction

function dispatch_Button_onUnTrack takes integer this_43, player p returns nothing
	if Widget_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Button.onUnTrack")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Button.onUnTrack on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call Button_onUnTrack(this_43, p)
endfunction

function trackableTrackHandler takes nothing returns nothing
	local player p = trackable_getOwner(GetTriggeringTrackable())
	local integer playerId = GetPlayerId(p)
	local integer b = dispatch_HTable_get(TrackableEventHandler_trackableHitAction, GetTriggeringTrackable(), TrackableEventHandler_currentMenuOfPlayer[GetPlayerId(p)])
	local integer current = TrackableEventHandler_currentButtonOfPlayer[playerId]
	if b != current then
		if b != 0 then
			call dispatch_Button_onTrack(b, p)
		endif
		if current != 0 then
			call dispatch_Button_onUnTrack(current, p)
		endif
	endif
	set TrackableEventHandler_currentButtonOfPlayer[playerId] = b
	set p = null
endfunction

function updateTime takes nothing returns nothing
	set HandleCounter_seconds = HandleCounter_seconds + 1
endfunction

function initGlobals takes nothing returns nothing
	set udg_zw = 0.
	set udg_t = null
	set udg_MeineAbility = 0
	set udg_CasterVariable = null
	set udg_UnverwundbarkeitsGruppe = null
	set udg_MeineHashtable = null
	set udg_Urspung = null
	set udg_Ziel = null
	set udg_x1 = 0.
	set udg_x2 = 0.
	set udg_x3 = 0.
	set udg_x4 = 0.
	set udg_x5 = 0.
	set udg_y1 = 0.
	set udg_y4 = 0.
	set udg_y5 = 0.
	set udg_y3 = 0.
	set udg_y2 = 0.
	set gg_cam_Camera_001 = null
	set gg_cam_Camera_002 = null
	set gg_trg_Unbezeichneter_Ausl__ser_003 = null
	set LinkedList_firstFree = 0
	set LinkedList_lastFree = 0
	set LinkedList_maxIndex = 0
	set LLEntry_firstFree = 0
	set LLEntry_lastFree = 0
	set LLEntry_maxIndex = 0
	set LLIterator_firstFree = 0
	set LLIterator_lastFree = 0
	set LLIterator_maxIndex = 0
	set Table_firstFree = 0
	set Table_lastFree = 0
	set Table_maxIndex = 0
	set StringIterator_firstFree = 0
	set StringIterator_lastFree = 0
	set StringIterator_maxIndex = 0
	set StringLines_firstFree = 0
	set StringLines_lastFree = 0
	set StringLines_maxIndex = 0
	set BigNum_l_firstFree = 0
	set BigNum_l_lastFree = 0
	set BigNum_l_maxIndex = 0
	set BigNum_firstFree = 0
	set BigNum_lastFree = 0
	set BigNum_maxIndex = 0
	set UnitIndex_firstFree = 0
	set UnitIndex_lastFree = 0
	set UnitIndex_maxIndex = 0
	set Event_firstFree = 0
	set Event_lastFree = 0
	set Event_maxIndex = 0
	set Action_firstFree = 0
	set Action_lastFree = 0
	set Action_maxIndex = 0
	set TList_firstFree = 0
	set TList_lastFree = 0
	set TList_maxIndex = 0
	set TIterator_firstFree = 0
	set TIterator_lastFree = 0
	set TIterator_maxIndex = 0
	set Dot_firstFree = 0
	set Dot_lastFree = 0
	set Dot_maxIndex = 0
	set Buff_firstFree = 0
	set Buff_lastFree = 0
	set Buff_maxIndex = 0
	set AbilityDefinition_firstFree = 0
	set AbilityDefinition_lastFree = 0
	set AbilityDefinition_maxIndex = 0
	set BuffDefinition_firstFree = 0
	set BuffDefinition_lastFree = 0
	set BuffDefinition_maxIndex = 0
	set W3UDefinition_firstFree = 0
	set W3UDefinition_lastFree = 0
	set W3UDefinition_maxIndex = 0
	set Table3D_firstFree = 0
	set Table3D_lastFree = 0
	set Table3D_maxIndex = 0
	set Array_firstFree = 0
	set Array_lastFree = 0
	set Array_maxIndex = 0
	set DebugFile_firstFree = 0
	set DebugFile_lastFree = 0
	set DebugFile_maxIndex = 0
	set HashMap_firstFree = 0
	set HashMap_lastFree = 0
	set HashMap_maxIndex = 0
	set CallbackSingle_firstFree = 0
	set CallbackSingle_lastFree = 0
	set CallbackSingle_maxIndex = 0
	set CallbackPeriodic_firstFree = 0
	set CallbackPeriodic_lastFree = 0
	set CallbackPeriodic_maxIndex = 0
	set CallbackCounted_firstFree = 0
	set CallbackCounted_lastFree = 0
	set CallbackCounted_maxIndex = 0
	set Widget_firstFree = 0
	set Widget_lastFree = 0
	set Widget_maxIndex = 0
	set TextTag_firstFree = 0
	set TextTag_lastFree = 0
	set TextTag_maxIndex = 0
	set ShieldList_firstFree = 0
	set ShieldList_lastFree = 0
	set ShieldList_maxIndex = 0
	set Shield_firstFree = 0
	set Shield_lastFree = 0
	set Shield_maxIndex = 0
	set Bar_firstFree = 0
	set Bar_lastFree = 0
	set Bar_maxIndex = 0
	set BarTest_firstFree = 0
	set BarTest_lastFree = 0
	set BarTest_maxIndex = 0
	set Queue_firstFree = 0
	set Queue_lastFree = 0
	set Queue_maxIndex = 0
	set SEntry_firstFree = 0
	set SEntry_lastFree = 0
	set SEntry_maxIndex = 0
	set SIterator_firstFree = 0
	set SIterator_lastFree = 0
	set SIterator_maxIndex = 0
	set AreaMarker_firstFree = 0
	set AreaMarker_lastFree = 0
	set AreaMarker_maxIndex = 0
	set HandleMap_firstFree = 0
	set HandleMap_lastFree = 0
	set HandleMap_maxIndex = 0
	set DelayData_firstFree = 0
	set DelayData_lastFree = 0
	set DelayData_maxIndex = 0
	set Fx_firstFree = 0
	set Fx_lastFree = 0
	set Fx_maxIndex = 0
	set ControlPoint_firstFree = 0
	set ControlPoint_lastFree = 0
	set ControlPoint_maxIndex = 0
	set CaptureData_firstFree = 0
	set CaptureData_lastFree = 0
	set CaptureData_maxIndex = 0
	set Order_firstFree = 0
	set Order_lastFree = 0
	set Order_maxIndex = 0
	set ObjId_firstFree = 0
	set ObjId_lastFree = 0
	set ObjId_maxIndex = 0
	set SpellSetup_firstFree = 0
	set SpellSetup_lastFree = 0
	set SpellSetup_maxIndex = 0
	set Spellcast_firstFree = 0
	set Spellcast_lastFree = 0
	set Spellcast_maxIndex = 0
	set Spell_firstFree = 0
	set Spell_lastFree = 0
	set Spell_maxIndex = 0
	set EventData_firstFree = 0
	set EventData_lastFree = 0
	set EventData_maxIndex = 0
	set EventAction_firstFree = 0
	set EventAction_lastFree = 0
	set EventAction_maxIndex = 0
	set Unit_firstFree = 0
	set Unit_lastFree = 0
	set Unit_maxIndex = 0
	set Bonus_firstFree = 0
	set Bonus_lastFree = 0
	set Bonus_maxIndex = 0
	set Stun_firstFree = 0
	set Stun_lastFree = 0
	set Stun_maxIndex = 0
	set PreDamageData_firstFree = 0
	set PreDamageData_lastFree = 0
	set PreDamageData_maxIndex = 0
	set OnDamageData_firstFree = 0
	set OnDamageData_lastFree = 0
	set OnDamageData_maxIndex = 0
	set SpellData_firstFree = 0
	set SpellData_lastFree = 0
	set SpellData_maxIndex = 0
	set Units_firstFree = 0
	set Units_lastFree = 0
	set Units_maxIndex = 0
	set CaptureEventData_firstFree = 0
	set CaptureEventData_lastFree = 0
	set CaptureEventData_maxIndex = 0
	set HTable_firstFree = 0
	set HTable_lastFree = 0
	set HTable_maxIndex = 0
	set Player_firstFree = 0
	set Player_lastFree = 0
	set Player_maxIndex = 0
	set Trackable_firstFree = 0
	set Trackable_lastFree = 0
	set Trackable_maxIndex = 0
	set MenuIndexer_firstFree = 0
	set MenuIndexer_lastFree = 0
	set MenuIndexer_maxIndex = 0
	set Menu_firstFree = 0
	set Menu_lastFree = 0
	set Menu_maxIndex = 0
	set TextTagEx_firstFree = 0
	set TextTagEx_lastFree = 0
	set TextTagEx_maxIndex = 0
	set Text_firstFree = 0
	set Text_lastFree = 0
	set Text_maxIndex = 0
	set TextBlock_firstFree = 0
	set TextBlock_lastFree = 0
	set TextBlock_maxIndex = 0
	set Word_firstFree = 0
	set Word_lastFree = 0
	set Word_maxIndex = 0
	set SamplePointSpell_firstFree = 0
	set SamplePointSpell_lastFree = 0
	set SamplePointSpell_maxIndex = 0
	set TestSpell1_firstFree = 0
	set TestSpell1_lastFree = 0
	set TestSpell1_maxIndex = 0
	set MazeChecker_firstFree = 0
	set MazeChecker_lastFree = 0
	set MazeChecker_maxIndex = 0
	set RockThrow_firstFree = 0
	set RockThrow_lastFree = 0
	set RockThrow_maxIndex = 0
	set RTable_firstFree = 0
	set RTable_lastFree = 0
	set RTable_maxIndex = 0
	set Pull2_firstFree = 0
	set Pull2_lastFree = 0
	set Pull2_maxIndex = 0
	set Missle_firstFree = 0
	set Missle_lastFree = 0
	set Missle_maxIndex = 0
	set Item_firstFree = 0
	set Item_lastFree = 0
	set Item_maxIndex = 0
	set Aura_firstFree = 0
	set Aura_lastFree = 0
	set Aura_maxIndex = 0
	set CustomBar_firstFree = 0
	set CustomBar_lastFree = 0
	set CustomBar_maxIndex = 0
	set Stack_firstFree = 0
	set Stack_lastFree = 0
	set Stack_maxIndex = 0
	set SEntry_firstFree_2 = 0
	set SEntry_lastFree_2 = 0
	set SEntry_maxIndex_2 = 0
	set SIterator_firstFree_2 = 0
	set SIterator_lastFree_2 = 0
	set SIterator_maxIndex_2 = 0
	set Preload_firstFree = 0
	set Preload_lastFree = 0
	set Preload_maxIndex = 0
	set ForceIterator_firstFree = 0
	set ForceIterator_lastFree = 0
	set ForceIterator_maxIndex = 0
	set OnCast_firstFree = 0
	set OnCast_lastFree = 0
	set OnCast_maxIndex = 0
	set OnPointCast_firstFree = 0
	set OnPointCast_lastFree = 0
	set OnPointCast_maxIndex = 0
	set OnUnitCast_firstFree = 0
	set OnUnitCast_lastFree = 0
	set OnUnitCast_maxIndex = 0
	set A_firstFree = 0
	set A_lastFree = 0
	set A_maxIndex = 0
	set Char_firstFree = 0
	set Char_lastFree = 0
	set Char_maxIndex = 0
	set ref_function_IssueHauntOrderAtLocBJFilter = function IssueHauntOrderAtLocBJFilter
	set ref_function_EnumDestructablesInCircleBJFilter = function EnumDestructablesInCircleBJFilter
	set ref_function_GetUnitsInRectOfPlayerFilter = function GetUnitsInRectOfPlayerFilter
	set ref_function_GetUnitsOfTypeIdAllFilter = function GetUnitsOfTypeIdAllFilter
	set ref_function_GetUnitsOfPlayerAndTypeIdFilter = function GetUnitsOfPlayerAndTypeIdFilter
	set ref_function_MeleeTrainedUnitIsHeroBJFilter = function MeleeTrainedUnitIsHeroBJFilter
	set ref_function_LivingPlayerUnitsOfTypeIdFilter = function LivingPlayerUnitsOfTypeIdFilter
	set ref_function_QueuedTriggerDoneBJ = function QueuedTriggerDoneBJ
	set ref_function_SetDNCSoundsDawn = function SetDNCSoundsDawn
	set ref_function_SetDNCSoundsDusk = function SetDNCSoundsDusk
	set ref_function_SetDNCSoundsDay = function SetDNCSoundsDay
	set ref_function_SetDNCSoundsNight = function SetDNCSoundsNight
	set ref_function_StartStockUpdates = function StartStockUpdates
	set ref_function_RemovePurchasedItem = function RemovePurchasedItem
	set ref_function_MarkGameStarted = function MarkGameStarted
	set ref_function_PerformStockUpdates = function PerformStockUpdates
	set ref_function_UpdateEachStockBuildingEnum = function UpdateEachStockBuildingEnum
	set ref_function_DelayedSuspendDecay = function DelayedSuspendDecay
	set ref_function_MeleeTriggerTournamentFinishSoon = function MeleeTriggerTournamentFinishSoon
	set ref_function_MeleeTriggerTournamentFinishNow = function MeleeTriggerTournamentFinishNow
	set ref_function_MeleeTriggerActionConstructCancel = function MeleeTriggerActionConstructCancel
	set ref_function_MeleeTriggerActionUnitDeath = function MeleeTriggerActionUnitDeath
	set ref_function_MeleeTriggerActionUnitConstructionStart = function MeleeTriggerActionUnitConstructionStart
	set ref_function_MeleeTriggerActionPlayerDefeated = function MeleeTriggerActionPlayerDefeated
	set ref_function_MeleeTriggerActionPlayerLeft = function MeleeTriggerActionPlayerLeft
	set ref_function_MeleeTriggerActionAllianceChange = function MeleeTriggerActionAllianceChange
	set ref_function_MeleeTriggerActionPlayerLeft_2 = function MeleeTriggerActionPlayerLeft
	set ref_function_MeleeTriggerActionAllianceChange_2 = function MeleeTriggerActionAllianceChange
	set ref_function_MeleeDoDrawEnum = function MeleeDoDrawEnum
	set ref_function_MeleeDoDefeatEnum = function MeleeDoDefeatEnum
	set ref_function_MeleeDoVictoryEnum = function MeleeDoVictoryEnum
	set ref_function_MeleeDoDefeatEnum_2 = function MeleeDoDefeatEnum
	set ref_function_MeleeDoVictoryEnum_2 = function MeleeDoVictoryEnum
	set ref_function_MeleeCrippledPlayerTimeout = function MeleeCrippledPlayerTimeout
	set ref_function_MeleeEnumFindNearestMine = function MeleeEnumFindNearestMine
	set ref_function_MeleeClearExcessUnit = function MeleeClearExcessUnit
	set ref_function_MeleeGrantItemsToTrainedHero = function MeleeGrantItemsToTrainedHero
	set ref_function_MeleeGrantItemsToHiredHero = function MeleeGrantItemsToHiredHero
	set ref_function_SetPlayerColorBJEnum = function SetPlayerColorBJEnum
	set ref_function_TriggerActionUnitRescuedBJ = function TriggerActionUnitRescuedBJ
	set ref_function_MakeUnitRescuableToForceBJEnum = function MakeUnitRescuableToForceBJEnum
	set ref_function_FinishCinematicFadeBJ = function FinishCinematicFadeBJ
	set ref_function_ContinueCinematicFadeBJ = function ContinueCinematicFadeBJ
	set ref_function_SetCineModeVolumeGroupsImmediateBJ = function SetCineModeVolumeGroupsImmediateBJ
	set ref_function_CancelCineSceneBJ = function CancelCineSceneBJ
	set ref_function_CustomDefeatRestartBJ = function CustomDefeatRestartBJ
	set ref_function_CustomDefeatReduceDifficultyBJ = function CustomDefeatReduceDifficultyBJ
	set ref_function_CustomDefeatLoadBJ = function CustomDefeatLoadBJ
	set ref_function_CustomDefeatQuitBJ = function CustomDefeatQuitBJ
	set ref_function_CustomVictoryOkBJ = function CustomVictoryOkBJ
	set ref_function_CustomVictoryQuitBJ = function CustomVictoryQuitBJ
	set ref_function_MakeUnitsPassiveForPlayerEnum = function MakeUnitsPassiveForPlayerEnum
	set ref_function_CountUnitsInGroupEnum = function CountUnitsInGroupEnum
	set ref_function_GetRandomSubGroupEnum = function GetRandomSubGroupEnum
	set ref_function_CountPlayersInForceEnum = function CountPlayersInForceEnum
	set ref_function_GroupAddGroupEnum = function GroupAddGroupEnum
	set ref_function_ForcePickRandomPlayerEnum = function ForcePickRandomPlayerEnum
	set ref_function_GroupPickRandomUnitEnum = function GroupPickRandomUnitEnum
	set ref_function_GroupRemoveGroupEnum = function GroupRemoveGroupEnum
	set ref_function_NearbyElevatorExistsEnum = function NearbyElevatorExistsEnum
	set ref_function_FindElevatorWallBlockerEnum = function FindElevatorWallBlockerEnum
	set ref_function_NudgeUnitsInRectEnum = function NudgeUnitsInRectEnum
	set ref_function_NudgeItemsInRectEnum = function NudgeItemsInRectEnum
	set ref_function_RandomDestructableInRectBJEnum = function RandomDestructableInRectBJEnum
	set ref_function_PauseAllUnitsBJEnum = function PauseAllUnitsBJEnum
	set ref_function_WakePlayerUnitsEnum = function WakePlayerUnitsEnum
	set ref_function_IsUnitGroupInRectBJEnum = function IsUnitGroupInRectBJEnum
	set ref_function_IsUnitGroupEmptyBJEnum = function IsUnitGroupEmptyBJEnum
	set ref_function_IsUnitGroupDeadBJEnum = function IsUnitGroupDeadBJEnum
	set ref_function_SelectGroupBJEnum = function SelectGroupBJEnum
	set ref_function_SelectGroupBJEnum_2 = function SelectGroupBJEnum
	set ref_function_DelayedSuspendDecayStopAnimEnum = function DelayedSuspendDecayStopAnimEnum
	set ref_function_DelayedSuspendDecayStopAnimEnum_2 = function DelayedSuspendDecayStopAnimEnum
	set ref_function_DelayedSuspendDecayFleshEnum = function DelayedSuspendDecayFleshEnum
	set ref_function_DelayedSuspendDecayBoneEnum = function DelayedSuspendDecayBoneEnum
	set ref_function_DelayedSuspendDecayStopAnimEnum_3 = function DelayedSuspendDecayStopAnimEnum
	set ref_function_GetLastCreatedGroupEnum = function GetLastCreatedGroupEnum
	set ref_function_RandomItemInRectBJEnum = function RandomItemInRectBJEnum
	set ref_function_VolumeGroupResetImmediateBJ = function VolumeGroupResetImmediateBJ
	set ref_function_SetSpeechVolumeGroupsImmediateBJ = function SetSpeechVolumeGroupsImmediateBJ
	set ref_function_RegisterDestDeathInRegionEnum = function RegisterDestDeathInRegionEnum
	set ref_function_Trig_Unbezeichneter_Ausl__ser_003_Actions = function Trig_Unbezeichneter_Ausl__ser_003_Actions
	set ref_function_GroupAddGroupEnum_2 = function GroupAddGroupEnum
	set ref_function_resetCam = function resetCam
	set ref_function_resetCam_2 = function resetCam
	set ref_function_resetCam_3 = function resetCam
	set ref_function_hideItem = function hideItem
	set ref_function_Dot_timerDestroyDot = function Dot_timerDestroyDot
	set ref_function_Buff_createEffect = function Buff_createEffect
	set ref_function_Buff_timerDestroyBuff = function Buff_timerDestroyBuff
	set ref_function_CallbackSingle_staticCallback = function CallbackSingle_staticCallback
	set ref_function_CallbackPeriodic_staticCallback = function CallbackPeriodic_staticCallback
	set ref_function_CallbackCounted_staticCallback = function CallbackCounted_staticCallback
	set ref_function_Image_callShowFadedCallback = function Image_callShowFadedCallback
	set ref_function_Image_callHideFadedCallback = function Image_callHideFadedCallback
	set ref_function_TextTag_destroyTextTag = function TextTag_destroyTextTag
	set ref_function_TextTag_destroyTextTag_2 = function TextTag_destroyTextTag
	set ref_function_TextTag_destroyTextTag_3 = function TextTag_destroyTextTag
	set ref_function_Shield_onExpire = function Shield_onExpire
	set ref_function_Bar_callUpdateEx = function Bar_callUpdateEx
	set ref_function_AreaMarker_destr = function AreaMarker_destr
	set ref_function_playAnimation = function playAnimation
	set ref_function_destroyTimedEffect = function destroyTimedEffect
	set ref_function_destroyTimedFx = function destroyTimedFx
	set ref_function_notDead = function notDead
	set ref_function_ControlPoint_callGroupCheck = function ControlPoint_callGroupCheck
	set ref_function_ControlPoint_callInRangeActions = function ControlPoint_callInRangeActions
	set ref_function_ControlPoint_hideDummy = function ControlPoint_hideDummy
	set ref_function_Spell_timedDisableCastDummy = function Spell_timedDisableCastDummy
	set ref_function_cdt = function cdt
	set ref_function_notUnit = function notUnit
	set ref_function_Unit_callMakeVunerable = function Unit_callMakeVunerable
	set ref_function_Stun_destroyStun = function Stun_destroyStun
	set ref_function_Hero_enableAbilityTimed = function Hero_enableAbilityTimed
	set ref_function_Stun_destroyStun_2 = function Stun_destroyStun
	set ref_function_resetDoubleHit = function resetDoubleHit
	set ref_function_Image_callSrinkCallback = function Image_callSrinkCallback
	set ref_function_Image_callGrowCallback = function Image_callGrowCallback
	set ref_function_SamplePointSpell_callCallback = function SamplePointSpell_callCallback
	set ref_function_TestSpell1_bla = function TestSpell1_bla
	set ref_function_TestSpell1_callCallback = function TestSpell1_callCallback
	set ref_function_RockThrow_rockMoveCall = function RockThrow_rockMoveCall
	set ref_function_Pull2_blackHCall = function Pull2_blackHCall
	set ref_function_Missle_callMove = function Missle_callMove
	set ref_function_Missle_callMove_2 = function Missle_callMove
	set ref_function_actions = function actions
	set ref_function_callback = function callback
	set ref_function_Aura_callCheck = function Aura_callCheck
	set ref_function_CustomBar_copyForce = function CustomBar_copyForce
	set ref_function_CustomBar_lockCallback = function CustomBar_lockCallback
	set ref_function_CustomBar_fadeOutCallback = function CustomBar_fadeOutCallback
	set ref_function_Preload_preload = function Preload_preload
	set ref_function_Preload_createBackground = function Preload_createBackground
	set ref_function_Preload_preload_2 = function Preload_preload
	set ref_function_Preload_preload_3 = function Preload_preload
	set ref_function_ForceIterator_callback = function ForceIterator_callback
	set ref_function_createMultiboard = function createMultiboard
	set ref_function_Bar_updatePos = function Bar_updatePos_2
	set ref_function_Bar_updateVision = function Bar_updateVision_2
	set ref_function_checkDelayed = function checkDelayed
	set ref_function_kill = function kill
	set ref_function_Hero_handleCasts = function Hero_handleCasts
	set ref_function_Hero_checkOrders = function Hero_checkOrders_2
	set ref_function_GetOrders_callOnOrder = function GetOrders_callOnOrder
	set ref_function_Unit_tookDamage = function Unit_tookDamage
	set ref_function_doubleHit = function doubleHit
	set ref_function_trackableHitHandler = function trackableHitHandler
	set ref_function_trackableTrackHandler = function trackableTrackHandler
	set ref_function_trackableDoubleHitHandler = function trackableDoubleHitHandler
	set ref_function_spellCondition = function spellCondition
	set ref_function_spellStart = function spellStart
	set ref_function_updateTime = function updateTime
	set ref_function_setCallLimit = function setCallLimit
	set ref_function_Dot_loopList = function Dot_loopList
	set ref_function_callKnockback = function callKnockback
	set ref_function_camTest = function camTest
	set ref_function_forceKey = function forceKey
	set ref_function_charMessung = function charMessung
	set ref_function_onEsc = function onEsc
	set ref_function_textTag = function textTag
	set ref_function_handleCasts = function handleCasts
endfunction

function init_Array takes nothing returns nothing
	set Array_currentSize = 0
endfunction

function init_Basics takes nothing returns nothing
	set Basics_DUMMY_UNIT_ID = 1697656880
	set Basics_HEIGHT_ENABLER = 1097691750
	set Basics_TREE_RECOGNITION = 1097163124
	set Basics_LOCUST_ID = 1097625443
	set Basics_ANIMATION_PERIOD = 0.03
	set Basics_MAX_COLLISION_SIZE = 197.0
	set Basics_DUMMY_PLAYER = Player(15)
	set Basics_DUMMY_HOSTILE_PLAYER = Player(12)
endfunction

function init_BigNum takes nothing returns nothing
	set BigNum_l_count = 0
endfunction

function init_CaptureAnimation takes nothing returns nothing
	set CaptureAnimation_captureTimer = new_Table()
endfunction

function init_ChannelSpellPreset takes nothing returns nothing
	set ChannelSpellPreset_CHANNEL_ID = "ANcl"
	set ChannelSpellPreset_visibleval = 1
	set ChannelSpellPreset_targetimageval = 2
	set ChannelSpellPreset_physicalspellval = 4
	set ChannelSpellPreset_universalspellval = 8
	set ChannelSpellPreset_uniquecastval = 16
endfunction

function c2sInit takes nothing returns nothing
	set Char_c2s[0] = ""
	set Char_c2s[1] = ""
	set Char_c2s[2] = ""
	set Char_c2s[3] = ""
	set Char_c2s[4] = ""
	set Char_c2s[5] = ""
	set Char_c2s[6] = ""
	set Char_c2s[7] = ""
	set Char_c2s[8] = ""
	set Char_c2s[9] = "\t"
	set Char_c2s[10] = "\n"
	set Char_c2s[11] = ""
	set Char_c2s[12] = ""
	set Char_c2s[13] = "\r"
	set Char_c2s[14] = ""
	set Char_c2s[15] = ""
	set Char_c2s[16] = ""
	set Char_c2s[17] = ""
	set Char_c2s[18] = ""
	set Char_c2s[19] = ""
	set Char_c2s[20] = ""
	set Char_c2s[21] = ""
	set Char_c2s[22] = ""
	set Char_c2s[23] = ""
	set Char_c2s[24] = ""
	set Char_c2s[25] = ""
	set Char_c2s[26] = ""
	set Char_c2s[27] = ""
	set Char_c2s[28] = ""
	set Char_c2s[29] = ""
	set Char_c2s[30] = ""
	set Char_c2s[31] = ""
	set Char_c2s[32] = " "
	set Char_c2s[33] = "!"
	set Char_c2s[34] = "\""
	set Char_c2s[35] = "#"
	set Char_c2s[36] = "$"
	set Char_c2s[37] = "%"
	set Char_c2s[38] = "&"
	set Char_c2s[39] = "'"
	set Char_c2s[40] = "("
	set Char_c2s[41] = ")"
	set Char_c2s[42] = "*"
	set Char_c2s[43] = "+"
	set Char_c2s[44] = ","
	set Char_c2s[45] = "-"
	set Char_c2s[46] = "."
	set Char_c2s[47] = "/"
	set Char_c2s[48] = "0"
	set Char_c2s[49] = "1"
	set Char_c2s[50] = "2"
	set Char_c2s[51] = "3"
	set Char_c2s[52] = "4"
	set Char_c2s[53] = "5"
	set Char_c2s[54] = "6"
	set Char_c2s[55] = "7"
	set Char_c2s[56] = "8"
	set Char_c2s[57] = "9"
	set Char_c2s[58] = ":"
	set Char_c2s[59] = ";"
	set Char_c2s[60] = "<"
	set Char_c2s[61] = "="
	set Char_c2s[62] = ">"
	set Char_c2s[63] = "?"
	set Char_c2s[64] = "@"
	set Char_c2s[65] = "A"
	set Char_c2s[66] = "B"
	set Char_c2s[67] = "C"
	set Char_c2s[68] = "D"
	set Char_c2s[69] = "E"
	set Char_c2s[70] = "F"
	set Char_c2s[71] = "G"
	set Char_c2s[72] = "H"
	set Char_c2s[73] = "I"
	set Char_c2s[74] = "J"
	set Char_c2s[75] = "K"
	set Char_c2s[76] = "L"
	set Char_c2s[77] = "M"
	set Char_c2s[78] = "N"
	set Char_c2s[79] = "O"
	set Char_c2s[80] = "P"
	set Char_c2s[81] = "Q"
	set Char_c2s[82] = "R"
	set Char_c2s[83] = "S"
	set Char_c2s[84] = "T"
	set Char_c2s[85] = "U"
	set Char_c2s[86] = "V"
	set Char_c2s[87] = "W"
	set Char_c2s[88] = "X"
	set Char_c2s[89] = "Y"
	set Char_c2s[90] = "Z"
	set Char_c2s[91] = "["
	set Char_c2s[92] = "\\"
	set Char_c2s[93] = "]"
	set Char_c2s[94] = "^"
	set Char_c2s[95] = "_"
	set Char_c2s[96] = "`"
	set Char_c2s[97] = "a"
	set Char_c2s[98] = "b"
	set Char_c2s[99] = "c"
	set Char_c2s[100] = "d"
	set Char_c2s[101] = "e"
	set Char_c2s[102] = "f"
	set Char_c2s[103] = "g"
	set Char_c2s[104] = "h"
	set Char_c2s[105] = "i"
	set Char_c2s[106] = "j"
	set Char_c2s[107] = "k"
	set Char_c2s[108] = "l"
	set Char_c2s[109] = "m"
	set Char_c2s[110] = "n"
	set Char_c2s[111] = "o"
	set Char_c2s[112] = "p"
	set Char_c2s[113] = "q"
	set Char_c2s[114] = "r"
	set Char_c2s[115] = "s"
	set Char_c2s[116] = "t"
	set Char_c2s[117] = "u"
	set Char_c2s[118] = "v"
	set Char_c2s[119] = "w"
	set Char_c2s[120] = "x"
	set Char_c2s[121] = "y"
	set Char_c2s[122] = "z"
	set Char_c2s[123] = "{"
	set Char_c2s[124] = "|"
	set Char_c2s[125] = "}"
	set Char_c2s[126] = "~"
	set Char_c2s[127] = ""
endfunction

function s2cInit takes nothing returns nothing
	local integer i_2 = 0
	local integer temp = Char_MAX_INDEX
	loop
		exitwhen i_2 > temp
		if StringCase(Char_c2s[i_2], true) == Char_c2s[i_2] then
			set Char_s2c[StringHash(Char_c2s[i_2]) / 2033480 + 1002] = i_2
		endif
		set i_2 = i_2 + 1
	endloop
endfunction

function widthInit takes nothing returns nothing
	set Char_width[0] = 0.
	set Char_width[1] = 0.
	set Char_width[2] = 0.
	set Char_width[3] = 0.
	set Char_width[4] = 0.
	set Char_width[5] = 0.
	set Char_width[6] = 0.
	set Char_width[7] = 0.
	set Char_width[8] = 0.
	set Char_width[9] = 0.
	set Char_width[10] = 1000000000.
	set Char_width[11] = 0.
	set Char_width[12] = 0.
	set Char_width[13] = 0.
	set Char_width[14] = 0.
	set Char_width[15] = 0.
	set Char_width[16] = 0.
	set Char_width[17] = 0.
	set Char_width[18] = 0.
	set Char_width[19] = 0.
	set Char_width[20] = 0.
	set Char_width[21] = 0.
	set Char_width[22] = 0.
	set Char_width[23] = 0.
	set Char_width[24] = 0.
	set Char_width[25] = 0.
	set Char_width[26] = 0.
	set Char_width[27] = 0.
	set Char_width[28] = 0.
	set Char_width[29] = 0.
	set Char_width[30] = 0.
	set Char_width[31] = 0.
	set Char_width[32] = 1.5
	set Char_width[33] = 1.2
	set Char_width[34] = 1.95
	set Char_width[35] = 4.
	set Char_width[36] = 3.1
	set Char_width[37] = 4.2
	set Char_width[38] = 5.1
	set Char_width[39] = 0.85
	set Char_width[40] = 1.8
	set Char_width[41] = 1.6
	set Char_width[42] = 2.5
	set Char_width[43] = 3.1
	set Char_width[44] = 1.25
	set Char_width[45] = 2.2
	set Char_width[46] = 1.05
	set Char_width[47] = 2.7
	set Char_width[48] = 2.
	set Char_width[49] = 2.
	set Char_width[50] = 3.65
	set Char_width[51] = 3.25
	set Char_width[52] = 3.8
	set Char_width[53] = 3.3
	set Char_width[54] = 3.5
	set Char_width[55] = 3.3
	set Char_width[56] = 3.65
	set Char_width[57] = 3.65
	set Char_width[58] = 1.05
	set Char_width[59] = 1.25
	set Char_width[60] = 2.9
	set Char_width[61] = 3.1
	set Char_width[62] = 2.9
	set Char_width[63] = 2.7
	set Char_width[64] = 4.5
	set Char_width[65] = 4.8
	set Char_width[66] = 3.5
	set Char_width[67] = 4.
	set Char_width[68] = 4.2
	set Char_width[69] = 3.3
	set Char_width[70] = 2.75
	set Char_width[71] = 4.35
	set Char_width[72] = 4.35
	set Char_width[73] = 1.6
	set Char_width[74] = 2.
	set Char_width[75] = 4.0
	set Char_width[76] = 3.25
	set Char_width[77] = 6.
	set Char_width[78] = 4.4
	set Char_width[79] = 4.95
	set Char_width[80] = 3.3
	set Char_width[81] = 5.3
	set Char_width[82] = 4.
	set Char_width[83] = 3.3
	set Char_width[84] = 3.4
	set Char_width[85] = 4.2
	set Char_width[86] = 4.
	set Char_width[87] = 6.25
	set Char_width[88] = 4.35
	set Char_width[89] = 3.45
	set Char_width[90] = 3.3
	set Char_width[91] = 1.8
	set Char_width[92] = 2.3
	set Char_width[93] = 1.55
	set Char_width[94] = 3.3
	set Char_width[95] = 3.3
	set Char_width[96] = 1.8
	set Char_width[97] = 3.3
	set Char_width[98] = 3.3
	set Char_width[99] = 3.1
	set Char_width[100] = 3.5
	set Char_width[101] = 3.3
	set Char_width[102] = 2.1
	set Char_width[103] = 3.8
	set Char_width[104] = 3.3
	set Char_width[105] = 1.25
	set Char_width[106] = 1.6
	set Char_width[107] = 3.3
	set Char_width[108] = 1.3
	set Char_width[109] = 5.3
	set Char_width[110] = 3.3
	set Char_width[111] = 3.5
	set Char_width[112] = 3.5
	set Char_width[113] = 3.5
	set Char_width[114] = 2.
	set Char_width[115] = 2.9
	set Char_width[116] = 2.15
	set Char_width[117] = 3.3
	set Char_width[118] = 3.65
	set Char_width[119] = 5.15
	set Char_width[120] = 3.4
	set Char_width[121] = 3.45
	set Char_width[122] = 3.3
	set Char_width[123] = 1.8
	set Char_width[124] = 1.
	set Char_width[125] = 1.8
	set Char_width[126] = 3.3
	set Char_width[127] = 0.
endfunction

function init_Char takes nothing returns nothing
	set Char_MAX_INDEX = 126 + 1
	set Char_DEFAULT_WIDTH = 0.
	set Char_DEFAULT_STRING = ""
	call c2sInit()
	call s2cInit()
	call widthInit()
endfunction

function alloc_HashMap takes nothing returns integer
	local integer this_43
	if HashMap_firstFree == 0 then
		set HashMap_maxIndex = HashMap_maxIndex + 1
		set this_43 = HashMap_maxIndex
	else
		set this_43 = HashMap_firstFree
		set HashMap_firstFree = HashMap_nextFree[HashMap_firstFree]
		set HashMap_nextFree[this_43] = 0
	endif
	set HashMap_typeId[this_43] = 608
	return this_43
endfunction

function construct_HashMap takes integer this_43 returns nothing
endfunction

function new_HashMap takes nothing returns integer
	local integer this_43 = alloc_HashMap()
	call construct_HashMap(this_43)
	return this_43
endfunction

function trigger_addAction takes trigger this_43, code actionFunc returns trigger
	call TriggerAddAction(this_43, actionFunc)
	return this_43
endfunction

function trigger_registerAnyUnitEvent takes trigger this_43, playerunitevent whichEvent returns trigger
	call TriggerRegisterAnyUnitEventBJ(this_43, whichEvent)
	return this_43
endfunction

function init_ClosureEvents takes nothing returns nothing
	call trigger_addAction(trigger_registerAnyUnitEvent(CreateTrigger(), EVENT_PLAYER_UNIT_SPELL_CAST), ref_function_handleCasts)
	set OnCast_casts = new_HashMap()
	set OnPointCast_casts = new_HashMap()
	set OnUnitCast_casts = new_HashMap()
endfunction

function init_Colors takes nothing returns nothing
	local integer i_2 = 0
	local integer i2
	local integer tempIndex
	local integer tempIndex_2
	local integer tempIndex_3
	local integer tempIndex_4
	local integer tempIndex_5
	local integer tempIndex_6
	local integer tempIndex_7
	local integer tempIndex_8
	local integer tempIndex_9
	local integer tempIndex_10
	local integer tempIndex_11
	local integer tempIndex_12
	local integer tempIndex_13
	loop
		exitwhen i_2 > 9
		set Colors_hexs[i_2] = int_toString(i_2)
		set i_2 = i_2 + 1
	endloop
	set Colors_hexs[10] = "A"
	set Colors_hexs[11] = "B"
	set Colors_hexs[12] = "C"
	set Colors_hexs[13] = "D"
	set Colors_hexs[14] = "E"
	set Colors_hexs[15] = "F"
	set Colors_decs = new_Table()
	set i2 = 0
	loop
		exitwhen i2 > 9
		call dispatch_Table_saveInt(Colors_decs, StringHash(int_toString(i2)), i2)
		set i2 = i2 + 1
	endloop
	call dispatch_Table_saveInt(Colors_decs, StringHash("A"), 10)
	call dispatch_Table_saveInt(Colors_decs, StringHash("B"), 11)
	call dispatch_Table_saveInt(Colors_decs, StringHash("C"), 12)
	call dispatch_Table_saveInt(Colors_decs, StringHash("D"), 13)
	call dispatch_Table_saveInt(Colors_decs, StringHash("E"), 14)
	call dispatch_Table_saveInt(Colors_decs, StringHash("F"), 15)
	set tempIndex = 0
	set Colors_playercolors[tempIndex] = 255
	set Colors_playercolors_2[tempIndex] = 255
	set Colors_playercolors_3[tempIndex] = 255
	set tempIndex_2 = 1
	set Colors_playercolors[tempIndex_2] = 255
	set Colors_playercolors_2[tempIndex_2] = 2
	set Colors_playercolors_3[tempIndex_2] = 2
	set tempIndex_3 = 2
	set Colors_playercolors[tempIndex_3] = 0
	set Colors_playercolors_2[tempIndex_3] = 65
	set Colors_playercolors_3[tempIndex_3] = 255
	set tempIndex_4 = 3
	set Colors_playercolors[tempIndex_4] = 27
	set Colors_playercolors_2[tempIndex_4] = 230
	set Colors_playercolors_3[tempIndex_4] = 184
	set tempIndex_5 = 4
	set Colors_playercolors[tempIndex_5] = 83
	set Colors_playercolors_2[tempIndex_5] = 0
	set Colors_playercolors_3[tempIndex_5] = 128
	set tempIndex_6 = 5
	set Colors_playercolors[tempIndex_6] = 255
	set Colors_playercolors_2[tempIndex_6] = 204
	set Colors_playercolors_3[tempIndex_6] = 0
	set tempIndex_7 = 6
	set Colors_playercolors[tempIndex_7] = 255
	set Colors_playercolors_2[tempIndex_7] = 255
	set Colors_playercolors_3[tempIndex_7] = 1
	set tempIndex_8 = 7
	set Colors_playercolors[tempIndex_8] = 31
	set Colors_playercolors_2[tempIndex_8] = 191
	set Colors_playercolors_3[tempIndex_8] = 0
	set tempIndex_9 = 8
	set Colors_playercolors[tempIndex_9] = 229
	set Colors_playercolors_2[tempIndex_9] = 90
	set Colors_playercolors_3[tempIndex_9] = 175
	set tempIndex_10 = 9
	set Colors_playercolors[tempIndex_10] = 148
	set Colors_playercolors_2[tempIndex_10] = 149
	set Colors_playercolors_3[tempIndex_10] = 150
	set tempIndex_11 = 10
	set Colors_playercolors[tempIndex_11] = 125
	set Colors_playercolors_2[tempIndex_11] = 190
	set Colors_playercolors_3[tempIndex_11] = 241
	set tempIndex_12 = 11
	set Colors_playercolors[tempIndex_12] = 15
	set Colors_playercolors_2[tempIndex_12] = 97
	set Colors_playercolors_3[tempIndex_12] = 69
	set tempIndex_13 = 12
	set Colors_playercolors[tempIndex_13] = 77
	set Colors_playercolors_2[tempIndex_13] = 41
	set Colors_playercolors_3[tempIndex_13] = 3
endfunction

function init_ControlPoint takes nothing returns nothing
	set ControlPoint_range = 900.
	set ControlPoint_captureRange = 800.
	set ControlPoint_model = 1668314212
	set ControlPoint_morphAbi = 1668575341
	set ControlPoint_height = 335.
	set ControlPoint_baseDmg = 2.
	set ControlPoint_dmgPerLvl = 1.
	set ControlPoint_percentualDmg = 0.2
	set ControlPoint_heroDmgFactor = 0.1
	set ControlPoint_unitDmgFactor = 0.01
	set ControlPoint_creepDmg = 0.75
	set ControlPoint_captureSpeedPoint = 0.0125
	set ControlPoint_captureSpeedHero = 0.009
	set ControlPoint_baseSHeal = 2.0
	set ControlPoint_heroSHealFactor = 0.1
	set ControlPoint_unitSHealFactor = 0.025
endfunction

function init_Cooldown takes nothing returns nothing
	set Cooldown_count = 100
	set Cooldown_lastAbi = 0
	set Cooldown_cdIcon[1] = 1127231537
	set Cooldown_cdIcon[2] = 1127231538
	set Cooldown_cdIcon[3] = 1127231539
	set Cooldown_cdIcon[4] = 1127231540
	set Cooldown_cdIcon[5] = 1127231541
	set Cooldown_cdIcon[6] = 1127231542
	set Cooldown_cdIcon[7] = 1127231543
	set Cooldown_cdIcon[8] = 1127231544
	set Cooldown_cdIcon[9] = 1127231545
	set Cooldown_cdIcon[10] = 1127231792
	set Cooldown_cdIcon[20] = 1127232048
	set Cooldown_cdIcon[30] = 1127232304
	set Cooldown_cdIcon[40] = 1127232560
	set Cooldown_cdIcon[50] = 1127232816
	set Cooldown_cdIcon[60] = 1127233072
	set Cooldown_cdIcon[70] = 1127233328
	set Cooldown_cdIcon[80] = 1127233584
	set Cooldown_cdIcon[90] = 1127233840
	set Cooldown_cdIcon[100] = 1127297072
endfunction

function init_CustomBar takes nothing returns nothing
	set CustomBar_DEFAULT_BACKGROUND = -16777216
	set CustomBar_DEFAULT_FOREGROUND = -1
	set CustomBar_MAX_GRADIENTS = 10
	set CustomBar_count = 0
	set CustomBar_animationTimer = CreateTimer()
endfunction

function init_DebugFile takes nothing returns nothing
	call PreloadGenClear()
	set DebugFile_path = "C:\\Users\\Crigges\\Dropbox\\wurst"
	set DebugFile_filetype = ".debug"
	set DebugFile_lastSavedFile = 0
endfunction

function init_Dot takes nothing returns nothing
	set LinkedListModule_first = 0
	set LinkedListModule_last = 0
	set LinkedListModule_size = 0
endfunction

function init_DummyRecycler takes nothing returns nothing
	local integer endPos
	local integer n
	local real angl
	local real x
	local real y
	local integer i_2
	set DummyRecycler_ANG_N = 8
	set DummyRecycler_ANG_STORAGE_MAX = 12
	set DummyRecycler_DEATH_TIME = 2.
	set DummyRecycler_ANG_VAL = 360 / DummyRecycler_ANG_N
	set DummyRecycler_ANG_MID = DummyRecycler_ANG_VAL / 2
	set DummyRecycler_recycle = 0
	set DummyRecycler_protect = CreateGroup()
	set LinkedListModule_first_3 = 0
	set LinkedListModule_last_3 = 0
	set LinkedListModule_size_3 = 0
	set n = DummyRecycler_ANG_N
	set x = MapBounds_mapMaxX
	set y = MapBounds_mapMaxY
	set i_2 = DummyRecycler_ANG_N
	loop
		exitwhen i_2 < 0
		set DummyRecycler_stackN[i_2] = DummyRecycler_ANG_STORAGE_MAX
		set DummyRecycler_queueNext[i_2] = n
		set angl = int_toReal(i_2 * DummyRecycler_ANG_VAL + DummyRecycler_ANG_MID)
		set endPos = n + DummyRecycler_ANG_STORAGE_MAX
		set DummyRecycler_queueLast[i_2] = endPos - 1
		loop
			exitwhen  not (n < endPos)
			set DummyRecycler_queueNext[n] = n + 1
			set DummyRecycler_stack[n] = CreateUnit(Basics_DUMMY_PLAYER, Basics_DUMMY_UNIT_ID, x, y, angl)
			call unit_pause(unit_addAbility(unit_removeAbility(unit_addAbility(DummyRecycler_stack[n], Basics_HEIGHT_ENABLER), Basics_HEIGHT_ENABLER), Basics_LOCUST_ID))
			set n = n + 1
		endloop
		set DummyRecycler_queueNext[n - 1] = 0
		set i_2 = i_2 - 1
	endloop
	call TimerStart(CreateTimer(), 0.1, true, ref_function_checkDelayed)
endfunction

function TextTag_classname takes nothing returns string
	return "TextTag"
endfunction

function registerNewInstanceEntry takes string name returns integer
	set InstanceBoard_classes = InstanceBoard_classes + 1
	set InstanceBoard_nameOfClass[InstanceBoard_classes] = name
	return InstanceBoard_classes
endfunction

function init_FloatingText takes nothing returns nothing
	set ShowInstances_classId = registerNewInstanceEntry(TextTag_classname())
endfunction

function Preload_startPreload takes nothing returns nothing
	call timer_start(getTimer(), 0.0, ref_function_Preload_preload)
	call timer_start(getTimer(), 1.0, ref_function_Preload_createBackground)
endfunction

function alloc_Closure_10 takes nothing returns integer
	local integer this_43
	if Action_firstFree == 0 then
		set Action_maxIndex = Action_maxIndex + 1
		set this_43 = Action_maxIndex
	else
		set this_43 = Action_firstFree
		set Action_firstFree = Action_nextFree[Action_firstFree]
		set Action_nextFree[this_43] = 0
	endif
	set Action_typeId[this_43] = 729
	return this_43
endfunction

function texttag_setColor takes texttag this_43, integer col_red, integer col_green, integer col_blue, integer col_alpha returns texttag
	call SetTextTagColor(this_43, col_red, col_green, col_blue, col_alpha)
	return this_43
endfunction

function texttag_setLifespan takes texttag this_43, real span returns texttag
	call SetTextTagLifespan(this_43, span)
	return this_43
endfunction

function texttag_setPermanent takes texttag this_43, boolean flag returns texttag
	call SetTextTagPermanent(this_43, flag)
	return this_43
endfunction

function texttag_setText takes texttag this_43, string text, real size returns texttag
	call SetTextTagText(this_43, text, size * 0.0023)
	return this_43
endfunction

function vec2_withZ takes real this_x, real this_y, real z returns real
	set vec2_withZ_return_x = this_x
	set vec2_withZ_return_y = this_y
	set vec2_withZ_return_z = z
	return vec2_withZ_return_x
endfunction

function createTTEx takes real pos_x, real pos_y, real pos_z, string message, real size, integer col_red, integer col_green, integer col_blue, integer col_alpha returns texttag
	local texttag tt = CreateTextTag()
	call texttag_setPermanent(texttag_setLifespan(texttag_setColor(texttag_setPos(texttag_setText(tt, message, size), vec2_withZ(vec3_toVec2(pos_x, pos_y, pos_z), vec3_toVec2_return_y, 20.), vec2_withZ_return_y, vec2_withZ_return_z), col_red, col_green, col_blue, col_alpha), 2000.), false)
	set createTTExtempReturn = tt
	set tt = null
	return createTTExtempReturn
endfunction

function alloc_LLEntry takes nothing returns integer
	local integer this_43
	if LLEntry_firstFree == 0 then
		set LLEntry_maxIndex = LLEntry_maxIndex + 1
		set this_43 = LLEntry_maxIndex
	else
		set this_43 = LLEntry_firstFree
		set LLEntry_firstFree = LLEntry_nextFree[LLEntry_firstFree]
		set LLEntry_nextFree[this_43] = 0
	endif
	set LLEntry_typeId[this_43] = 2
	return this_43
endfunction

function construct_LLEntry takes integer this_43, integer elem, integer prev, integer next returns nothing
	set LLEntry_elem[this_43] = elem
	set LLEntry_prev[this_43] = prev
	set LLEntry_next[this_43] = next
endfunction

function new_LLEntry takes integer elem, integer prev, integer next returns integer
	local integer this_43 = alloc_LLEntry()
	call construct_LLEntry(this_43, elem, prev, next)
	return this_43
endfunction

function LinkedList_add takes integer this_43, integer elem returns nothing
	local integer entry = new_LLEntry(elem, LLEntry_prev[LinkedList_dummy[this_43]], LinkedList_dummy[this_43])
	set LLEntry_next[LLEntry_prev[LinkedList_dummy[this_43]]] = entry
	set LLEntry_prev[LinkedList_dummy[this_43]] = entry
	set LinkedList_size[this_43] = LinkedList_size[this_43] + 1
endfunction

function dispatch_LinkedList_add takes integer this_43, integer elem returns nothing
	if LinkedList_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling LinkedList.add")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called LinkedList.add on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call LinkedList_add(this_43, elem)
endfunction

function alloc_ControlPoint takes nothing returns integer
	local integer this_43
	if ControlPoint_firstFree == 0 then
		set ControlPoint_maxIndex = ControlPoint_maxIndex + 1
		set this_43 = ControlPoint_maxIndex
	else
		set this_43 = ControlPoint_firstFree
		set ControlPoint_firstFree = ControlPoint_nextFree[ControlPoint_firstFree]
		set ControlPoint_nextFree[this_43] = 0
	endif
	set ControlPoint_typeId[this_43] = 627
	return this_43
endfunction

function createUnit_2 takes player p, integer unitId, real pos_x, real pos_y, real facing_radians returns unit
	return CreateUnit(p, unitId, pos_x, pos_y, angle_degrees(facing_radians))
endfunction

function unit_setUserData takes unit this_43, integer data returns unit
	call SetUnitUserData(this_43, data)
	return this_43
endfunction

function construct_ControlPoint takes integer this_43, real pos_x, real pos_y, player owner returns nothing
	local timer t3
	local integer tempIndex
	set ControlPoint_inRange[this_43] = CreateGroup()
	set ControlPoint_enemyHerosInGroup[this_43] = 0
	set ControlPoint_allyHerosInGroup[this_43] = 0
	set ControlPoint_enemysInGroup[this_43] = 0
	set ControlPoint_allysInGroup[this_43] = 0
	set ControlPoint_t1[this_43] = getTimer()
	set ControlPoint_t2[this_43] = getTimer()
	set ControlPoint_hp[this_43] = 1.
	set ControlPoint_clickDummy[this_43] = createUnit_2(owner, ControlPoint_model, pos_x, pos_y, 0.)
	call unit_addAbility(ControlPoint_clickDummy[this_43], ControlPoint_morphAbi)
	call unit_setUserData(ControlPoint_clickDummy[this_43], this_43)
	set ControlPoint_visualDummy[this_43] = createUnit_2(owner, 1747988531, pos_x, pos_y, 0.)
	set tempIndex = this_43
	set ControlPoint_pos[tempIndex] = pos_x - 10.
	set ControlPoint_pos_2[tempIndex] = pos_y - 25.
	set ControlPoint_pos_3[tempIndex] = ControlPoint_height
	set ControlPoint_owner[this_43] = owner
	call timer_setData(ControlPoint_t1[this_43], this_43)
	call timer_startPeriodic(ControlPoint_t1[this_43], 0.10, ref_function_ControlPoint_callGroupCheck)
	call timer_setData(ControlPoint_t2[this_43], this_43)
	call timer_startPeriodic(ControlPoint_t2[this_43], 0.03, ref_function_ControlPoint_callInRangeActions)
	set t3 = getTimer()
	call timer_setData(t3, this_43)
	call timer_start(t3, 1., ref_function_ControlPoint_hideDummy)
	set t3 = null
endfunction

function new_ControlPoint takes real pos_x, real pos_y, player owner returns integer
	local integer this_43 = alloc_ControlPoint()
	call construct_ControlPoint(this_43, pos_x, pos_y, owner)
	return this_43
endfunction

function alloc_Hero takes nothing returns integer
	local integer this_43
	if Unit_firstFree == 0 then
		set Unit_maxIndex = Unit_maxIndex + 1
		set this_43 = Unit_maxIndex
	else
		set this_43 = Unit_firstFree
		set Unit_firstFree = Unit_nextFree[Unit_firstFree]
		set Unit_nextFree[this_43] = 0
	endif
	set Unit_typeId[this_43] = 685
	return this_43
endfunction

function trigger_registerUnitEvent takes trigger this_43, unit whichUnit, unitevent whichEvent returns trigger
	call TriggerRegisterUnitEvent(this_43, whichUnit, whichEvent)
	return this_43
endfunction

function GetOrders_addOrderDetection takes unit u returns nothing
	call trigger_registerUnitEvent(GetOrders_orderDetect, u, EVENT_UNIT_ISSUED_ORDER)
	call trigger_registerUnitEvent(GetOrders_orderDetect, u, EVENT_UNIT_ISSUED_POINT_ORDER)
	call trigger_registerUnitEvent(GetOrders_orderDetect, u, EVENT_UNIT_ISSUED_TARGET_ORDER)
endfunction

function alloc_ShieldList takes nothing returns integer
	local integer this_43
	if ShieldList_firstFree == 0 then
		set ShieldList_maxIndex = ShieldList_maxIndex + 1
		set this_43 = ShieldList_maxIndex
	else
		set this_43 = ShieldList_firstFree
		set ShieldList_firstFree = ShieldList_nextFree[ShieldList_firstFree]
		set ShieldList_nextFree[this_43] = 0
	endif
	set ShieldList_typeId[this_43] = 616
	return this_43
endfunction

function construct_ShieldList takes integer this_43 returns nothing
	set ShieldList_first[this_43] = 0
	set ShieldList_last[this_43] = 0
	set ShieldList_shieldSum[this_43] = 0.
endfunction

function new_ShieldList takes nothing returns integer
	local integer this_43 = alloc_ShieldList()
	call construct_ShieldList(this_43)
	return this_43
endfunction

function alloc_TList takes nothing returns integer
	local integer this_43
	if TList_firstFree == 0 then
		set TList_maxIndex = TList_maxIndex + 1
		set this_43 = TList_maxIndex
	else
		set this_43 = TList_firstFree
		set TList_firstFree = TList_nextFree[TList_firstFree]
		set TList_nextFree[this_43] = 0
	endif
	set TList_typeId[this_43] = 12
	return this_43
endfunction

function construct_TList takes integer this_43 returns nothing
	set TList_size[this_43] = 0
endfunction

function new_TList takes nothing returns integer
	local integer this_43 = alloc_TList()
	call construct_TList(this_43)
	return this_43
endfunction

function unit_getMoveSpeed takes unit this_43 returns real
	return GetUnitMoveSpeed(this_43)
endfunction

function unit_getOwner takes unit this_43 returns player
	return GetOwningPlayer(this_43)
endfunction

function construct_Unit takes integer this_43, unit u, real attack, real mass, real radius, real height, integer bounty returns nothing
	local multiboarditem mbi
	local integer i_2
	set Unit_attack[this_43] = 0.
	set Unit_bonusAttack[this_43] = 0.
	set Unit_bonusAttackPer[this_43] = 0.
	set Unit_armor[this_43] = 0.
	set Unit_bonusArmor[this_43] = 0.
	set Unit_bonusArmorPer[this_43] = 0.
	set Unit_life[this_43] = 0.
	set Unit_bonusLife[this_43] = 0.
	set Unit_bonusLifePer[this_43] = 0.
	set Unit_mana[this_43] = 0.
	set Unit_bonusMana[this_43] = 0.
	set Unit_bonusManaPer[this_43] = 0.
	set Unit_lifeReg[this_43] = 0.
	set Unit_bonusLifeReg[this_43] = 0.
	set Unit_bonusLifeRegPer[this_43] = 0.
	set Unit_manaReg[this_43] = 0.
	set Unit_bonusManaReg[this_43] = 0.
	set Unit_bonusManaRegPer[this_43] = 0.
	set Unit_bonusAttackspeed[this_43] = 0.
	set Unit_spellpower[this_43] = 0.
	set Unit_spellpowerPer[this_43] = 0.
	set Unit_movespeed[this_43] = 0.
	set Unit_bonusMovespeed[this_43] = 0.
	set Unit_bonusMovespeedPer[this_43] = 0.
	set Unit_magicReduction[this_43] = 0.
	set Unit_normalReduction[this_43] = 0.
	set Unit_resistance[this_43] = 0.
	set Unit_bonusResistance[this_43] = 0.
	set Unit_bonusResistancePer[this_43] = 0.
	set Unit_hitchance[this_43] = 97.
	set Unit_evade[this_43] = 3.
	set Unit_critchance[this_43] = 5.
	set Unit_critdamage[this_43] = 0.
	set Unit_bonusDamage[this_43] = 0.
	set Unit_magicDeflection[this_43] = 0.
	set Unit_normalDeflection[this_43] = 0.
	set Unit_lifesteal[this_43] = 0.
	set Unit_bonusHeal[this_43] = 0.
	set Unit_vunerableCount[this_43] = 0
	set Unit_vunerable[this_43] = true
	set Unit_lastDamager[this_43] = 0
	set Unit_lastHeroDamager[this_43] = 0
	set Unit_mass[this_43] = 0.
	set Unit_bonusMass[this_43] = 0.
	set Unit_bonusMassPer[this_43] = 0.
	set Unit_knockX[this_43] = 0.
	set Unit_knockY[this_43] = 0.
	set Unit_radius[this_43] = 0.
	set Unit_height[this_43] = 0.
	set Unit_lastKnocker[this_43] = 0
	set Unit_lastCollision[this_43] = 0
	set Unit_wallLocX[this_43] = 0.
	set Unit_wallLocY[this_43] = 0.
	set Unit_hasKnockback[this_43] = false
	set Unit_isHero[this_43] = false
	set Unit_isDead[this_43] = false
	set Unit_level[this_43] = 1
	set Unit_bounty[this_43] = 0
	set Unit_ownerId[this_43] = 0
	set Unit_owner[this_43] = null
	set Unit_stun[this_43] = 0
	set Unit_damageTT[this_43] = 0
	set Unit_healTT[this_43] = 0
	set Unit_dotTT[this_43] = 0
	set Unit_percentDamage[this_43] = new_Table()
	set Unit_allDots[this_43] = new_TList()
	set Unit_allBuffs[this_43] = new_TList()
	set Unit_causeNormalDamagePre[this_43] = 0
	set Unit_causeNormalDamageOn[this_43] = 0
	set Unit_takeNormalDamagePre[this_43] = 0
	set Unit_takeNormalDamageOn[this_43] = 0
	set Unit_causeMagicDamagePre[this_43] = 0
	set Unit_causeMagicDamageOn[this_43] = 0
	set Unit_takeMagicDamagePre[this_43] = 0
	set Unit_takeMagicDamageOn[this_43] = 0
	set Unit_takeHitPre[this_43] = 0
	set Unit_takeHitOn[this_43] = 0
	set Unit_causeHitPre[this_43] = 0
	set Unit_causeHitOn[this_43] = 0
	set Unit_takeCritHitOn[this_43] = 0
	set Unit_causeCritHitOn[this_43] = 0
	set Unit_onDodge[this_43] = 0
	set Unit_onMiss[this_43] = 0
	set Unit_onDeath[this_43] = 0
	set Unit_causeDeath[this_43] = 0
	set Unit_takeSpell[this_43] = 0
	set Unit_causeSpell[this_43] = 0
	set Unit_takeHeal[this_43] = 0
	set Unit_causeHeal[this_43] = 0
	set Unit_takeManaHeal[this_43] = 0
	set Unit_causeManaHeal[this_43] = 0
	set Unit_ct[this_43] = 0
	set Unit_onCapture[this_43] = 0
	set InstanceBoard_count[ShowInstances_classId_3] = InstanceBoard_count[ShowInstances_classId_3] + 1
	set mbi = multiboard_getItem(InstanceBoard_mb, ShowInstances_classId_3, 1)
	call multiboarditem_release(multiboarditem_setValue(mbi, int_toString(InstanceBoard_count[ShowInstances_classId_3])))
	set Unit_u[this_43] = u
	set Unit_mass[this_43] = mass
	set Unit_attack[this_43] = attack
	set Unit_radius[this_43] = radius
	set Unit_height[this_43] = height
	set Unit_bounty[this_43] = bounty
	set Unit_ownerId[this_43] = GetPlayerId(unit_getOwner(u))
	set Unit_life[this_43] = unit_getState(u, UNIT_STATE_MAX_LIFE)
	set Unit_mana[this_43] = unit_getState(u, UNIT_STATE_MAX_MANA)
	set Unit_movespeed[this_43] = unit_getMoveSpeed(u)
	call trigger_registerUnitEvent(Unit_damageDetect, u, EVENT_UNIT_DAMAGED)
	call SetUnitUserData(u, this_43)
	set UnitClass_last = this_43
	set Unit_shieldList[this_43] = new_ShieldList()
	set Unit_owner[this_43] = unit_getOwner(u)
	set i_2 = 0
	loop
		exitwhen i_2 > 11
		call dispatch_Table_saveReal(Unit_percentDamage[this_43], i_2, 0.)
		set i_2 = i_2 + 1
	endloop
	set mbi = null
endfunction

function alloc_Bar takes nothing returns integer
	local integer this_43
	if Bar_firstFree == 0 then
		set Bar_maxIndex = Bar_maxIndex + 1
		set this_43 = Bar_maxIndex
	else
		set this_43 = Bar_firstFree
		set Bar_firstFree = Bar_nextFree[Bar_firstFree]
		set Bar_nextFree[this_43] = 0
	endif
	set Bar_typeId[this_43] = 618
	return this_43
endfunction

function construct_Bar takes integer this_43, integer h_2 returns nothing
	set Bar_isVisible[this_43] = true
	set Bar_check[this_43] = true
	set LinkedListModule_size_2 = LinkedListModule_size_2 + 1
	if LinkedListModule_size_2 == 1 then
		set LinkedListModule_first_2 = this_43
		set LinkedListModule_prev_2[this_43] = 0
	else
		set LinkedListModule_prev_2[this_43] = LinkedListModule_last_2
		set LinkedListModule_next_2[LinkedListModule_last_2] = this_43
		set LinkedListModule_prev_2[LinkedListModule_first_2] = this_43
	endif
	set LinkedListModule_next_2[this_43] = 0
	set LinkedListModule_last_2 = this_43
	set Bar_owner[this_43] = h_2
	set Bar_tt[this_43] = CreateTextTag()
	call texttag_setPos(Bar_tt[this_43], dispatch_Hero_getBarPos(h_2), dispatch_Hero_getBarPos_return_y, dispatch_Hero_getBarPos_return_z)
	call texttag_setColor(Bar_tt[this_43], 0, 200, 0, 255)
	call dispatch_Bar_updateEx(this_43)
endfunction

function new_Bar takes integer h_2 returns integer
	local integer this_43 = alloc_Bar()
	call construct_Bar(this_43, h_2)
	return this_43
endfunction

function alloc_HandleMap takes nothing returns integer
	local integer this_43
	if HandleMap_firstFree == 0 then
		set HandleMap_maxIndex = HandleMap_maxIndex + 1
		set this_43 = HandleMap_maxIndex
	else
		set this_43 = HandleMap_firstFree
		set HandleMap_firstFree = HandleMap_nextFree[HandleMap_firstFree]
		set HandleMap_nextFree[this_43] = 0
	endif
	set HandleMap_typeId[this_43] = 624
	return this_43
endfunction

function construct_HandleMap takes integer this_43 returns nothing
endfunction

function new_HandleMap takes nothing returns integer
	local integer this_43 = alloc_HandleMap()
	call construct_HandleMap(this_43)
	return this_43
endfunction

function alloc_Queue takes nothing returns integer
	local integer this_43
	if Queue_firstFree == 0 then
		set Queue_maxIndex = Queue_maxIndex + 1
		set this_43 = Queue_maxIndex
	else
		set this_43 = Queue_firstFree
		set Queue_firstFree = Queue_nextFree[Queue_firstFree]
		set Queue_nextFree[this_43] = 0
	endif
	set Queue_typeId[this_43] = 620
	return this_43
endfunction

function construct_Queue takes integer this_43 returns nothing
	set Queue_size[this_43] = 0
	set Queue_dummy[this_43] = new_SEntry(0, 0)
	set Queue_front[this_43] = Queue_dummy[this_43]
endfunction

function new_Queue takes nothing returns integer
	local integer this_43 = alloc_Queue()
	call construct_Queue(this_43)
	return this_43
endfunction

function real_asAngleDegrees takes real this_43 returns real
	return this_43 * Maths_DEGTORAD
endfunction

function construct_Hero takes integer this_43, unit hero, real attack, real mass, real radius, real height, integer morphAbi, integer bounty returns nothing
	call construct_Unit(this_43, hero, attack, mass, radius, height, bounty)
	set Hero_armorBuffer[this_43] = 0
	set Hero_attackBuffer[this_43] = 0
	set Hero_onAdd[this_43] = false
	set Hero_wantCapture[this_43] = false
	set Hero_channelCancel[this_43] = 0
	set Hero_animationIndex[this_43] = 0
	set Hero_hasPeriodicAnimation[this_43] = false
	set Hero_animationIntervall[this_43] = 0.
	set Hero_animationSpeed[this_43] = 100.
	set Hero_captureOffsetZ[this_43] = 0.
	set Hero_captureOffsetDistance[this_43] = 0.
	set Hero_captureEffect[this_43] = null
	set Hero_captureEffectAttachmentPoint[this_43] = ""
	set Hero_currentEffect[this_43] = null
	set Hero_captureOffsetAngle[this_43] = real_asAngleDegrees(0.)
	set Hero_enableAbility[this_43] = new_HandleMap()
	set Hero_acceptOrders[this_43] = true
	set Hero_stillNoOrder[this_43] = false
	set Hero_mainOrder[this_43] = 0
	set Hero_lastOrdered[this_43] = 0
	set Hero_castQueue[this_43] = new_Queue()
	set Hero_spellQ[this_43] = 0
	set Hero_spellW[this_43] = 0
	set Hero_spellE[this_43] = 0
	set Hero_spellR[this_43] = 0
	set Hero_spellD[this_43] = 0
	set Hero_spellF[this_43] = 0
	set LinkedListModule_size_4 = LinkedListModule_size_4 + 1
	if LinkedListModule_size_4 == 1 then
		set LinkedListModule_first_4 = this_43
		set LinkedListModule_prev_4[this_43] = 0
	else
		set LinkedListModule_prev_4[this_43] = LinkedListModule_last_4
		set LinkedListModule_next_4[LinkedListModule_last_4] = this_43
		set LinkedListModule_prev_4[LinkedListModule_first_4] = this_43
	endif
	set LinkedListModule_next_4[this_43] = 0
	set LinkedListModule_last_4 = this_43
	set Hero_agi[this_43] = int_toReal(GetHeroAgi(hero, false))
	set Hero_str[this_43] = int_toReal(GetHeroStr(hero, false))
	set Hero_inte[this_43] = int_toReal(GetHeroInt(hero, false))
	set Hero_morphAbi[this_43] = morphAbi
	set Hero_hb[this_43] = new_Bar(this_43)
	set Unit_isHero[this_43] = true
	call unit_addAbility(hero, 1095917932)
	call unit_addAbility(hero, morphAbi)
	call unit_addAbility(hero, Spell_cleanSpellbook)
	call unit_addAbility(hero, 1514234228)
	call unit_addAbility(hero, 1514238836)
	call unit_addAbility(hero, 1514238819)
	call unit_addAbility(hero, 1702390132)
	call trigger_registerUnitEvent(Hero_castDetect, hero, EVENT_UNIT_SPELL_CAST)
	call GetOrders_addOrderDetection(hero)
endfunction

function new_Hero takes unit hero, real attack, real mass, real radius, real height, integer morphAbi, integer bounty returns integer
	local integer this_43 = alloc_Hero()
	call construct_Hero(this_43, hero, attack, mass, radius, height, morphAbi, bounty)
	return this_43
endfunction

function alloc_LinkedList takes nothing returns integer
	local integer this_43
	if LinkedList_firstFree == 0 then
		set LinkedList_maxIndex = LinkedList_maxIndex + 1
		set this_43 = LinkedList_maxIndex
	else
		set this_43 = LinkedList_firstFree
		set LinkedList_firstFree = LinkedList_nextFree[LinkedList_firstFree]
		set LinkedList_nextFree[this_43] = 0
	endif
	set LinkedList_typeId[this_43] = 1
	return this_43
endfunction

function construct_LinkedList takes integer this_43 returns nothing
	set LinkedList_size[this_43] = 0
	set LinkedList_dummy[this_43] = new_LLEntry(0, 0, 0)
	set LLEntry_next[LinkedList_dummy[this_43]] = LinkedList_dummy[this_43]
	set LLEntry_prev[LinkedList_dummy[this_43]] = LinkedList_dummy[this_43]
endfunction

function new_LinkedList takes nothing returns integer
	local integer this_43 = alloc_LinkedList()
	call construct_LinkedList(this_43)
	return this_43
endfunction

function alloc_Player takes nothing returns integer
	local integer this_43
	if Player_firstFree == 0 then
		set Player_maxIndex = Player_maxIndex + 1
		set this_43 = Player_maxIndex
	else
		set this_43 = Player_firstFree
		set Player_firstFree = Player_nextFree[Player_firstFree]
		set Player_nextFree[this_43] = 0
	endif
	set Player_typeId[this_43] = 701
	return this_43
endfunction

function construct_Player takes integer this_43, player p returns nothing
	set Player_h[this_43] = 0
	set Player_team[this_43] = Setup_team1
	set Player_kills[this_43] = 0
	set Player_assists[this_43] = 0
	set Player_death[this_43] = 0
	set Player_selectionOn[this_43] = false
	set Player_camSet[this_43] = getTimer()
	set Player_sightfield[this_43] = 60.
	set Player_perspektiv[this_43] = 295.
	set PlayerClass_lastp = this_43
	set Player_p[this_43] = p
	call dispatch_HandleMap_put(PlayerClass_playerData, p, this_43)
endfunction

function new_Player takes player p returns integer
	local integer this_43 = alloc_Player()
	call construct_Player(this_43, p)
	return this_43
endfunction

function alloc_SimpleEvent takes nothing returns integer
	local integer this_43
	if Event_firstFree == 0 then
		set Event_maxIndex = Event_maxIndex + 1
		set this_43 = Event_maxIndex
	else
		set this_43 = Event_firstFree
		set Event_firstFree = Event_nextFree[Event_firstFree]
		set Event_nextFree[this_43] = 0
	endif
	set Event_typeId[this_43] = 699
	return this_43
endfunction

function construct_SimpleEvent takes integer this_43 returns nothing
	call construct_Event(this_43)
endfunction

function new_SimpleEvent takes nothing returns integer
	local integer this_43 = alloc_SimpleEvent()
	call construct_SimpleEvent(this_43)
	return this_43
endfunction

function alloc_TestSpell1Setup takes nothing returns integer
	local integer this_43
	if Spell_firstFree == 0 then
		set Spell_maxIndex = Spell_maxIndex + 1
		set this_43 = Spell_maxIndex
	else
		set this_43 = Spell_firstFree
		set Spell_firstFree = Spell_nextFree[Spell_firstFree]
		set Spell_nextFree[this_43] = 0
	endif
	set Spell_typeId[this_43] = 715
	return this_43
endfunction

function construct_Spell takes integer this_43, integer owner, integer st returns nothing
	local integer temp
	set Spell_lvl[this_43] = 1
	set Spell_owner[this_43] = owner
	set Spell_st[this_43] = st
	set temp = st
	if temp == 0 then
		set Hero_spellQ[owner] = this_43
	elseif temp == 1 then
		set Hero_spellW[owner] = this_43
	elseif temp == 2 then
		set Hero_spellE[owner] = this_43
	elseif temp == 3 then
		set Hero_spellR[owner] = this_43
	elseif temp == 4 then
		set Hero_spellD[owner] = this_43
	elseif temp == 5 then
		set Hero_spellF[owner] = this_43
	endif
endfunction

function SpellSetup_setSpellType takes integer this_43, integer sp returns nothing
	set SpellSetup_sp[this_43] = sp
	call dispatch_ObjId_setId1(SpellSetup_castDummy[this_43], SpellType_toId(sp))
endfunction

function dispatch_SpellSetup_setSpellType takes integer this_43, integer sp returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setSpellType")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setSpellType on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setSpellType(this_43, sp)
endfunction

function TargetType_toId takes integer this_43 returns integer
	local integer temp = this_43
	if temp == 0 then
		return 48
	elseif temp == 1 then
		return 49
	elseif temp == 2 then
		return 50
	elseif temp == 3 then
		return 51
	else
		return -1
	endif
endfunction

function ObjId_setId4_2 takes integer this_43, integer char4 returns nothing
	set ObjId_id4[this_43] = char4
endfunction

function dispatch_ObjId_setId4_2 takes integer this_43, integer char4 returns nothing
	if ObjId_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling ObjId.setId4")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called ObjId.setId4 on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call ObjId_setId4_2(this_43, char4)
endfunction

function SpellSetup_setTargetType takes integer this_43, integer tt returns nothing
	call dispatch_ObjId_setId4_2(SpellSetup_castDummy[this_43], TargetType_toId(tt))
endfunction

function dispatch_SpellSetup_setTargetType takes integer this_43, integer tt returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setTargetType")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setTargetType on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setTargetType(this_43, tt)
endfunction

function HashMap_put takes integer this_43, integer key, integer value returns nothing
	call hashtable_saveInt(HashMap_ht, this_43, key, value)
endfunction

function dispatch_HashMap_put takes integer this_43, integer key, integer value returns nothing
	if HashMap_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling HashMap.put")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called HashMap.put on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call HashMap_put(this_43, key, value)
endfunction

function Spell_readSetup takes integer this_43, integer ss returns nothing
	set Spell_spell[this_43] = SpellSetup_spell[ss]
	set Spell_spellbook[this_43] = SpellSetup_spellbook[ss]
	set Spell_castDummy[this_43] = dispatch_ObjId_getId(SpellSetup_castDummy[ss])
	set Spell_maxLvl[this_43] = SpellSetup_maxLvl[ss]
	call dispatch_HashMap_put(Hero_abiIdToSpell, Spell_spell[this_43], this_43)
	call unit_addAbility(Unit_u[Spell_owner[this_43]], Spell_spellbook[this_43])
	call unit_addAbility(Unit_u[Spell_owner[this_43]], Spell_spell[this_43])
	call SetPlayerAbilityAvailable(Unit_owner[Spell_owner[this_43]], Spell_spellbook[this_43], false)
endfunction

function dispatch_Spell_readSetup takes integer this_43, integer ss returns nothing
	if Spell_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling Spell.readSetup")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called Spell.readSetup on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	if Spell_typeId[this_43] <= 713 then
		if Spell_typeId[this_43] <= 642 then
			call Spell_readSetup(this_43, ss)
		else
			call Spell_readSetup(this_43, ss)
		endif
	else
		call Spell_readSetup(this_43, ss)
	endif
endfunction

function construct_PointSpell takes integer this_43, integer owner, integer ss, integer st returns nothing
	call construct_Spell(this_43, owner, st)
	call dispatch_SpellSetup_setTargetType(ss, 2)
	call dispatch_SpellSetup_setSpellType(ss, st)
	call dispatch_Spell_readSetup(this_43, ss)
endfunction

function construct_TestSpell1Setup takes integer this_43, integer owner, integer st returns nothing
	call construct_PointSpell(this_43, owner, TestSpell1Setup_setup, st)
endfunction

function new_TestSpell1Setup takes integer owner, integer st returns integer
	local integer this_43 = alloc_TestSpell1Setup()
	call construct_TestSpell1Setup(this_43, owner, st)
	return this_43
endfunction

function playerFromIndex_2 takes integer i_2 returns player
	call hashtable_saveFogStateHandle(PrimitiveIndexes_ht, 0, 0, ConvertFogState(i_2))
	return hashtable_loadPlayerHandle(PrimitiveIndexes_ht, 0, 0)
endfunction

function trigger_registerPlayerChatEvent takes trigger this_43, player whichPlayer, string chatMessageToDetect, boolean exactMatchOnly returns trigger
	call TriggerRegisterPlayerChatEvent(this_43, whichPlayer, chatMessageToDetect, exactMatchOnly)
	return this_43
endfunction

function init_GameStart takes nothing returns nothing
	local integer i_2
	local trigger blub
	local integer wurst__iterator0
	local player p
	local trigger charTestTrig
	local integer i_3
	local integer h_2
	local integer clVar
	local integer temp
	set GameStart_testt = trigger_addAction(CreateTrigger(), ref_function_setCallLimit)
	set GameStart_lastBon = 0
	set GameStart_hp = 0.
	set GameStart_testc = 0
	set GameStart_testi = 0
	set GameStart_ttSize = 0.0300
	set GameStart_testr = 0.
	set GameStart_tests = null
	set GameStart_testSpell = 0
	set GameStart_testChar = ""
	set GameStart_testTag = createTTEx(0., 0., 0., "||||||||||||||||||||", 10., 255, 255, 255, 255)
	set GameStart_testg = CreateGroup()
	set GameStart_progress = 0
	set GameStart_recursionCounter = 0
	set GameStart_testd = CreateDestructable(1231253358, Setup_menuStart_x + 20., Setup_menuStart_y + 10., 0., 1., 1)
	set GameStart_callLimit = 1
	set GameStart_tList = new_TList()
	set GameStart_lList = new_LinkedList()
	set i_2 = 0
	loop
		exitwhen i_2 > 11
		if GetPlayerSlotState(Player(i_2)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i_2)) == MAP_CONTROL_USER then
			call dispatch_LinkedList_add(Setup_allPlayers, playerToIndex(Player(i_2)))
			call SetPlayerAbilityAvailable(Player(i_2), 1514238056, false)
			call SetPlayerAbilityAvailable(Player(i_2), 1514234228, false)
			call SetPlayerAbilityAvailable(Player(i_2), 1514238836, false)
			call SetPlayerAbilityAvailable(Player(i_2), 1514238819, false)
		endif
		set i_2 = i_2 + 1
	endloop
	call timer_startPeriodic(getTimer(), 0.5, ref_function_Dot_loopList)
	call timer_startPeriodic(getTimer(), 0.03, ref_function_callKnockback)
	set blub = CreateTrigger()
	call trigger_addAction(blub, ref_function_camTest)
	call trigger_registerPlayerChatEvent(blub, Player(0), "", false)
	call new_ControlPoint(2000., 0., Player(1))
	call new_ControlPoint(-2000., 0., Player(0))
	call EnablePreSelect(false, false)
	call timer_startPeriodic(getTimer(), 0.1, ref_function_forceKey)
	set wurst__iterator0 = dispatch_LinkedList_iterator(Setup_allPlayers)
	loop
		exitwhen  not dispatch_LLIterator_hasNext(wurst__iterator0)
		set p = playerFromIndex_2(dispatch_LLIterator_next(wurst__iterator0))
		call new_Player(p)
	endloop
	call dispatch_LLIterator_close(wurst__iterator0)
	set charTestTrig = trigger_addAction(CreateTrigger(), ref_function_charMessung)
	call trigger_registerAnyUnitEvent(charTestTrig, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
	set i_3 = 1
	loop
		exitwhen i_3 > 1
		set h_2 = new_Hero(CreateUnit(Player(0), 1211117617, 0., 0., 0.), 20., 100., 50., 150., 1095911493, 100)
		set Hero_animationIndex[h_2] = 7
		set Hero_captureOffsetDistance[h_2] = 35.
		set Hero_captureOffsetZ[h_2] = 20.
		set Hero_captureEffectAttachmentPoint[h_2] = "weapton"
		set Hero_captureEffect[h_2] = "Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl"
		set GameStart_testSpell = new_TestSpell1Setup(h_2, 0)
		set i_3 = i_3 + 1
	endloop
	call trigger_registerPlayerChatEvent(GameStart_testt, Player(0), "", false)
	call TriggerRegisterPlayerEventEndCinematic(trigger_addAction(CreateTrigger(), ref_function_onEsc), Player(0))
	call Preload_startPreload()
	call timer_startPeriodic(getTimer(), 0.1, ref_function_textTag)
	set Preload_maxProgress = 20.33
	set Preload_progress = 0.
	set Preload_preloadStatus = 0
	set Preload_preloadEnd = new_SimpleEvent()
	set Preload_showProgress = false
	set Preload_trackCounter = 0
	set Preload_trackTrig = CreateTrigger()
	set Preload_trackPos_i1 = 1
	set Preload_trackPos_i2 = 1
	set Preload_preloadDummy = CreateUnit(Basics_DUMMY_PLAYER, 1211117617, 0., 0., 0.)
	set Preload_abiCounter = 0
	set Preload_itemCounter = 0
	set temp = Preload_preloadEnd
	set clVar = alloc_Closure_10()
	call dispatch_Event_addAction(temp, clVar)
	set blub = null
	set p = null
	set charTestTrig = null
endfunction

function init_GameTimer takes nothing returns nothing
	set GameTimer_gameTimer = CreateTimer()
	call timer_start(GameTimer_gameTimer, 100000., null)
endfunction

function init_HandleCounter takes nothing returns nothing
	set HandleCounter_TITLE = "HandleCounter"
	set HandleCounter_board = null
	set HandleCounter_boardTimer = getTimer()
	set HandleCounter_HANDLE = Player(0)
	set HandleCounter_HANDLE_TEXT = "current handlecount"
	set HandleCounter_MAX_HANDLE = Player(1)
	set HandleCounter_MAX_HANDLE_TEXT = "max handlecount"
	set HandleCounter_TIME_TEXT = "current time"
	set HandleCounter_TIME = Player(2)
	set HandleCounter_updatePeriod = 0.25
	set HandleCounter_stackEndTreshold = 15
	set HandleCounter_clock = getTimer()
	set HandleCounter_seconds = 0
	set HandleCounter_maxHandleCount = 0
	call TimerStart(HandleCounter_clock, 1., true, ref_function_updateTime)
endfunction

function init_HandleMap takes nothing returns nothing
	set HandleMap_ht = InitHashtable()
endfunction

function init_HashMap takes nothing returns nothing
	set HashMap_ht = InitHashtable()
endfunction

function init_Helper takes nothing returns nothing
	local integer i_2 = 0
	loop
		exitwhen i_2 > 31
		set Helper_pow2[i_2] = R2I(Pow(2., I2R(i_2)))
		set i_2 = i_2 + 1
	endloop
endfunction

function init_HeroBar takes nothing returns nothing
	set HeroBar_hpColor = "|c00009900"
	set HeroBar_hpColorDead = "|c00003300"
	set HeroBar_shieldColor = "|c00999999"
	set HeroBar_mpColor = "|c000000AA"
	set HeroBar_mpColorDead = "|c00000022"
	set HeroBar_endColor = "|r"
	set HeroBar_marker = "|c00000000|||r"
	set HeroBar_bar = "|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"
	set HeroBar_realBarCount = 125
	set HeroBar_fakeBarCount = 250
	set HeroBar_seperateAt = 250
	set Bar_updatePos = timer_startPeriodic(getTimer(), 0.01, ref_function_Bar_updatePos)
	set Bar_updateVision = timer_startPeriodic(getTimer(), 0.25, ref_function_Bar_updateVision)
	set LinkedListModule_first_2 = 0
	set LinkedListModule_last_2 = 0
	set LinkedListModule_size_2 = 0
endfunction

function init_HeroClass takes nothing returns nothing
	set HeroClass_heroCount = 0
	set Hero_castDetect = trigger_addAction(CreateTrigger(), ref_function_Hero_handleCasts)
	set Hero_abiIdToSpell = new_HashMap()
	set Hero_checkOrders = timer_startPeriodic(getTimer(), 0.01, ref_function_Hero_checkOrders)
	set GetOrders_orderDetect = trigger_addAction(CreateTrigger(), ref_function_GetOrders_callOnOrder)
	set LinkedListModule_first_4 = 0
	set LinkedListModule_last_4 = 0
	set LinkedListModule_size_4 = 0
endfunction

function init_Icon takes nothing returns nothing
	set Icon_animationSpeedHover = 3.5
endfunction

function init_ImageEx takes nothing returns nothing
	set Image_resizeRateConstant = 0.015
	set Image_fadeTicks = 8
	set Image_resizeTicks = 8
	set Image_timerOwner = new_HandleMap()
	set Image_tick = new_HandleMap()
endfunction

function init_InstanceBoard takes nothing returns nothing
	set InstanceBoard_classes = 0
	set InstanceBoard_ht = InitHashtable()
	set InstanceBoard_mb = null
	call timer_start(getTimer(), 0.0, ref_function_createMultiboard)
endfunction

function init_Lightning takes nothing returns nothing
	set Lightning_CHAIN_LIGHTNING_PRIMARY = "CLPB"
	set Lightning_CHAIN_LIGHTNING_SECONDARY = "CLSB"
	set Lightning_DRAIN = "DRAB"
	set Lightning_DRAIN_LIFE = "DRAL"
	set Lightning_DRAIN_MANA = "DRAM"
	set Lightning_FINGER_OF_DEATH = "AFOD"
	set Lightning_FORKED_LIGHTNING = "FORK"
	set Lightning_HEALING_WAVE_PRIMARY = "HWPB"
	set Lightning_HEALING_WAVE_SECONDARY = "HWSB"
	set Lightning_LIGHTNING_ATTACK = "CHIM"
	set Lightning_MAGIC_LEASH = "LEAS"
	set Lightning_MANA_BURN = "MBUR"
	set Lightning_MANA_FLARE = "MFPB"
	set Lightning_SPIRIT_LINK = "SPLK"
endfunction

function init_MapBounds takes nothing returns nothing
	set MapBounds_mapRect = GetPlayableMapRect()
	set MapBounds_mapMinX = GetRectMinX(MapBounds_mapRect)
	set MapBounds_mapMinY = GetRectMinY(MapBounds_mapRect)
	set MapBounds_mapMaxX = GetRectMaxX(MapBounds_mapRect)
	set MapBounds_mapMaxY = GetRectMaxY(MapBounds_mapRect)
	set MapBounds_mapCenter_x = (MapBounds_mapMaxX + MapBounds_mapMinX) / 2.
	set MapBounds_mapCenter_y = (MapBounds_mapMinY + MapBounds_mapMaxY) / 2.
endfunction

function init_Maths takes nothing returns nothing
	set Maths_PI = 3.141592654
	set Maths_PI2 = 6.28318
	set Maths_PIHALF = 1.570796326
	set Maths_DEGTORAD = 0.017453293
	set Maths_RADTODEG = 57.295779513
endfunction

function init_Menu takes nothing returns nothing
	set Menu_clickingPlayer = 0
	set Menu_clickedButton = 0
	set Menu_buttons = new_TList()
	set Menu_index = new_MenuIndexer()
endfunction

function Order_classname takes nothing returns string
	return "Order"
endfunction

function init_OrderHandling takes nothing returns nothing
	set OrderHandling_smartId = 851971
	set OrderHandling_stopId = 852529
	set OrderHandling_attackId = 852662
	set OrderHandling_scoreboardId = 852185
	set OrderHandling_exitDetectId = 852131
	set OrderHandling_skillMenuId = 852131
	set OrderHandling_stopSpell = 1937010544
	set OrderHandling_attackSpell = 1635021931
	set OrderHandling_scoreboardSpell = 1935896434
	set OrderHandling_exitDetectSpell = 1702390132
	set OrderHandling_qSpellNoTarget = 1364414512
	set OrderHandling_qSpellUnitTarget = 1364414513
	set OrderHandling_qSpellPointTarget = 1364414514
	set OrderHandling_qSpellUnitPointTarget = 1364414515
	set OrderHandling_wSpellNoTarget = 1465077812
	set OrderHandling_wSpellUnitTarget = 1465077809
	set OrderHandling_wSpellPointTarget = 1465077810
	set OrderHandling_wSpellUnitPointTarget = 1465077811
	set OrderHandling_eSpellNoTarget = 1163087920
	set OrderHandling_eSpellUnitTarget = 1163087921
	set OrderHandling_eSpellPointTarget = 1163087922
	set OrderHandling_eSpellUnitPointTarget = 1163087923
	set OrderHandling_rSpellNoTarget = 1381191728
	set OrderHandling_rSpellUnitTarget = 1381191729
	set OrderHandling_rSpellPointTarget = 1381191730
	set OrderHandling_rSpellUnitPointTarget = 1381191731
	set OrderHandling_dSpellNoTarget = 1146310704
	set OrderHandling_dSpellUnitTarget = 1146310705
	set OrderHandling_dSpellPointTarget = 1146310706
	set OrderHandling_dSpellUnitPointTarget = 1146310707
	set OrderHandling_fSpellNoTarget = 1179865136
	set OrderHandling_fpellUnitTarget = 1179865137
	set OrderHandling_fSpellPointTarget = 1179865138
	set OrderHandling_fSpellUnitPointTarget = 1179865139
	set ShowInstances_classId_2 = registerNewInstanceEntry(Order_classname())
	set MoveOrder_moveOrderId = 851986
	set AttackOrder_atkOrderId = 852541
endfunction

function init_PlayerClass takes nothing returns nothing
	set PlayerClass_lastp = 0
	set PlayerClass_camDistance = 3000.
	set PlayerClass_camAngle = 90.
	set PlayerClass_camWidth = 1000.
	set PlayerClass_camHeightLow = 2000.
	set PlayerClass_camHeightHigh = -200.
	set PlayerClass_playerData = new_HandleMap()
endfunction

function init_PreloadHandler takes nothing returns nothing
	set PreloadHandler_dum = CreateUnit(Player(15), Basics_DUMMY_UNIT_ID, 0., 0., 0.)
	if PreloadHandler_dum == null then
		call printError("xePreload : DUMMY_UNITID (" + debugIdInteger2IdString(Basics_DUMMY_UNIT_ID) + ") not added correctly to the map.")
	endif
	call TimerStart(CreateTimer(), 0.0, false, ref_function_kill)
endfunction

function init_PrimitiveIndexes takes nothing returns nothing
	set PrimitiveIndexes_ht = InitHashtable()
endfunction

function init_PrintingHelper takes nothing returns nothing
	set PrintingHelper_DEBUG_LEVEL = 3
	set PrintingHelper_DEBUG_MSG_DURATION = 45.
	set PrintingHelper_msgcount = 0
endfunction

function trigger_addCondition takes trigger this_43, boolexpr condition returns trigger
	call TriggerAddCondition(this_43, condition)
	return this_43
endfunction

function init_Pull2 takes nothing returns nothing
	local trigger t = CreateTrigger()
	call trigger_addCondition(t, Condition(ref_function_spellCondition))
	call trigger_addAction(t, ref_function_spellStart)
	call trigger_registerAnyUnitEvent(t, EVENT_PLAYER_UNIT_SPELL_CAST)
	set t = null
endfunction

function init_RTable takes nothing returns nothing
	set RTable_tableSize = 8192
endfunction

function init_Rect takes nothing returns nothing
	set Rect_sourceTable = new_Table()
	set Rect_regionData = new_Table()
endfunction

function init_RockThrow takes nothing returns nothing
endfunction

function init_RunningMazeChecker takes nothing returns nothing
	set RunningMazeChecker_tileWidth = 64.
endfunction

function SpellSetup_setDummySpellBook takes integer this_43, integer abiCode returns nothing
	set SpellSetup_spellbook[this_43] = abiCode
endfunction

function dispatch_SpellSetup_setDummySpellBook takes integer this_43, integer abiCode returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setDummySpellBook")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setDummySpellBook on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setDummySpellBook(this_43, abiCode)
endfunction

function SpellSetup_setMaxLvl takes integer this_43, integer lvl returns nothing
	set SpellSetup_maxLvl[this_43] = lvl
endfunction

function dispatch_SpellSetup_setMaxLvl takes integer this_43, integer lvl returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setMaxLvl")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setMaxLvl on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setMaxLvl(this_43, lvl)
endfunction

function SpellSetup_setNeededSkillpoints takes integer this_43, integer lvl, integer points returns nothing
	call dispatch_Table_saveInt(SpellSetup_pointCost[this_43], lvl, points)
endfunction

function dispatch_SpellSetup_setNeededSkillpoints takes integer this_43, integer lvl, integer points returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setNeededSkillpoints")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setNeededSkillpoints on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setNeededSkillpoints(this_43, lvl, points)
endfunction

function SpellSetup_setSpell takes integer this_43, integer abiCode returns nothing
	set SpellSetup_spell[this_43] = abiCode
endfunction

function dispatch_SpellSetup_setSpell takes integer this_43, integer abiCode returns nothing
	if SpellSetup_typeId[this_43] == 0 then
		if this_43 == 0 then
			call BJDebugMsg("Nullpointer exception when calling SpellSetup.setSpell")
			call I2S(1 / 0)
		else
			call BJDebugMsg("Called SpellSetup.setSpell on invalid object.")
			call I2S(1 / 0)
		endif
	endif
	call SpellSetup_setSpell(this_43, abiCode)
endfunction

function TestSpell1Setup_setSpellData takes integer ss returns integer
	call dispatch_SpellSetup_setSpell(ss, 1952805681)
	call dispatch_SpellSetup_setDummySpellBook(ss, 1514239025)
	call dispatch_SpellSetup_setMaxLvl(ss, 5)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 1, 1)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 2, 1)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 3, 2)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 4, 2)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 5, 3)
	return ss
endfunction

function alloc_SpellSetup takes nothing returns integer
	local integer this_43
	if SpellSetup_firstFree == 0 then
		set SpellSetup_maxIndex = SpellSetup_maxIndex + 1
		set this_43 = SpellSetup_maxIndex
	else
		set this_43 = SpellSetup_firstFree
		set SpellSetup_firstFree = SpellSetup_nextFree[SpellSetup_firstFree]
		set SpellSetup_nextFree[this_43] = 0
	endif
	set SpellSetup_typeId[this_43] = 636
	return this_43
endfunction

function construct_SpellSetup takes integer this_43 returns nothing
	set SpellSetup_castDummy[this_43] = new_ObjId()
	set SpellSetup_pointCost[this_43] = new_Table()
	call dispatch_ObjId_setId2(SpellSetup_castDummy[this_43], 83)
	call dispatch_ObjId_setId3(SpellSetup_castDummy[this_43], 80)
endfunction

function new_SpellSetup takes nothing returns integer
	local integer this_43 = alloc_SpellSetup()
	call construct_SpellSetup(this_43)
	return this_43
endfunction

function init_SampleSpells takes nothing returns nothing
	set TestSpell1Setup_setup = TestSpell1Setup_setSpellData(new_SpellSetup())
	set TestSpell1_animationType = 7
endfunction

function cBonData takes integer raw, integer size returns integer
	set cBonData_return_raw = raw
	set cBonData_return_size = size
	return cBonData_return_raw
endfunction

function alloc_DebugFile takes nothing returns integer
	local integer this_43
	if DebugFile_firstFree == 0 then
		set DebugFile_maxIndex = DebugFile_maxIndex + 1
		set this_43 = DebugFile_maxIndex
	else
		set this_43 = DebugFile_firstFree
		set DebugFile_firstFree = DebugFile_nextFree[DebugFile_firstFree]
		set DebugFile_nextFree[this_43] = 0
	endif
	set DebugFile_typeId[this_43] = 607
	return this_43
endfunction

function construct_DebugFile takes integer this_43, string filename returns nothing
	set DebugFile_buffer[this_43] = ""
	set DebugFile_content[this_43] = new_Table()
	set DebugFile_currentLine[this_43] = 0
	set DebugFile_filename[this_43] = filename
endfunction

function new_DebugFile takes string filename returns integer
	local integer this_43 = alloc_DebugFile()
	call construct_DebugFile(this_43, filename)
	return this_43
endfunction

function alloc_Table3D takes nothing returns integer
	local integer this_43
	if Table3D_firstFree == 0 then
		set Table3D_maxIndex = Table3D_maxIndex + 1
		set this_43 = Table3D_maxIndex
	else
		set this_43 = Table3D_firstFree
		set Table3D_firstFree = Table3D_nextFree[Table3D_firstFree]
		set Table3D_nextFree[this_43] = 0
	endif
	set Table3D_typeId[this_43] = 605
	return this_43
endfunction

function construct_Table3D takes integer this_43, integer key3IndexSize returns nothing
	set Table3D_ht[this_43] = InitHashtable()
	set Table3D_key3IndexSize[this_43] = 0
	set Table3D_key3IndexSize[this_43] = key3IndexSize
endfunction

function new_Table3D takes integer key3IndexSize returns integer
	local integer this_43 = alloc_Table3D()
	call construct_Table3D(this_43, key3IndexSize)
	return this_43
endfunction

function init_Setup takes nothing returns nothing
	local integer i1
	local integer temp
	local integer i2
	local integer temp_2
	set Setup_timeTest = null
	set Setup_maxBonSize = 13
	set Setup_attackRaw_raw = cBonData(676800816, 0)
	set Setup_attackRaw_size = cBonData_return_size
	set Setup_attackSpeedRaw_raw = cBonData(675883312, 0)
	set Setup_attackSpeedRaw_size = cBonData_return_size
	set Setup_armorRaw_raw = cBonData(675883312, 0)
	set Setup_armorRaw_size = cBonData_return_size
	set Setup_lifeRaw_raw = cBonData(675883312, 0)
	set Setup_lifeRaw_size = cBonData_return_size
	set Setup_manaRaw_raw = cBonData(675883312, 0)
	set Setup_manaRaw_size = cBonData_return_size
	set Setup_agiRaw_raw = cBonData(675883312, 0)
	set Setup_agiRaw_size = cBonData_return_size
	set Setup_strRaw_raw = cBonData(675883312, 0)
	set Setup_strRaw_size = cBonData_return_size
	set Setup_intRaw_raw = cBonData(675883312, 0)
	set Setup_intRaw_size = cBonData_return_size
	set Setup_lifeRegRaw_raw = cBonData(675883312, 0)
	set Setup_lifeRegRaw_size = cBonData_return_size
	set Setup_manaRegRaw_raw = cBonData(675883312, 0)
	set Setup_manaRegRaw_size = cBonData_return_size
	set Setup_preloadAbi = new_TList()
	set Setup_permAttackTomeId = new_TList()
	set Setup_infoFile = new_DebugFile("Info")
	set Setup_errorFile = new_DebugFile("Error")
	set Setup_debugFile = new_DebugFile("Debug")
	set Setup_charMap = ".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
	set Setup_allPlayers = new_LinkedList()
	set Setup_team1 = "Wargrin"
	set Setup_team2 = "Everliving"
	set Setup_recycleGraveyard_x = 0.
	set Setup_recycleGraveyard_y = 0.
	set Setup_menuStart_x = 1000.
	set Setup_menuStart_y = 0.
	set Setup_trackBlacklist = InitHashtable()
	set Setup_trackableTrackTrigger = CreateTrigger()
	set Setup_trackableHitTrigger = CreateTrigger()
	set Setup_trackableDoubleHitTrigger = CreateTrigger()
	set Setup_trackableMap = new_Table3D(20)
	set Setup_menuHeight = 22
	set Setup_menuWidth = 44
	set Setup_abilityLoadTime = 0.1
	set Setup_abilityLoadTimeLevelBonus = 0.03
	call hashtable_saveBoolean(Setup_trackBlacklist, 1, 1, true)
	set i1 = 675359073
	set temp = 256 * 256
	loop
		exitwhen i1 > 675752289
		set i2 = i1
		set temp_2 = i1 + 10
		loop
			exitwhen i2 > temp_2
			set i2 = i2 + 1
		endloop
		set i1 = i1 + temp
	endloop
	set Setup_attackPerm[0] = 676997473
	set Setup_attackPerm[1] = 676997474
	set Setup_attackPerm[2] = 676997475
	set Setup_attackPerm[3] = 676997476
	set Setup_attackPerm[4] = 676997477
	set Setup_attackPerm[5] = 676997478
	set Setup_attackPerm[6] = 676997479
	set Setup_attackPerm[7] = 676997480
	set Setup_attackPerm[8] = 676997481
	call dispatch_TList_add(Setup_permAttackTomeId, 676997482)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997483)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997484)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997485)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997486)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997487)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997488)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997489)
	call dispatch_TList_add(Setup_permAttackTomeId, 676997490)
	set Setup_permAttackNegTomeId = 676997491
	call dispatch_TList_add(Setup_preloadAbi, 675359073)
	call dispatch_TList_add(Setup_preloadAbi, 675359074)
	call dispatch_TList_add(Setup_preloadAbi, 675359075)
	call dispatch_TList_add(Setup_preloadAbi, 675359076)
	call dispatch_TList_add(Setup_preloadAbi, 675359077)
	call dispatch_TList_add(Setup_preloadAbi, 675359078)
	call dispatch_TList_add(Setup_preloadAbi, 675359079)
	call dispatch_TList_add(Setup_preloadAbi, 675359080)
	call dispatch_TList_add(Setup_preloadAbi, 675359081)
	call dispatch_TList_add(Setup_preloadAbi, 675359082)
	call dispatch_TList_add(Setup_preloadAbi, 675359021)
	call dispatch_TList_add(Setup_preloadAbi, 675424609)
	call dispatch_TList_add(Setup_preloadAbi, 675424610)
	call dispatch_TList_add(Setup_preloadAbi, 675424611)
	call dispatch_TList_add(Setup_preloadAbi, 675424612)
	call dispatch_TList_add(Setup_preloadAbi, 675424613)
	call dispatch_TList_add(Setup_preloadAbi, 675424614)
	call dispatch_TList_add(Setup_preloadAbi, 675424615)
	call dispatch_TList_add(Setup_preloadAbi, 675424616)
	call dispatch_TList_add(Setup_preloadAbi, 675424617)
	call dispatch_TList_add(Setup_preloadAbi, 675424618)
	call dispatch_TList_add(Setup_preloadAbi, 675424557)
	call dispatch_TList_add(Setup_preloadAbi, 676997473)
	call dispatch_TList_add(Setup_preloadAbi, 676997474)
	call dispatch_TList_add(Setup_preloadAbi, 676997475)
	call dispatch_TList_add(Setup_preloadAbi, 676997476)
	call dispatch_TList_add(Setup_preloadAbi, 676997477)
	call dispatch_TList_add(Setup_preloadAbi, 676997478)
	call dispatch_TList_add(Setup_preloadAbi, 676997479)
	call dispatch_TList_add(Setup_preloadAbi, 676997480)
	call dispatch_TList_add(Setup_preloadAbi, 676997481)
	call dispatch_TList_add(Setup_preloadAbi, 676997492)
	call dispatch_TList_add(Setup_preloadAbi, 675883361)
	call dispatch_TList_add(Setup_preloadAbi, 675883362)
	call dispatch_TList_add(Setup_preloadAbi, 675883363)
	call dispatch_TList_add(Setup_preloadAbi, 675883364)
	call dispatch_TList_add(Setup_preloadAbi, 675883365)
	call dispatch_TList_add(Setup_preloadAbi, 675883366)
	call dispatch_TList_add(Setup_preloadAbi, 675883367)
	call dispatch_TList_add(Setup_preloadAbi, 675883368)
	call dispatch_TList_add(Setup_preloadAbi, 675883369)
	call dispatch_TList_add(Setup_preloadAbi, 675883309)
	call dispatch_TList_add(Setup_preloadAbi, 676931937)
	call dispatch_TList_add(Setup_preloadAbi, 676931938)
	call dispatch_TList_add(Setup_preloadAbi, 676931939)
	call dispatch_TList_add(Setup_preloadAbi, 676931940)
	call dispatch_TList_add(Setup_preloadAbi, 676931941)
	call dispatch_TList_add(Setup_preloadAbi, 676931942)
	call dispatch_TList_add(Setup_preloadAbi, 676931943)
	call dispatch_TList_add(Setup_preloadAbi, 676931944)
	call dispatch_TList_add(Setup_preloadAbi, 676931945)
	call dispatch_TList_add(Setup_preloadAbi, 676931946)
	call dispatch_TList_add(Setup_preloadAbi, 676931947)
	call dispatch_TList_add(Setup_preloadAbi, 676931948)
	call dispatch_TList_add(Setup_preloadAbi, 676931885)
	call dispatch_TList_add(Setup_preloadAbi, 676866401)
	call dispatch_TList_add(Setup_preloadAbi, 676866402)
	call dispatch_TList_add(Setup_preloadAbi, 676866403)
	call dispatch_TList_add(Setup_preloadAbi, 676866404)
	call dispatch_TList_add(Setup_preloadAbi, 676866405)
	call dispatch_TList_add(Setup_preloadAbi, 676866406)
	call dispatch_TList_add(Setup_preloadAbi, 676866407)
	call dispatch_TList_add(Setup_preloadAbi, 676866408)
	call dispatch_TList_add(Setup_preloadAbi, 676866409)
	call dispatch_TList_add(Setup_preloadAbi, 676866410)
	call dispatch_TList_add(Setup_preloadAbi, 676866411)
	call dispatch_TList_add(Setup_preloadAbi, 676866412)
	call dispatch_TList_add(Setup_preloadAbi, 676866349)
	call dispatch_TList_add(Setup_preloadAbi, 675686753)
	call dispatch_TList_add(Setup_preloadAbi, 675686754)
	call dispatch_TList_add(Setup_preloadAbi, 675686755)
	call dispatch_TList_add(Setup_preloadAbi, 675686756)
	call dispatch_TList_add(Setup_preloadAbi, 675686757)
	call dispatch_TList_add(Setup_preloadAbi, 675686758)
	call dispatch_TList_add(Setup_preloadAbi, 675686759)
	call dispatch_TList_add(Setup_preloadAbi, 675686760)
	call dispatch_TList_add(Setup_preloadAbi, 675686761)
	call dispatch_TList_add(Setup_preloadAbi, 675686701)
	call dispatch_TList_add(Setup_preloadAbi, 675752289)
	call dispatch_TList_add(Setup_preloadAbi, 675752290)
	call dispatch_TList_add(Setup_preloadAbi, 675752291)
	call dispatch_TList_add(Setup_preloadAbi, 675752292)
	call dispatch_TList_add(Setup_preloadAbi, 675752293)
	call dispatch_TList_add(Setup_preloadAbi, 675752294)
	call dispatch_TList_add(Setup_preloadAbi, 675752295)
	call dispatch_TList_add(Setup_preloadAbi, 675752296)
	call dispatch_TList_add(Setup_preloadAbi, 675752297)
	call dispatch_TList_add(Setup_preloadAbi, 675752237)
	call dispatch_TList_add(Setup_preloadAbi, 675817825)
	call dispatch_TList_add(Setup_preloadAbi, 675817826)
	call dispatch_TList_add(Setup_preloadAbi, 675817827)
	call dispatch_TList_add(Setup_preloadAbi, 675817828)
	call dispatch_TList_add(Setup_preloadAbi, 675817829)
	call dispatch_TList_add(Setup_preloadAbi, 675817830)
	call dispatch_TList_add(Setup_preloadAbi, 675817831)
	call dispatch_TList_add(Setup_preloadAbi, 675817832)
	call dispatch_TList_add(Setup_preloadAbi, 675817833)
	call dispatch_TList_add(Setup_preloadAbi, 675817773)
	call dispatch_TList_add(Setup_preloadAbi, 676800865)
	call dispatch_TList_add(Setup_preloadAbi, 676800866)
	call dispatch_TList_add(Setup_preloadAbi, 676800867)
	call dispatch_TList_add(Setup_preloadAbi, 676800868)
	call dispatch_TList_add(Setup_preloadAbi, 676800869)
	call dispatch_TList_add(Setup_preloadAbi, 676800870)
	call dispatch_TList_add(Setup_preloadAbi, 676800871)
	call dispatch_TList_add(Setup_preloadAbi, 676800872)
	call dispatch_TList_add(Setup_preloadAbi, 676800873)
	call dispatch_TList_add(Setup_preloadAbi, 676800874)
	call dispatch_TList_add(Setup_preloadAbi, 676800875)
	call dispatch_TList_add(Setup_preloadAbi, 676800876)
	call dispatch_TList_add(Setup_preloadAbi, 676735329)
	call dispatch_TList_add(Setup_preloadAbi, 676735330)
	call dispatch_TList_add(Setup_preloadAbi, 676735331)
	call dispatch_TList_add(Setup_preloadAbi, 676735332)
	call dispatch_TList_add(Setup_preloadAbi, 676735333)
	call dispatch_TList_add(Setup_preloadAbi, 676735334)
	call dispatch_TList_add(Setup_preloadAbi, 676735335)
	call dispatch_TList_add(Setup_preloadAbi, 676735336)
	call dispatch_TList_add(Setup_preloadAbi, 676735337)
	call dispatch_TList_add(Setup_preloadAbi, 676735338)
	call dispatch_TList_add(Setup_preloadAbi, 676735339)
	call dispatch_TList_add(Setup_preloadAbi, 676735340)
	call dispatch_TList_add(Setup_preloadAbi, 1213226795)
	call dispatch_TList_add(Setup_preloadAbi, 1213226797)
	call dispatch_TList_add(Setup_preloadAbi, 1297112875)
	call dispatch_TList_add(Setup_preloadAbi, 1297112877)
endfunction

function init_Spell takes nothing returns nothing
	set Spell_qSpellId = 852490
	set Spell_wSpellId = 852491
	set Spell_eSpellId = 852217
	set Spell_rSpellId = 852186
	set Spell_dSpellId = 852576
	set Spell_fSpellId = 852215
	set Spell_cleanSpellbook = 1514237281
endfunction

function init_SpellDesignConfig takes nothing returns nothing
	set SpellDesignConfig_TITLECOLOR = "|cff3B97D3"
	set SpellDesignConfig_TITLE_COOLDOWN = "Cooldown:"
	set SpellDesignConfig_TITLE_TTYPE = "Target Type:"
	set SpellDesignConfig_TITLE_EFFECT = "Effect:"
endfunction

function SamplePointSpellSetup_setSpellData takes integer ss returns integer
	call dispatch_SpellSetup_setSpell(ss, 1094861636)
	call dispatch_SpellSetup_setDummySpellBook(ss, 1162233672)
	call dispatch_SpellSetup_setMaxLvl(ss, 5)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 1, 1)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 2, 1)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 3, 2)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 4, 2)
	call dispatch_SpellSetup_setNeededSkillpoints(ss, 5, 3)
	return ss
endfunction

function init_SpellTemplate takes nothing returns nothing
	set SamplePointSpellSetup_setup = SamplePointSpellSetup_setSpellData(new_SpellSetup())
endfunction

function string_length takes string this_43 returns integer
	return StringLength(this_43)
endfunction

function init_String takes nothing returns nothing
	set String_charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	set String_numberset = "0123456789"
	set String_numbersetlength = string_length(String_numberset)
	set String_charsetlength = string_length(String_charset)
endfunction

function init_TList takes nothing returns nothing
	set TList_ht = InitHashtable()
endfunction

function init_Table takes nothing returns nothing
	set Table_ht = InitHashtable()
endfunction

function init_Terrain takes nothing returns nothing
	set Terrain_MAX_RANGE = 10.
	set Terrain_DUMMY_ITEM_ID = 2003790951
	set Terrain_tempLoc = Location(0., 0.)
	set Terrain_worldRect = GetWorldBounds()
	set Terrain_dItem = null
	set Terrain_find = null
	set Terrain_hidMax = 0
	set Terrain_X = 0.
	set Terrain_Y = 0.
	set Terrain_find = Rect(0., 0., 128., 128.)
	set Terrain_dItem = CreateItem(Terrain_DUMMY_ITEM_ID, 0., 0.)
	call SetItemVisible(Terrain_dItem, false)
	set Terrain_minWorldX = GetRectMinX(Terrain_worldRect)
	set Terrain_minWorldY = GetRectMinY(Terrain_worldRect)
	set Terrain_maxWorldX = GetRectMaxX(Terrain_worldRect)
	set Terrain_maxWorldY = GetRectMaxY(Terrain_worldRect)
endfunction

function Word_classname takes nothing returns string
	return "Word"
endfunction

function init_TextHelper takes nothing returns nothing
	set TextHelper_charLengthFactor = 0.95
	set Word_allWords = new_LinkedList()
	set ShowInstances_classId_4 = registerNewInstanceEntry(Word_classname())
endfunction

function init_TextTagEx takes nothing returns nothing
	set TextTagEx_standardColor_red = 255
	set TextTagEx_standardColor_green = 255
	set TextTagEx_standardColor_blue = 255
	set TextTagEx_standardColor_alpha = 255
	set TextTagEx_resizeRateConstant = 0.015
	set TextTagEx_fadeTicks = 8
	set TextTagEx_resizeTicks = 8
	set TextTagEx_timerOwner = new_HandleMap()
	set TextTagEx_tick = new_HandleMap()
endfunction

function init_TimedEffect takes nothing returns nothing
	set TimedEffect_effectData = new_Table()
endfunction

function init_TimerUtils takes nothing returns nothing
	set TimerUtils_freeTimersCount = 0
	set TimerUtils_timerData = new_Table()
	set TimerUtils_HELD = 679645218
endfunction

function init_Trackable takes nothing returns nothing
	set Trackable_trackData = new_HandleMap()
	set Trackable_doubleHitSpeed = 0.5
	set Trackable_doubleHitDetect = trigger_addAction(CreateTrigger(), ref_function_doubleHit)
	set Trackable_triggeringTrackable = null
endfunction

function alloc_HTable takes nothing returns integer
	local integer this_43
	if HTable_firstFree == 0 then
		set HTable_maxIndex = HTable_maxIndex + 1
		set this_43 = HTable_maxIndex
	else
		set this_43 = HTable_firstFree
		set HTable_firstFree = HTable_nextFree[HTable_firstFree]
		set HTable_nextFree[this_43] = 0
	endif
	set HTable_typeId[this_43] = 700
	return this_43
endfunction

function construct_HTable takes integer this_43 returns nothing
	set HTable_ht[this_43] = InitHashtable()
endfunction

function new_HTable takes nothing returns integer
	local integer this_43 = alloc_HTable()
	call construct_HTable(this_43)
	return this_43
endfunction

function init_TrackableEventHandler takes nothing returns nothing
	set TrackableEventHandler_trackableTrackAction = new_HTable()
	set TrackableEventHandler_trackableHitAction = new_HTable()
	set TrackableEventHandler_trackableDoubleHitAction = new_HTable()
	call trigger_addAction(Setup_trackableHitTrigger, ref_function_trackableHitHandler)
	call trigger_addAction(Setup_trackableTrackTrigger, ref_function_trackableTrackHandler)
	call trigger_addAction(Setup_trackableDoubleHitTrigger, ref_function_trackableDoubleHitHandler)
endfunction

function init_Trigger takes nothing returns nothing
	set Trigger_triggerData = new_Table()
endfunction

function init_TypeCasting takes nothing returns nothing
	set TypeCasting_typecastdata = new_Table()
endfunction

function Unit_classname takes nothing returns string
	return "Unit"
endfunction

function init_UnitClass takes nothing returns nothing
	set Unit_bounceFactor = 1.
	set Unit_knockbackFactor = 6000.
	set Unit_basicAttackspeed = 0.5
	set Unit_damageDetect = trigger_addAction(CreateTrigger(), ref_function_Unit_tookDamage)
	set ShowInstances_classId_3 = registerNewInstanceEntry(Unit_classname())
	set UnitClass_knocklist = new_TList()
endfunction

function main takes nothing returns nothing
	call initGlobals()
	call SetCameraBounds(( - 3328.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), ( - 3584.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), ( - 3328.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), ( - 3584.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
	call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
	call NewSoundEnvironment("Default")
	call SetAmbientDaySound("LordaeronSummerDay")
	call SetAmbientNightSound("LordaeronSummerNight")
	call SetMapMusic("Music", true, 0)
	call CreateCameras()
	call CreateAllUnits()
	call InitBlizzard()
	call InitGlobals()
	call InitCustomTriggers()
	call RunInitializationTriggers()
	call init_Char()
	call init_Table()
	call init_Trigger()
	call init_TimerUtils()
	call init_PrintingHelper()
	call init_String()
	call init_Maths()
	call init_Basics()
	call init_Rect()
	call init_TypeCasting()
	call init_BigNum()
	call init_Array()
	call init_TList()
	call init_Terrain()
	call init_Helper()
	call init_Dot()
	call init_ChannelSpellPreset()
	call init_SpellDesignConfig()
	call init_DebugFile()
	call init_HashMap()
	call init_Setup()
	call init_InstanceBoard()
	call init_FloatingText()
	call init_Colors()
	call init_Lightning()
	call init_HandleMap()
	call init_MapBounds()
	call init_GameTimer()
	call init_DummyRecycler()
	call init_TimedEffect()
	call init_ControlPoint()
	call init_UnitClass()
	call init_HeroBar()
	call init_OrderHandling()
	call init_PrimitiveIndexes()
	call init_PreloadHandler()
	call init_Spell()
	call init_Cooldown()
	call init_HeroClass()
	call init_CaptureAnimation()
	call init_ClosureEvents()
	call init_CustomBar()
	call init_Trackable()
	call init_HandleCounter()
	call init_PlayerClass()
	call init_Icon()
	call init_Menu()
	call init_TrackableEventHandler()
	call init_ImageEx()
	call init_SampleSpells()
	call init_GameStart()
	call init_Pull2()
	call init_RTable()
	call init_RockThrow()
	call init_RunningMazeChecker()
	call init_SpellTemplate()
	call init_TextHelper()
	call init_TextTagEx()
endfunction

function InitAllyPriorities takes nothing returns nothing
	call SetStartLocPrioCount(0, 1)
	call SetStartLocPrio(0, 0, 1, MAP_LOC_PRIO_HIGH)
	call SetStartLocPrioCount(1, 1)
	call SetStartLocPrio(1, 0, 0, MAP_LOC_PRIO_HIGH)
endfunction

function InitCustomPlayerSlots takes nothing returns nothing
	call SetPlayerStartLocation(Player(0), 0)
	call SetPlayerColor(Player(0), ConvertPlayerColor(0))
	call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
	call SetPlayerRaceSelectable(Player(0), true)
	call SetPlayerController(Player(0), MAP_CONTROL_USER)
	call SetPlayerStartLocation(Player(1), 1)
	call SetPlayerColor(Player(1), ConvertPlayerColor(1))
	call SetPlayerRacePreference(Player(1), RACE_PREF_ORC)
	call SetPlayerRaceSelectable(Player(1), true)
	call SetPlayerController(Player(1), MAP_CONTROL_USER)
endfunction

function config takes nothing returns nothing
	call SetMapName("Noch eine WARCRAFT-III-Karte")
	call SetMapDescription("Unbeschrieben")
	call SetPlayers(2)
	call SetTeams(2)
	call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
	call DefineStartLocation(0, 768.0,  - 512.0)
	call DefineStartLocation(1,  - 1856.0, 192.0)
	call InitCustomPlayerSlots()
	call SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
	call SetPlayerSlotAvailable(Player(1), MAP_CONTROL_USER)
	call InitGenericPlayerSlots()
	call InitAllyPriorities()
endfunction

